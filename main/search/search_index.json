{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to vAccel Documentation","text":"<p>vAccel is a lightweight, modular framework that exposes hardware acceleration functionality to workloads in virtualized or otherwise isolated environments \u00a0Read more </p> <ul> <li> <p> Get started</p> <p>Install vAccel and try the examples</p> <p> Start here</p> </li> <li> <p> Configuration</p> <p>Adjust runtime settings using environment variables</p> <p> Configure it</p> </li> <li> <p> Plugins</p> <p>Discover the available plugins and their usage</p> <p> Browse plugins</p> </li> <li> <p> API</p> <p>Learn how the API works</p> <p> Explore API</p> </li> <li> <p> Language bindings</p> <p>Use it with your preferred programming language</p> <p> See bindings</p> </li> <li> <p> Tutorials</p> <p>Step-by-step guides for common use cases</p> <p> Try a tutorial</p> </li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>vAccel can be configured at runtime using environment variables.</p>"},{"location":"configuration/#overview","title":"Overview","text":"Variable Name Description Expected Values Default <code>VACCEL_PLUGINS</code> Path(s) or filename(s) of backend plugin(s) Absolute path, filename, or <code>:</code>-separated list <code>VACCEL_LOG_LEVEL</code> Controls log verbosity <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> <code>1</code> <code>VACCEL_LOG_FILE</code> Filename of a log file Filename (without extension) <code>VACCEL_PROFILING_ENABLED</code> Enables or disables profiling <code>1</code>, <code>0</code> <code>0</code> <code>VACCEL_VERSION_IGNORE</code> If set, ignores plugin/lib version mismatches <code>1</code>, <code>0</code> <code>0</code> <code>VACCEL_BOOTSTRAP_ENABLED</code> Enables or disables lib auto-bootstrap <code>1</code>, <code>0</code> <code>1</code> <code>VACCEL_CLEANUP_ENABLED</code> Enables or disables lib auto-cleanup <code>1</code>, <code>0</code> <code>1</code>"},{"location":"configuration/#description","title":"Description","text":""},{"location":"configuration/#vaccel_plugins","title":"<code>VACCEL_PLUGINS</code>","text":"<p>Specifies one or more plugins to be used as backends.</p> <p>Expected values:</p> <ul> <li>An absolute path (e.g., <code>/usr/local/lib/libvaccel-noop.so</code>)</li> <li>A filename that can be found in standard library locations (e.g.,   <code>libvaccel-noop.so</code>)</li> <li>A colon-separated (<code>:</code>) list of absolute paths or filenames</li> </ul>"},{"location":"configuration/#vaccel_log_level","title":"<code>VACCEL_LOG_LEVEL</code>","text":"<p>Sets the verbosity of logging output.</p> <p>Expected values:</p> <ul> <li><code>1</code> \u2013 Critical errors or errors that require attention</li> <li><code>2</code> \u2013 Warnings that indicate potential issues</li> <li><code>3</code> \u2013 General application events</li> <li><code>4</code> \u2013 Detailed debug logs for development and troubleshooting</li> </ul> <p>Default: <code>1</code></p>"},{"location":"configuration/#vaccel_log_file","title":"<code>VACCEL_LOG_FILE</code>","text":"<p>Specifies the filename (without the extension) of the log file where application logs will be written.</p> <p>The file is created in the current directory and the date and extension are automatically appended to the filename with the format <code>-&lt;YYYY&gt;-&lt;MM&gt;-&lt;DD&gt;.log</code>. If no path is provided, logs are written to standard output (<code>stdout</code>)</p> <p>Expected values:</p> <ul> <li>A filename for the log file (e.g., <code>mylog</code>)</li> </ul>"},{"location":"configuration/#vaccel_profiling_enabled","title":"<code>VACCEL_PROFILING_ENABLED</code>","text":"<p>Controls whether profiling is enabled or disabled.</p> <p>Expected values:</p> <ul> <li><code>1</code> \u2013 Enables profiling</li> <li><code>0</code> \u2013 Disables profiling</li> </ul> <p>Default: <code>0</code></p>"},{"location":"configuration/#vaccel_version_ignore","title":"<code>VACCEL_VERSION_IGNORE</code>","text":"<p>Controls whether to ignore a mismatch between the plugin vAccel version and the core vAccel library version.</p> <p>Expected values:</p> <ul> <li><code>1</code> \u2013 Ignore version mismatch</li> <li><code>0</code> \u2013 Do not ignore version mismatch</li> </ul> <p>Default: <code>0</code></p>"},{"location":"configuration/#vaccel_bootstrap_enabled","title":"<code>VACCEL_BOOTSTRAP_ENABLED</code>","text":"<p>Controls whether to bootstrap the vAccel components upon loading the library. Useful when setting <code>vaccel_config</code> programmatically, so the library can be configured before bootstrapping the components.</p> <p>Expected values:</p> <ul> <li><code>1</code> \u2013 Bootstrap components on library load</li> <li><code>0</code> \u2013 Do not bootstrap components on library load</li> </ul> <p>Default: <code>1</code></p>"},{"location":"configuration/#vaccel_cleanup_enabled","title":"<code>VACCEL_CLEANUP_ENABLED</code>","text":"<p>Controls whether to automatically cleanup the allocated objects upon unloading the vAccel library.</p> <p>Expected values:</p> <ul> <li><code>1</code> \u2013 Cleanup components on library unload</li> <li><code>0</code> \u2013 Do not cleanup components on library unload</li> </ul> <p>Default: <code>1</code></p>"},{"location":"overview/","title":"Overview","text":"<p>vAccel is a lightweight, modular framework that exposes hardware acceleration functionality to workloads in virtualized or otherwise isolated environments. It enables transparent offloading of compute-intensive operations to acceleration backends, abstracting away platform-specific details through a unified API and plugin interface.</p> <p>The vAccel framework decouples applications from hardware-specific logic, enabling binary portability across diverse hardware platforms and system configurations, including deployments where accelerators are not directly accessible from the application context.</p> <p> </p> <p>vAccel software stack  </p>"},{"location":"overview/#core-design-principles","title":"Core Design Principles","text":"<ul> <li> <p>Portability: Applications built with vAccel can be deployed across systems   with differing accelerator types and configurations without requiring source   changes or recompilation.</p> </li> <li> <p>Security: Supports hardware-accelerated execution within strong isolation   boundaries, including KVM-based VMs (eg., QEMU, Firecracker, Cloud   Hypervisor).</p> </li> <li> <p>Modularity: vAccel supports a plugin-based architecture for backend   accelerators, allowing hardware-specific implementations to be developed and   maintained independently.</p> </li> <li> <p>Efficiency: Communication between guest and host is handled through   low-overhead transports such as <code>VirtIO</code>, <code>VSOCK</code>, or <code>TCP</code>, minimizing   performance loss.</p> </li> <li> <p>Scalability: vAccel integrates natively with Kubernetes to support   large-scale, multi-tenant deployments of acceleration-enabled workloads.</p> </li> </ul>"},{"location":"overview/#key-features","title":"Key Features","text":"<ul> <li> <p>Rich Architecture Support: Native support for amd64, arm, and arm64   platforms, including cross-compiled deployments and heterogeneous cluster   environments.</p> </li> <li> <p>CI-Driven Development: An end-to-end CI pipeline validates functionality   across multiple backends, host/guest combinations, and transport modes. All   core components and language bindings are continuously tested for correctness   and performance.</p> </li> <li> <p>Dynamic Model Inference: Enhanced support for frameworks like PyTorch (via   <code>jitload_forward</code>) and TensorFlow, enabling runtime-loaded model execution   inside isolated environments.</p> </li> <li> <p>Language Bindings: Native bindings available for Go and Python, enabling   rapid prototyping and integration into existing ML/AI pipelines and   cloud-native workflows.</p> </li> </ul>"},{"location":"overview/#vaccel-architecture","title":"vAccel Architecture","text":"<p>At its core, vAccel consists of:</p> <ul> <li> <p>A core library, exposing the vAccel API to applications.</p> </li> <li> <p>A plugin system, where backend modules handle calls to specific   accelerator runtimes.</p> </li> </ul> <p>This layered design allows applications to remain agnostic of the underlying accelerator or transport mechanism.</p> <p>Info</p> <p>Find out more about the different components and how they interact in the Architecture page.</p>"},{"location":"overview/#virtualization-and-transport","title":"Virtualization and Transport","text":"<p>vAccel is designed to operate seamlessly in virtualized environments. Instead of relying on device pass-through or vendor-specific drivers, vAccel exposes coarse-grained acceleration operations to guest workloads over generic, extensible transports. Implementations include:</p> <ul> <li> <p>VirtIO (with QEMU and Firecracker support)</p> </li> <li> <p>RPC (VSOCK, TCP and UNIX sockets)</p> </li> </ul> <p>These transports allow flexible deployment across a range of hypervisors and system configurations.</p> <p>Info</p> <p>More details are available in the Transport Plugins page.</p>"},{"location":"overview/#performance","title":"Performance","text":"<p>vAccel introduces minimal overhead compared to native execution. Benchmarks across real-world inference tasks and varied payload sizes consistently demonstrate near-native performance, with less than 5% overhead in most configurations.</p>"},{"location":"api/","title":"API","text":"<p>Learn how the API works:</p> <ul> <li>API guide</li> <li>API reference</li> </ul>"},{"location":"api/api-guide/","title":"API guide","text":"<p>Learn more about the different API components:</p> <ul> <li>Operations API</li> </ul>"},{"location":"api/api-guide/operations/","title":"Operations API","text":"<p>The Operations API consists of the vAccel acceleration functions. More specifically, it includes the \"definitions\" - interface - of the functions (operations) that can be implemented by the plugins.</p>"},{"location":"api/api-guide/operations/#overview","title":"Overview","text":"<p>Each operation is defined in two ways:</p> <ol> <li>An operation type that is used to identify the operation</li> <li>An actual function that maps the function interface to the plugin    function</li> </ol> <p>For example, you can have a look at the definitions of the simple <code>SGEMM</code> operation that handles matrix to matrix multiplication.</p> <p>The operation type (<code>VACCEL_OP_BLAS_SGEMM</code>) is defined in the public op.h:</p> src/include/vaccel/op.h<pre><code>...\n/* Define vaccel_op_type_t, vaccel_op_type_to_str() and\n * vaccel_op_type_to_base_str() */\n#define _ENUM_PREFIX VACCEL_OP\n#define VACCEL_OP_TYPE_ENUM_LIST(VACCEL_ENUM_ITEM)            \\\n...\n        VACCEL_ENUM_ITEM(BLAS_SGEMM, _ENUM_PREFIX)            \\\n...\n</code></pre> <p>The <code>vaccel_sgemm</code> function corresponding to the operation type is defined in blas.c and exported internally with blas.h:</p> src/ops/blas.c<pre><code>int vaccel_sgemm(struct vaccel_session *sess, long long int m, long long int n,\n                 long long int k, float alpha, float *a, long long int lda,\n                 float *b, long long int ldb, float beta, float *c,\n                 long long int ldc)\n{\n        int ret;\n...\n        sgemm_fn_t plugin_sgemm =\n                plugin_get_op_func(VACCEL_OP_BLAS_SGEMM, sess-&gt;hint);\n        if (!plugin_sgemm) {\n                ret = VACCEL_ENOTSUP;\n                goto out;\n        }\n\n        ret = plugin_sgemm(sess, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);\n...\n        return ret;\n}\n</code></pre> <p>The plugin function for <code>VACCEL_OP_BLAS_SGEMM</code> is loaded with <code>plugin_get_op_func()</code>. That is how a user calling <code>vaccel_sgemm</code> gets the plugin implementation of the function.</p> <p>To actually build an operation, you also also have to add these two files to the build system:</p> src/ops/meson.build<pre><code>vaccel_headers += files([\n  'blas.h',\n...\n])\n\nvaccel_sources += files([\n  'blas.c',\n...\n])\n</code></pre>"},{"location":"api/api-guide/operations/#special-operations","title":"Special operations","text":"<p>To facilitate development of transport plugins and integration with existing projects, vAccel provides some special-purpose operations.</p>"},{"location":"api/api-guide/operations/#the-generic-operation-genop","title":"The Generic operation (<code>GenOp</code>)","text":"<p>While defining a new operation is relatively simple, any new operation needs to be implemented for the transport plugins. To simplify addition of new operations with minimal modifications to the transport plugins, vAccel defines the Generic operation (<code>GenOp</code>).</p> <p><code>GenOp</code> provides a generic interface to pass arguments to an operation. Any operation that has a <code>GenOp</code> variant can be supported by a transport plugin with minimal modifications to the plugin itself, provided <code>GenOp</code> is already implemented in the transport layer.</p> <p>To add <code>GenOp</code> support for an operation you need to define an <code>unpack</code> function that will convert the generic arguments to the actual function arguments.</p> <p>Revisiting blas.c from above, the relevant <code>vaccel_sgemm_unpack</code> is:</p> src/ops/blas.c<pre><code>int vaccel_sgemm_unpack(struct vaccel_session *sess, struct vaccel_arg *read,\n                        int nr_read, struct vaccel_arg *write, int nr_write)\n{\n...\n        long long int m = *(long long int *)read[0].buf;\n        long long int n = *(long long int *)read[1].buf;\n        long long int k = *(long long int *)read[2].buf;\n        float alpha = *(float *)read[3].buf;\n        float *a = (float *)read[4].buf;\n        long long int lda = *(long long int *)read[5].buf;\n        float *b = (float *)read[6].buf;\n        long long int ldb = *(long long int *)read[7].buf;\n        float beta = *(float *)read[8].buf;\n        long long int ldc = *(long long int *)read[9].buf;\n\n        float *c = (float *)write[0].buf;\n\n        return vaccel_sgemm(sess, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);\n}\n</code></pre> <p>Each <code>vaccel_sgemm</code> argument is expected as <code>vaccel_arg</code> in a specific order.</p> <p>To define the function as a genop unpacking function you also need to add it to the <code>callbacks</code> array in the same place as <code>VACCEL_OP_BLAS_SGEMM</code> is defined in the respective enum:</p> src/ops/genop.c<pre><code>...\nunpack_func_t callbacks[VACCEL_OP_MAX] = {\n...\n        vaccel_sgemm_unpack, /* 1 */\n...\n};\n...\n</code></pre> <p>An example of the relevant \"packing\" of the arguments can be found in the <code>sgemm_generic</code> example:</p> examples/sgemm_generic.c<pre><code>...\nint main(int argc, char *argv[])\n{\n...\n        vaccel_op_type_t op_type = VACCEL_OP_BLAS_SGEMM;\n        struct vaccel_arg read[] = {\n                { .size = sizeof(vaccel_op_type_t), .buf = &amp;op_type },\n                { .size = sizeof(m), .buf = &amp;m },\n                { .size = sizeof(n), .buf = &amp;n },\n                { .size = sizeof(k), .buf = &amp;k },\n                { .size = sizeof(alpha), .buf = (void *)&amp;alpha },\n                { .size = sizeof(a), .buf = a },\n                { .size = sizeof(k), .buf = &amp;k },\n                { .size = sizeof(b), .buf = b },\n                { .size = sizeof(n), .buf = &amp;n },\n                { .size = sizeof(beta), .buf = (void *)&amp;beta },\n                { .size = sizeof(n), .buf = &amp;n },\n        };\n        struct vaccel_arg write[] = {\n                { .size = sizeof(c), .buf = c },\n        };\n...\n                ret = vaccel_genop(&amp;sess, read, sizeof(read) / sizeof(read[0]),\n                                   write, sizeof(write) / sizeof(write[0]));\n...\n}\n</code></pre>"},{"location":"api/api-guide/operations/#the-exec-operation","title":"The Exec operation","text":"<p>Adding operations requires modification and rebuilding of vAccel itself. To use an unmodified vAccel with a new operation, you can take advantage of the <code>Exec</code> operation.</p> <p>The <code>Exec</code> operation - combined with the <code>Exec</code> plugin - enables execution of functions from arbitrary libraries without requiring the addition of new operations. The operation's usage is similar to <code>GenOp</code>, described above.</p> <p>While the <code>Exec</code> workflow can be support new operations without modifying vAccel, it must be used with caution in shared systems, since it allows the execution of arbitrary functions.</p>"},{"location":"api/api-reference/","title":"API reference","text":"<p>View the API of the various components:</p> <ul> <li>Operations API</li> </ul>"},{"location":"api/api-reference/operations/","title":"Operations API","text":"<p>This page presents the current form of the vAccel Operations API that consists of the interfaces of the acceleration functions (operations) supported by vAccel. Using this API users can build vAccel applications that interface directly with <code>libvaccel.so</code> and their operations can be executed using vAccel plugins.</p>"},{"location":"api/api-reference/operations/#image-inference","title":"Image inference","text":"<p>vAccel supports a set of operations for Image inference using the following primitive functions (per operation):</p>"},{"location":"api/api-reference/operations/#image-classification","title":"Image classification","text":"<p>The image classification operation, that receives an image (in the form of bytes) and a an optional model (as a vAccel resource) and returns the classification labels:</p> <pre><code>int vaccel_image_classification(struct vaccel_session *sess, const void *img,\n                                unsigned char *out_text, unsigned char *out_imgname,\n                                size_t len_img, size_t len_out_text, size_t len_out_imgname);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>const void *img</code>: the buffer holding the data to the input image.</li> <li><code>unsigned char *out_text</code>: the buffer holding the classification tag output</li> <li><code>unsigned char *out_imgname</code>: the name of the processed image, created as a   session resource (EXPERIMENTAL).</li> <li><code>size_t len_img</code>: the size of <code>img</code> in bytes.</li> <li><code>size_t len_out_text</code>: the size of <code>out_text</code> in bytes.</li> <li><code>size_t len_out_imgname</code>: the size of <code>out_imagename</code> in bytes.</li> </ul>"},{"location":"api/api-reference/operations/#image-segmentation","title":"Image segmentation","text":"<pre><code>int vaccel_image_segmentation(struct vaccel_session *sess, const void *img,\n                              unsigned char *out_imgname, size_t len_img,\n                              size_t len_out_imgname);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>const void *img</code>: the buffer holding the data to the input image.</li> <li><code>unsigned char *out_imgname</code>: the name of the processed image, created as a   session resource (EXPERIMENTAL).</li> <li><code>size_t len_img</code>: the size of <code>img</code> in bytes.</li> <li><code>size_t len_out_imgname</code>: the size of <code>out_imagename</code> in bytes.</li> </ul>"},{"location":"api/api-reference/operations/#object-detection","title":"Object detection","text":"<pre><code>int vaccel_image_detection(struct vaccel_session *sess, const void *img,\n                           unsigned char *out_imgname, size_t len_img,\n                           size_t len_out_imgname);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>const void *img</code>: the buffer holding the data to the input image.</li> <li><code>unsigned char *out_imgname</code>: the name of the processed image, created as a   session resource (EXPERIMENTAL).</li> <li><code>size_t len_img</code>: the size of <code>img</code> in bytes.</li> <li><code>size_t len_out_imgname</code>: the size of <code>out_imagename</code> in bytes.</li> </ul>"},{"location":"api/api-reference/operations/#pose-estimation","title":"Pose estimation","text":"<pre><code>int vaccel_image_pose(struct vaccel_session *sess, const void *img,\n                      unsigned char *out_imgname, size_t len_img,\n                      size_t len_out_imgname);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>const void *img</code>: the buffer holding the data to the input image.</li> <li><code>unsigned char *out_imgname</code>: the name of the processed image, created as a   session resource (EXPERIMENTAL).</li> <li><code>size_t len_img</code>: the size of <code>img</code> in bytes.</li> <li><code>size_t len_out_imgname</code>: the size of <code>out_imagename</code> in bytes.</li> </ul>"},{"location":"api/api-reference/operations/#monocular-depth","title":"Monocular Depth","text":"<pre><code>int vaccel_image_depth(struct vaccel_session *sess, const void *img,\n                       unsigned char *out_imgname, size_t len_img,\n                       size_t len_out_imgname);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>const void *img</code>: the buffer holding the data to the input image.</li> <li><code>unsigned char *out_imgname</code>: the name of the processed image, created as a   session resource (EXPERIMENTAL).</li> <li><code>size_t len_img</code>: the size of <code>img</code> in bytes.</li> <li><code>size_t len_out_imgname</code>: the size of <code>out_imagename</code> in bytes.</li> </ul>"},{"location":"api/api-reference/operations/#blas-library-functions","title":"BLAS library functions","text":""},{"location":"api/api-reference/operations/#matrix-to-matrix-multiplication","title":"Matrix-to-matrix multiplication","text":"<pre><code>int vaccel_sgemm(struct vaccel_session *sess, long long int m, long long int n,\n                 long long int k, float *alpha, float *a, long long int lda,\n                 float *b, long long int ldb, float beta, float *c,\n                 long long int ldc);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>long long int m</code>: first dimension of matrix A &amp; matrix C.</li> <li><code>long long int n</code>: second dimension of matrix A &amp; first dimension of matrix B.</li> <li><code>long long int k</code>: second dimension of matrix B &amp; matrix C.</li> <li><code>long long int lda</code>: size of matrix A in bytes.</li> <li><code>long long int ldb</code>: size of matrix B in bytes.</li> <li><code>long long int ldc</code>: size of matrix C in bytes.</li> <li><code>float *a</code>: pointer to matrix A.</li> <li><code>float *b</code>: pointer to matrix B.</li> <li><code>float *c</code>: pointer to matrix C.</li> <li><code>float alpha</code>: the floating point number to be used in <code>alpha</code> X (<code>A</code> X <code>B</code>) +   <code>beta</code> X <code>C</code>.</li> <li><code>float beta</code>: the floating point number to be used in <code>alpha</code> X (<code>A</code> X <code>B</code>) +   <code>beta</code> X <code>C</code>.</li> </ul>"},{"location":"api/api-reference/operations/#array-copy","title":"Array copy","text":"<pre><code>int vaccel_fpga_arraycopy(struct vaccel_session *sess, int array[],\n                          int out_array[], size_t len_array);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>int a[]</code>: input array.</li> <li><code>int out_a[]</code>: output array.</li> <li><code>size_t len_a</code>: length of input &amp; output arrays.</li> </ul>"},{"location":"api/api-reference/operations/#matrix-to-matrix-multiplication-simple","title":"Matrix-to-matrix multiplication simple","text":"<pre><code>int vaccel_fpga_mmult(struct vaccel_session *sess, float a[], float b[],\n                      float c[], size_t len_a);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>float a[]</code>: input array A.</li> <li><code>float b[]</code>: input array B.</li> <li><code>float c[]</code>: output array C.</li> <li><code>size_t len_a</code>: length of array A.</li> </ul>"},{"location":"api/api-reference/operations/#matrix-to-matrix-multiplication-and-addition-simple-wip","title":"Matrix-to-matrix multiplication and addition simple [WiP]","text":"<pre><code>int vaccel_fpga_parallel(struct vaccel_session *sess, float a[], float b[],\n                         float add_output[], float mult_output[], size_t len_a);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>float a[]</code>: input array A.</li> <li><code>float b[]</code>: input array B.</li> <li><code>float add_output[]</code>: addition output array.</li> <li><code>float mult_output[]</code>: multiplication output array.</li> <li><code>size_t len_a</code>: length of array A.</li> </ul>"},{"location":"api/api-reference/operations/#vector-add","title":"Vector add","text":"<pre><code>int vaccel_fpga_vadd(struct vaccel_session *sess, float a[], float b[],\n                     float c[], size_t len_a, size_t len_b);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>float a[]</code>: input array A.</li> <li><code>float b[]</code>: input array B.</li> <li><code>float c[]</code>: output array C.</li> <li><code>size_t len_a</code>: length of array A.</li> <li><code>size_t len_b</code>: length of array B.</li> </ul>"},{"location":"api/api-reference/operations/#generic-executors","title":"Generic executors","text":""},{"location":"api/api-reference/operations/#exec","title":"Exec","text":"<pre><code>int vaccel_exec(struct vaccel_session *sess, const char *library,\n                const char *fn_symbol, struct vaccel_arg *read,\n                size_t nr_read, struct vaccel_arg *write, size_t nr_write);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>const char *library</code>: name of the shared object to open.</li> <li><code>const char *fn_symbol</code>: name of the symbol to dereference in the shared   object <code>library</code>.</li> <li><code>struct vaccel_arg *read</code>: pointer to an array of <code>struct vaccel_arg</code>   read-only arguments to <code>fn_symbol</code>.</li> <li><code>size_t nr_read</code>: number of elements for the <code>read</code> array.</li> <li><code>struct vaccel_arg *write</code>: pointer to an array of <code>struct vaccel_arg</code>   write-only arguments to <code>fn_symbol</code>.</li> <li><code>size_t nr_write</code>: number of elements for the <code>write</code> array.</li> </ul>"},{"location":"api/api-reference/operations/#exec-with-resource","title":"Exec with resource","text":"<pre><code>int vaccel_exec_with_resource(struct vaccel_session *sess,\n                              struct vaccel_resource *resource,\n                              const char *fn_symbol, struct vaccel_arg *read,\n                              size_t nr_read, struct vaccel_arg *write,\n                              size_t nr_write);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>struct vaccel_resource *resource</code>: pointer to a vAccel resource which   contains the shared object created using <code>vaccel_resource_init()</code> or similar   vAccel function, and registered to a session using   <code>vaccel_resource_register()</code>.</li> <li><code>const char *fn_symbol</code>: name of the symbol to dereference in the shared   object <code>library</code>.</li> <li><code>struct vaccel_arg *read</code>: pointer to an array of <code>struct vaccel_arg</code>   read-only arguments to <code>fn_symbol</code>.</li> <li><code>size_t nr_read</code>: number of elements for the <code>read</code> array.</li> <li><code>struct vaccel_arg *write</code>: pointer to an array of <code>struct vaccel_arg</code>   write-only arguments to <code>fn_symbol</code>.</li> <li><code>size_t nr_write</code>: number of elements for the <code>write</code> array.</li> </ul>"},{"location":"api/api-reference/operations/#tensorflow-operations","title":"TensorFlow operations","text":""},{"location":"api/api-reference/operations/#tensorflow-model-load","title":"TensorFlow model load","text":"<pre><code>int vaccel_tf_model_load(struct vaccel_session *session,\n                         struct vaccel_resource *model,\n                         struct vaccel_tf_status *status);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>struct vaccel_resource *model</code>: a vAccel resource structure, created using   <code>vaccel_resource_init()</code> or similar vAccel function, and registered to a   session using <code>vaccel_resource_register()</code>. Internally, it contains the model   to be used.</li> <li><code>struct vaccel_tf_status *status</code>: status of the TF operation.</li> </ul>"},{"location":"api/api-reference/operations/#tensorflow-model-unload","title":"TensorFlow model unload","text":"<pre><code>int vaccel_tf_model_unload(struct vaccel_session *sess,\n                           struct vaccel_resource *model,\n                           struct vaccel_tf_status *status);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>struct vaccel_resource *model</code>: a vAccel resource structure that has been   previously loaded using <code>vaccel_tf_model_load()</code>.</li> <li><code>struct vaccel_tf_status *status</code>: status of the TF operation.</li> </ul>"},{"location":"api/api-reference/operations/#tensorflow-model-run","title":"TensorFlow model run","text":"<pre><code>int vaccel_tf_model_run(struct vaccel_session *sess,\n                        const struct vaccel_resource *model,\n                        const struct vaccel_tf_buffer *run_options,\n                        const struct vaccel_tf_node *in_nodes,\n                        struct vaccel_tf_tensor *const *in_tensors,\n                        int nr_inputs, const struct vaccel_tf_node *out_nodes,\n                        struct vaccel_tf_tensor **out_tensors, int nr_outputs,\n                        struct vaccel_tf_status *status);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>struct vaccel_resource *model</code>: a vAccel resource structure. It should have   been loaded previously with <code>vaccel_tf_model_load()</code>.</li> <li><code>const struct vaccel_tf_buffer *run_options</code>: runtime parameters for the TF   instance in the form of <code>{data, size}</code>.</li> <li><code>const struct vaccel_tf_node *in_nodes</code>: array of input nodes.</li> <li><code>const struct vaccel_tf_tensor *const *in_tensors</code>: array of input tensors.</li> <li><code>int nr_inputs</code>: length of input nodes/tensors array.</li> <li><code>const struct vaccel_tf_node *out_nodes</code>: array of output nodes.</li> <li><code>const struct vaccel_tf_tensor **out_tensors</code>: array of output tensors.</li> <li><code>int nr_outputs</code>: length of output nodes/tensors array.</li> <li><code>struct vaccel_tf_status *status</code>: status of the TF operation.</li> </ul>"},{"location":"api/api-reference/operations/#tensorflow-lite-operations","title":"TensorFlow Lite operations","text":""},{"location":"api/api-reference/operations/#tensorflow-lite-model-load","title":"TensorFlow Lite model load","text":"<pre><code>int vaccel_tflite_model_load(struct vaccel_session *sess,\n                             struct vaccel_resource *model);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>struct vaccel_resource *model</code>: a vAccel resource structure that represents   the TFLite model, created using <code>vaccel_resource_init()</code> or similar vAccel   function, and registered to a session using <code>vaccel_resource_register()</code>.</li> </ul>"},{"location":"api/api-reference/operations/#tensorflow-lite-model-unload","title":"TensorFlow Lite model unload","text":"<pre><code>int vaccel_tflite_model_unload(struct vaccel_session *sess,\n                               struct vaccel_resource *model);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>struct vaccel_resource *model</code>: a vAccel resource structure that has been   previously loaded using <code>vaccel_tflite_model_load()</code>.</li> </ul>"},{"location":"api/api-reference/operations/#tensorflow-lite-model-run","title":"TensorFlow Lite model run","text":"<pre><code>int vaccel_tflite_model_run(struct vaccel_session *sess,\n                            const struct vaccel_resource *model,\n                            struct vaccel_tflite_tensor *const *inputs,\n                            int nr_inputs,\n                            struct vaccel_tflite_tensor **outputs,\n                            int nr_outputs, uint8_t *status);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>const struct vaccel_resource *model</code>: a vAccel resource structure. It should   have been loaded previously with <code>vaccel_tflite_model_load()</code>.</li> <li><code>struct vaccel_tflite_tensor *const *inputs</code>: array of input tensors.</li> <li><code>int nr_inputs</code>: length of input tensors array.</li> <li><code>struct vaccel_tflite_tensor **outputs</code>: array of output tensors.</li> <li><code>int nr_outputs</code>: length of output tensors array.</li> <li><code>uint8_t *status</code>: status of the TFLite operation.</li> </ul>"},{"location":"api/api-reference/operations/#torch-operations","title":"Torch operations","text":""},{"location":"api/api-reference/operations/#torch-model-load","title":"Torch model load","text":"<pre><code>int vaccel_torch_model_load(struct vaccel_session *sess,\n                            const struct vaccel_resource *model);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>struct vaccel_resource *model</code>: a vAccel resource structure that represents   the Torch model, created using <code>vaccel_resource_init()</code> or similar vAccel   function, and registered to a session using <code>vaccel_resource_register()</code>.</li> </ul>"},{"location":"api/api-reference/operations/#torch-model-run","title":"Torch model run","text":"<p>The generic Torch operation, which can be used to run inference on any PyTorch model, having tensors as input and output:</p> <pre><code>int vaccel_torch_model_run(struct vaccel_session *sess,\n                           const struct vaccel_resource *model,\n                           const struct vaccel_torch_buffer *run_options,\n                           struct vaccel_torch_tensor *const *inputs,\n                           int nr_inputs, struct vaccel_torch_tensor **outputs,\n                           int nr_outputs);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session, created with   <code>vaccel_session_init()</code>.</li> <li><code>const struct vaccel_resource *model</code>: a vAccel resource structure to hold the   model. It should have been previously created with <code>vaccel_resource_init()</code> or   similar vAccel function and registered to the input session by using   <code>vaccel_resource_register()</code>.</li> <li><code>const struct vaccel_torch_buffer *run_options</code>: a buffer to hold other data   that may be useful for the plugin. It may be empty.</li> <li><code>struct vaccel_torch_tensor *const *inputs</code>: array of input tensors.</li> <li><code>int nr_inputs</code>: length of input tensors array.</li> <li><code>struct vaccel_torch_tensor **outputs</code>: array of output tensors.</li> <li><code>int nr_outputs</code>: length of output tensors array.</li> </ul>"},{"location":"api/api-reference/operations/#torch-matrix-to-matrix-multiplication","title":"Torch matrix-to-matrix multiplication","text":"<p>An operation that performs the classic single-precision general matrix multiplication (SGEMM):</p> <pre><code>int vaccel_torch_sgemm(struct vaccel_session *sess,\n                       struct vaccel_torch_tensor **in_A,\n                       struct vaccel_torch_tensor **in_B,\n                       struct vaccel_torch_tensor **in_C, int M, int N, int K,\n                       struct vaccel_torch_tensor **out);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>struct vaccel_torch_tensor **in_A</code>: pointer to input tensor A.</li> <li><code>struct vaccel_torch_tensor **in_B</code>: pointer to input tensor B.</li> <li><code>struct vaccel_torch_tensor **in_C</code>: pointer to input tensor C.</li> <li><code>int M</code>: first dimension of matrix A &amp; matrix C.</li> <li><code>int N</code>: second dimension of matrix B &amp; matrix C.</li> <li><code>int K</code>: second dimension of matrix A &amp; first dimension of matrix B.</li> <li><code>struct vaccel_torch_tensor **out</code>: the tensor that will hold the output   tensor.</li> </ul>"},{"location":"api/api-reference/operations/#misc-operations","title":"Misc operations","text":""},{"location":"api/api-reference/operations/#minmax","title":"MinMax","text":"<pre><code>int vaccel_minmax(struct vaccel_session *sess, const double *indata,\n                  int ndata, int low_threshold, int high_threshold,\n                  double *outdata, double *min, double *max);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created using   <code>vaccel_session_init()</code>.</li> <li><code>const double *indata</code>: input data (text file, one number per line).</li> <li><code>int ndata</code>: input size (number of lines).</li> <li><code>int low_threshold</code>: lower threshold for the minmax algorithm.</li> <li><code>int high_threshold</code>: higher threshold for the minmax algorithm.</li> <li><code>double *outdata</code>: array of output data.</li> <li><code>double *min</code>: minimum number from input data set.</li> <li><code>double *max</code>: maximum number from input data set.</li> </ul>"},{"location":"api/api-reference/operations/#generic-operation","title":"Generic operation","text":"<p>vAccel supports a generic operation that can be used to run all supported operations:</p> <pre><code>int vaccel_genop(struct vaccel_session *sess, struct vaccel_arg *read,\n                 int nr_read, struct vaccel_arg *write, int nr_write);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created with   <code>vaccel_session_init()</code>.</li> <li><code>struct vaccel_arg *read</code>: the read arguments to be passed to the operation.   The first argument should be the operation type, a <code>vaccel_op_type_t</code>   instance.</li> <li><code>int nr_read</code>: the number of the input arguments.</li> <li><code>struct vaccel_arg *write</code>: the buffer that will hold the output arguments,   after the end of the operation.</li> <li><code>int nr_write</code>: the number of the write arguments.</li> </ul>"},{"location":"api/api-reference/operations/#debug-operation","title":"Debug operation","text":"<p>vAccel supports the no-op operation, which can be used for debugging purposes:</p> <pre><code>int vaccel_noop(struct vaccel_session *sess);\n</code></pre> <ul> <li><code>struct vaccel_session *sess</code>: a pointer to a vAccel session created with   <code>vaccel_session_init()</code>.</li> </ul>"},{"location":"development/","title":"Development","text":"<p>Learn more about the development process of vAccel:</p> <ul> <li>CI Infrastructure</li> <li>Contributing</li> </ul>"},{"location":"development/ci/","title":"Continuous Integration (CI)","text":"<p>The vAccel project uses a Kubernetes-native, multi-architecture CI infrastructure designed for reliability, scalability, and reuse across all repositories in the ecosystem. CI is built around GitHub Actions, self-hosted runners, and reusable workflows.</p>"},{"location":"development/ci/#architecture-overview","title":"Architecture Overview","text":"<ul> <li>Runner Orchestration: Self-hosted runners are managed using   GitHub Actions Runner Controller (ARC)   on a K3s cluster.</li> <li>Provisioning: VMs are dynamically spawned via   Incus on <code>x86_64</code> and <code>arm64</code> bare-metal   nodes.</li> <li>Bootstrap: Each VM joins the cluster on boot and registers as a member to   the joint K3s control plane.</li> </ul>"},{"location":"development/ci/#supported-runner-tags","title":"Supported Runner Tags","text":"Tag Description <code>base</code> Toolchains: GCC, Clang/LLVM, Rust, Go, Python <code>torch</code> PyTorch stack with OpenCV, Torch runtime <code>tensorflow</code> TensorFlow runtime and libraries <code>tvm</code> TVM runtime and compiler stack <code>jetson</code> Jetson AGX platform with JetPack &amp; CUDA"},{"location":"development/ci/#ci-directory-structure","title":"CI Directory Structure","text":"<p>Each repository in the vAccel ecosystem uses a standardized <code>.github/</code> layout:</p>"},{"location":"development/ci/#githubactions","title":"<code>.github/actions/</code>","text":"<p>Reusable GitHub Actions for CI tasks. Example: <code>build</code></p> <ul> <li>Modular and script-driven</li> <li>Automatically handles multi-arch builds</li> <li>Plugin-agnostic logic (based on <code>meson</code>)</li> </ul>"},{"location":"development/ci/#githubworkflows","title":"<code>.github/workflows/</code>","text":"<p>Top-level workflows that coordinate testing, building, and artifact handling.</p> <ul> <li> <p>[<code>pr-build-and-verify.yml</code>]</p> <p>Triggers on each pull request and performs: - Linting - Architecture-specific builds - Example (end-to-end tests) execution (via <code>run_examples.sh</code>) - Artifact staging</p> </li> <li> <p>[<code>verify-build.yml</code>]</p> <p>A reusable workflow invoked by other repos to validate builds with standardized steps.</p> </li> </ul>"},{"location":"development/ci/#testing-strategy","title":"Testing Strategy","text":"<p>All repositories in the vAccel ecosystem include a <code>run_examples.sh</code> script, which is used to:</p> <ul> <li>Set up required runtime environments</li> <li>Run only the relevant examples per context</li> <li>Validate outputs and detect regressions</li> </ul> <p>These are invoked automatically by the workflows during CI runs, ensuring both core framework and plugin-specific coverage.</p>"},{"location":"development/ci/#artifact-publishing","title":"Artifact Publishing","text":"<p>On <code>main</code> branch merges and tagged releases:</p> <ul> <li>Binaries (<code>DEB</code>s, <code>TAR</code>s, <code>.so</code>, etc.) are compiled for supported   architectures</li> <li>Files are uploaded to a secure, versioned S3-compatible object storage</li> <li>Downstream components reference artifacts using semantic versions</li> </ul> <p>This approach enables:</p> <ul> <li>Binary-only integrations on resource-constrained platforms</li> <li>Secure and reproducible builds</li> </ul>"},{"location":"development/ci/#example-diagram","title":"Example diagram","text":"<pre><code>flowchart TD\n        PR[Pull Request]\n        Merge[Merge to main]\n    subgraph ARC[Arc Controller]\n        Runners --&gt; RunnerTag1[Runner Set]\n        Runners --&gt; RunnerTag2[Runner Set]\n        RunnerTag1 --&gt; x86\n        RunnerTag1 --&gt; arm64\n        RunnerTag1 --&gt; arm\n        RunnerTag2 --&gt; x86\n        RunnerTag2 --&gt; arm64\n        RunnerTag2 --&gt; arm\n    end\n    subgraph Build\n        BuildCode\n    end\n    subgraph Verify\n        VerifyCode --&gt; LintCode\n        VerifyCode --&gt; LintScripts\n        VerifyCode --&gt; LintDocs\n    end\n    subgraph Upload\n        UploadBin[Upload Binaries]\n    end\n    PR --&gt; ARC --&gt; Build --&gt; Verify --&gt; Upload\n    Merge --&gt; ARC --&gt; Build --&gt; Upload</code></pre>"},{"location":"development/contributing/","title":"Contributing","text":"<p>vAccel is an actively developed project, constantly evolving to handle more use cases. We appreciate any effort to improve the project and welcome contributions from the community.</p>"},{"location":"development/contributing/#how-to-contribute","title":"How to contribute","text":"<ol> <li>Use and Report: Try vAccel and share your experience. Were the    instructions clear? Did everything work as expected?</li> <li>Improve Documentation: Suggest changes or improvements to the    documentation to make it clearer.</li> <li>Request Features: Propose new features or enhancements.</li> <li>Report Bugs: Describe any issues you encounter.</li> <li>Code Changes: Improve existing code or add new functionality.</li> </ol>"},{"location":"development/contributing/#opening-an-issue","title":"Opening an issue","text":"<p>If you encounter any bugs or have suggestions for improvements, please open an issue.</p>"},{"location":"development/contributing/#reporting-bugs","title":"Reporting bugs","text":"<p>When reporting a bug provide as much detail as possible, including steps to reproduce the issue and any relevant information about your environment. Specifically, include:</p> <ul> <li>A clear description of the issue.</li> <li>The respective output logs using the maximum log level (<code>VACCEL_LOG_LEVEL=4</code>).</li> <li>Version details of vAccel and plugins (either the commit's hash or the   version).</li> <li>CPU architecture and build type.</li> <li>Steps to reproduce the issue.</li> <li>Mark the issue with the <code>bug</code> label.</li> <li>Keep an eye on the issue for possible questions from the maintainers.</li> </ul> <p>Example template for an issue:</p> <pre><code>## Description\nAn explanation of the issue\n\n## System info\n- vAccel version:\n- vAccel Plugin/Plugin's version:\n- Arch:\n- Build type:\n\n## Steps to reproduce\nA list of steps to reproduce the issue.\n</code></pre>"},{"location":"development/contributing/#requesting-new-features","title":"Requesting new features","text":"<p>To make a feature request, mark the issue with the <code>enhancement</code> label and provide a detailed description of the proposed feature.</p>"},{"location":"development/contributing/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<p>For significant changes, open an issue to discuss and receive feedback before proceeding with the implementation.</p>"},{"location":"development/contributing/#building-vaccel-and-testing-the-changes","title":"Building vAccel and testing the changes","text":"<p>You can find information on building vAccel in the Installation page and the meson_build document in the vAccel repository. After implementing the desired changes, the project should build and install correctly. Additionally, code tests and examples should be implemented (or modified) to include the new functionality. The process of formatting and running static analysis on the code is described in the Formatting code and running static analysis section.</p>"},{"location":"development/contributing/#preparing-for-a-pull-request","title":"Preparing for a Pull Request","text":"<p>Before creating a new Pull Request, ensure that:</p> <ul> <li>The build process is not broken.</li> <li>Your code includes appropriate tests and all tests pass.</li> <li>The style used follows the coding style of the project.</li> </ul> <p>To submit changes:</p> <ul> <li>Use one commit for each new feature or changed functionality</li> <li>Ensure that no commit in the Pull Request breaks the project's build process</li> <li>Make sure to sign-off your commits</li> <li>Provide meaningful commit messages, describing shortly the changes the commit   introduces</li> <li>Provide a meaningful Pull Request title and message</li> </ul>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request process","text":"<ol> <li>Automated checks: A maintainer checks the Pull Request and triggers the    automated checks.</li> <li>Review: If the checks pass, one or more maintainers review the Pull    Request.</li> <li>Address comments: The author of the Pull Request needs to address all the    reviewer comments.</li> <li>Approval: Upon approval, git trailers are added to the Pull Requests's    commits.</li> <li>Merge: The Pull Request is merged.</li> </ol>"},{"location":"development/contributing/#style-guide","title":"Style guide","text":""},{"location":"development/contributing/#git-commit-messages","title":"Git commit messages","text":"<p>Write clear and concise commit messages. Follow these guidelines for your commit messages:</p> <ul> <li>Limit the header (first line) to 72.</li> <li>Limit the body/footer to 80 characters</li> <li>Follow the Conventional Commits   specification and, specifically, format the header as   <code>&lt;type&gt;[optional scope]: &lt;description&gt;</code>, where <code>description</code> must not end with   a fullstop and <code>type</code> can be one of:<ul> <li>feat: A new feature</li> <li>fix: A bug fix</li> <li>docs: Documentation only changes</li> <li>style: Changes that do not affect the meaning of the code (white-space,   formatting, missing semi-colons, etc)</li> <li>refactor: A code change that neither fixes a bug nor adds a feature</li> <li>perf: A code change that improves performance</li> <li>test: Adding missing tests</li> <li>build: Changes that affect the build system or external dependencies   (example scopes: gulp, broccoli, npm)</li> <li>ci: Changes to our CI configuration files and scripts (example scopes:   Travis, Circle, BrowserStack, SauceLabs)</li> <li>chore: Other changes that don't modify src or test files</li> <li>revert: Reverts a previous commit</li> </ul> </li> <li>If the PR is associated with an issue, reference issues with   <code>Fixes: #issue_number</code></li> <li>Always sign-off your commit message</li> </ul> <p>The above rules are enforced by the PR checks, which will fail if requirements are not met.</p>"},{"location":"development/contributing/#cc-code-style","title":"C/C++ code style","text":"<p>vAccel code is formatted using <code>clang-format</code> with custom rules based on the Linux Kernel/K&amp;R style. Contributors can automatically apply formatting rules using the ninja target <code>clang-format</code> generated my meson. When Pull Request checks are run, an automated review with a patch containing any additional format changes required will be generated. For a Pull Request to be valid, format checks must not fail.</p>"},{"location":"development/contributing/#static-code-analysis","title":"Static code analysis","text":"<p>vAccel includes <code>clang-tidy</code> configs to validate it's codebase. Contributors can run checks using the ninja target <code>clang-tidy</code> generated my meson. Please address all errors and as much warnings as possible for the PR to be eligible for approval. Additionally, <code>cppcheck</code> checks triggered by the Pull Request actions must be successful.</p>"},{"location":"framework-bindings/tensorflow-bindings/","title":"Tensorflow bindings","text":"<p>To take advantage of vAccel's plugin system, we provide Tensorflow bindings for simple inference operations. With the use of bindings, native Tensorflow applications can leverage vAccel to run inference without modifications to the original code.</p> <p>vAccel Tensorflow bindings are part of the vAccel Tensorflow plugin distribution. You can find information on how to install the plugin at the relevant page.</p> <p>The next section assumes that you have installed vAccel and the Tensorflow plugin following the plugin's documentation.</p>"},{"location":"framework-bindings/tensorflow-bindings/#running-a-sample-tensorflow-application-with-vaccel","title":"Running a sample Tensorflow application with vAccel","text":"<p>Download a sample Tensorflow application:</p> <pre><code>git clone https://github.com/AmirulOm/tensorflow_capi_sample\ncd tensorflow_capi_sample\n</code></pre> <p>and build it with:</p> <pre><code>gcc -I/usr/local/include -L/usr/local/lib main.c -ltensorflow -o tf_sample\n</code></pre> <p>Link the LSTM model provided with vAccel to the current dir, so the application can find it:</p> <pre><code>ln -s /usr/local/share/vaccel/models/tf/lstm2 .\n</code></pre> <p>The application should run successfully with:</p> <pre><code>$ ./tf_sample\n2025-03-25 22:13:43.955282: I tensorflow/cc/saved_model/reader.cc:52] Reading meta graph with tags { serve }\n2025-03-25 22:13:43.955340: I tensorflow/cc/saved_model/reader.cc:147] Reading SavedModel debug info (if present) from: lstm2/\n2025-03-25 22:13:43.955394: I tensorflow/core/platform/cpu_feature_guard.cc:210] This TensorFlow binary is optimized to use available CPU instructions in performance-critical operations.\nTo enable the following instructions: SSE3 SSE4.1 SSE4.2 AVX AVX2 FMA, in other operations, rebuild TensorFlow with the appropriate compiler flags.\n2025-03-25 22:13:44.161071: I tensorflow/compiler/mlir/mlir_graph_optimization_pass.cc:388] MLIR V1 optimization pass is not enabled\n2025-03-25 22:13:44.203364: I tensorflow/cc/saved_model/loader.cc:236] Restoring SavedModel bundle.\n2025-03-25 22:13:44.365220: I tensorflow/cc/saved_model/loader.cc:220] Running initialization op on SavedModel bundle at path: lstm2/\n2025-03-25 22:13:44.499266: I tensorflow/cc/saved_model/loader.cc:462] SavedModel load for tags { serve }; Status: success: OK. Took 593575 microseconds.\nTF_LoadSessionFromSavedModel OK\nTF_GraphOperationByName serving_default_input_1 is OK\nTF_GraphOperationByName StatefulPartitionedCall is OK\nTF_NewTensor is OK\nSession is OK\nResult Tensor :\n0.016328\n0.016542\n0.015824\n0.016457\n0.016535\n0.016574\n0.016449\n0.016437\n0.016353\n0.016246\n</code></pre> <p>After successfully executing the native application, you are ready to use it with vAccel.</p> <p>To execute the same binary with vAccel you need to first setup the plugin as described in the relevant guide:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-tf.so\nexport VACCEL_LOG_LEVEL=4\n</code></pre> <p>You can then use the bindings with <code>LD_PRELOAD</code>:</p> <pre><code>$ LD_PRELOAD=/usr/local/lib/x86_64-linux-gnu/libvaccel-tf-bindings.so ./tf_sample\n2025.03.25-22:27:30.34 - &lt;debug&gt; Initializing vAccel\n2025.03.25-22:27:30.34 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.03.25-22:27:30.34 - &lt;debug&gt; Config:\n2025.03.25-22:27:30.34 - &lt;debug&gt;   plugins = libvaccel-tf.so\n2025.03.25-22:27:30.34 - &lt;debug&gt;   log_level = debug\n2025.03.25-22:27:30.34 - &lt;debug&gt;   log_file = (null)\n2025.03.25-22:27:30.34 - &lt;debug&gt;   profiling_enabled = false\n2025.03.25-22:27:30.34 - &lt;debug&gt;   version_ignore = false\n2025.03.25-22:27:30.34 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/8IBBqO\n2025.03.25-22:27:30.44 - &lt;info&gt; Registered plugin tf 0.1.0-21-3cb5453e\n2025.03.25-22:27:30.44 - &lt;debug&gt; Registered op tf_session_load from plugin tf\n2025.03.25-22:27:30.44 - &lt;debug&gt; Registered op tf_session_run from plugin tf\n2025.03.25-22:27:30.44 - &lt;debug&gt; Registered op tf_session_delete from plugin tf\n2025.03.25-22:27:30.44 - &lt;debug&gt; Registered op tflite_session_load from plugin tf\n2025.03.25-22:27:30.44 - &lt;debug&gt; Registered op tflite_session_run from plugin tf\n2025.03.25-22:27:30.44 - &lt;debug&gt; Registered op tflite_session_delete from plugin tf\n2025.03.25-22:27:30.44 - &lt;debug&gt; Loaded plugin tf from libvaccel-tf.so\n2025.03.25-22:27:30.45 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/8IBBqO/session.1\n2025.03.25-22:27:30.45 - &lt;debug&gt; Initialized session 1\n2025.03.25-22:27:30.45 - &lt;warn&gt; Path does not seem to have a `&lt;prefix&gt;://`\n2025.03.25-22:27:30.45 - &lt;warn&gt; Assuming lstm2/ is a local path\n2025.03.25-22:27:30.45 - &lt;debug&gt; Initialized resource 1\n2025.03.25-22:27:30.45 - &lt;debug&gt; session:1 Registered resource 1\n2025.03.25-22:27:30.45 - &lt;debug&gt; session:1 Looking for plugin implementing tf_session_load operation\n2025.03.25-22:27:30.45 - &lt;debug&gt; Returning func from hint plugin tf\n2025.03.25-22:27:30.45 - &lt;debug&gt; Found implementation in tf plugin\n2025.03.25-22:27:30.45 - &lt;debug&gt; [tf] Loading session from SavedModel\n2025-03-25 22:27:30.459234: I tensorflow/cc/saved_model/reader.cc:83] Reading SavedModel from: lstm2/\n2025-03-25 22:27:30.502324: I tensorflow/cc/saved_model/reader.cc:52] Reading meta graph with tags { serve }\n2025-03-25 22:27:30.502381: I tensorflow/cc/saved_model/reader.cc:147] Reading SavedModel debug info (if present) from: lstm2/\n2025-03-25 22:27:30.502437: I tensorflow/core/platform/cpu_feature_guard.cc:210] This TensorFlow binary is optimized to use available CPU instructions in performance-critical operations.\nTo enable the following instructions: SSE3 SSE4.1 SSE4.2 AVX AVX2 FMA, in other operations, rebuild TensorFlow with the appropriate compiler flags.\n2025-03-25 22:27:30.694945: I tensorflow/compiler/mlir/mlir_graph_optimization_pass.cc:388] MLIR V1 optimization pass is not enabled\n2025-03-25 22:27:30.751997: I tensorflow/cc/saved_model/loader.cc:236] Restoring SavedModel bundle.\n2025-03-25 22:27:30.924794: I tensorflow/cc/saved_model/loader.cc:220] Running initialization op on SavedModel bundle at path: lstm2/\n2025-03-25 22:27:31.080011: I tensorflow/cc/saved_model/loader.cc:462] SavedModel load for tags { serve }; Status: success: OK. Took 620801 microseconds.\n2025.03.25-22:27:31.11 - &lt;debug&gt; Model from path loaded correctly\n2025-03-25 22:27:31.188347: I tensorflow/cc/saved_model/reader.cc:83] Reading SavedModel from: lstm2/\n2025-03-25 22:27:31.236284: I tensorflow/cc/saved_model/reader.cc:52] Reading meta graph with tags { serve }\n2025-03-25 22:27:31.236342: I tensorflow/cc/saved_model/reader.cc:147] Reading SavedModel debug info (if present) from: lstm2/\n2025-03-25 22:27:31.466623: I tensorflow/cc/saved_model/loader.cc:236] Restoring SavedModel bundle.\n2025-03-25 22:27:31.621523: I tensorflow/cc/saved_model/loader.cc:220] Running initialization op on SavedModel bundle at path: lstm2/\n2025-03-25 22:27:31.777220: I tensorflow/cc/saved_model/loader.cc:462] SavedModel load for tags { serve }; Status: success: OK. Took 588881 microseconds.\nTF_LoadSessionFromSavedModel OK\nTF_GraphOperationByName serving_default_input_1 is OK\nTF_GraphOperationByName StatefulPartitionedCall is OK\nTF_NewTensor is OK\n2025.03.25-22:27:31.81 - &lt;debug&gt; session:1 Looking for plugin implementing tf_session_run operation\n2025.03.25-22:27:31.81 - &lt;debug&gt; Returning func from hint plugin tf\n2025.03.25-22:27:31.81 - &lt;debug&gt; Found implementation in tf plugin\n2025.03.25-22:27:31.81 - &lt;debug&gt; [tf] Running session\n2025.03.25-22:27:32.49 - &lt;debug&gt; [tf] Success\nSession is OK\n2025.03.25-22:27:32.49 - &lt;debug&gt; session:1 Looking for plugin implementing tf_session_delete operation\n2025.03.25-22:27:32.49 - &lt;debug&gt; Returning func from hint plugin tf\n2025.03.25-22:27:32.49 - &lt;debug&gt; Found implementation in tf plugin\n2025.03.25-22:27:32.49 - &lt;debug&gt; [tf] Deleting session\n2025.03.25-22:27:32.59 - &lt;debug&gt; session:1 Unregistered resource 1\n2025.03.25-22:27:32.59 - &lt;debug&gt; Released resource 1\n2025.03.25-22:27:32.69 - &lt;debug&gt; Released session 1\nResult Tensor :\n0.016328\n0.016542\n0.015824\n0.016457\n0.016535\n0.016574\n0.016449\n0.016437\n0.016353\n0.016246\n2025.03.25-22:27:32.69 - &lt;debug&gt; Cleaning up vAccel\n2025.03.25-22:27:32.69 - &lt;debug&gt; Cleaning up sessions\n2025.03.25-22:27:32.69 - &lt;debug&gt; Cleaning up resources\n2025.03.25-22:27:32.69 - &lt;debug&gt; Cleaning up plugins\n2025.03.25-22:27:32.69 - &lt;debug&gt; Unregistered plugin tf\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Learn how to setup vAccel and run you first vAccel application by using the provided examples:</p> <ul> <li>Architecture</li> <li>Installation</li> <li>Running the examples</li> <li>Introduction to plugins</li> </ul>"},{"location":"getting-started/architecture/","title":"Architecture","text":"<p>The vAccel framework is designed to enable transparent and secure offloading of hardware-accelerated operations from sandboxed workloads (eg., VMs, containers) to the host. Its architecture is centered on a unified, plugin-based model that abstracts execution, allowing for portability, flexibility, and minimal runtime overhead.</p>"},{"location":"getting-started/architecture/#system-overview","title":"System overview","text":"<p>At a high level, vAccel consists of:</p> <ol> <li> <p>The core library that:</p> <ul> <li>Exposes the API and is linked into user-space applications</li> <li>Matches API operations to the underlying plugins</li> </ul> </li> <li> <p>The plugins that handle the execution of operations:</p> <ul> <li>A set of transport plugins, which facilitate communication between hosts</li> <li>A set of backend plugins, which execute acceleration operations</li> </ul> </li> </ol> <p>All components interact through a well-defined API that ensures consistency and extensibility.</p> <p> </p> <p>vAccel software stack  </p>"},{"location":"getting-started/architecture/#core-library","title":"Core library","text":"<p>The vAccel runtime library is responsible for exposing the vAccel API to user applications, handling serialization/deserialization of operation requests, coordinating plugins through a modular and extensible logic. The library is written in C and is available as a shared library. It provides the base for language bindings in Python and Go.</p>"},{"location":"getting-started/architecture/#api-layer","title":"API layer","text":"<p>The API is semantically expressive and targets coarse-grained operations like:</p> <ul> <li> <p>ML model inference</p> </li> <li> <p>Image inference operations (eg. classification, segmentation etc.)</p> </li> <li> <p>Library-specific operations (eg. OpenCV)</p> </li> <li> <p>Vector operations (BLAS-related, like SGEMM etc.)</p> </li> </ul> <p>Internally, each operation is mapped to a plugin capability, abstracting hardware or transport-specific behavior.</p> <p>Info</p> <p>For more information on the API and the available operations see the API section.</p>"},{"location":"getting-started/architecture/#plugin-subsystem","title":"Plugin subsystem","text":"<p>The vAccel plugin model provides modularity and isolation. All offload logic is encapsulated in dynamically loadable shared objects that adhere to the vAccel Plugin ABI.</p>"},{"location":"getting-started/architecture/#plugin-types","title":"Plugin types","text":""},{"location":"getting-started/architecture/#acceleration-plugins","title":"Acceleration plugins","text":"<p>Acceleration plugins perform the actual execution of acceleration functions using host-side libraries, hardware drivers, or frameworks (eg., CUDA, OpenCL, neural accelerators, etc.).</p> <p>They must:</p> <ul> <li> <p>Implement the function(s) described in the vAccel API</p> </li> <li> <p>Register capabilities during initialization</p> </li> <li> <p>Handle requests from the core library (via the dispatch layer)</p> </li> </ul> <p>Each plugin is isolated from others and loaded only when required, minimizing resource footprint and improving security.</p>"},{"location":"getting-started/architecture/#transport-plugins","title":"Transport plugins","text":"<p>Transport plugins implement the guest \u2194 host communication layer. They handle request framing, sending, and receiving, enabling the core runtime to be decoupled from specific transport mechanisms.</p> <p>Examples include:</p> <ul> <li> <p><code>virtio</code>: Paravirtualized transport using memory-mapped buffers (via patched   QEMU or Firecracker)</p> </li> <li> <p><code>rpc</code>: Generic socket-based plugin with support for <code>VSOCK</code>, <code>TCP</code>, and <code>UNIX</code>   sockets</p> </li> </ul> <p>These are configured at runtime, allowing per-deployment customization.</p> <p>Info</p> <p>You can learn more about the available plugins and their usage in the Plugins section.</p>"},{"location":"getting-started/architecture/#execution-model","title":"Execution model","text":"<p>The execution of an acceleration operation typically follows this path:</p> <ol> <li> <p>The user application invokes a vAccel API call.</p> </li> <li> <p>The core library encodes the request into an internal format.</p> </li> <li> <p>The transport plugin transmits the encoded message to the host.</p> </li> <li> <p>On the host, the backend plugin receives and decodes the request.</p> </li> <li> <p>The operation is executed using the corresponding hardware or framework.</p> </li> <li> <p>The result is serialized and returned via the transport plugin.</p> </li> </ol> <p>This separation ensures that the application is agnostic to where and how execution happens, that plugins can evolve independently, and that hardware heterogeneity is abstracted away.</p> <p> </p> <p>vAccel execution flow  </p>"},{"location":"getting-started/architecture/#multi-architecture-support","title":"Multi-Architecture Support","text":"<p>vAccel is fully portable and supports:</p> <ul> <li> <p><code>amd64</code>: Main development and reference architecture</p> </li> <li> <p><code>arm64</code>: Optimized for edge and embedded devices (eg., NVIDIA Jetsons,   Raspberry Pi variants etc.)</p> </li> <li> <p><code>arm</code>: Deeply embedded environments (eg. Switch ASICs, FPGAs etc.)</p> </li> </ul> <p>Cross-compilation is supported via Meson and platform-specific build toolchains. CI workflows validate plugin compatibility and API coverage across architectures.</p>"},{"location":"getting-started/architecture/#continuous-integration-ci-and-testing","title":"Continuous integration (CI) and testing","text":"<p>A key enabler of robustness and portability is vAccel's integrated CI infrastructure:</p> <ul> <li> <p>Builds and tests all components (core, plugins) on <code>amd64</code>, <code>arm64</code>, and   <code>arm</code>.</p> </li> <li> <p>Runs automated functional and integration tests for all supported transports</p> </li> <li> <p>Validates plugin ABI compatibility across versions</p> </li> <li> <p>Ensures conformance of Python and Go bindings with the C runtime</p> </li> </ul> <p>Info</p> <p>The CI infrastructure is described in more detail in the CI page.</p>"},{"location":"getting-started/architecture/#extending-vaccel","title":"Extending vAccel","text":"<p>vAccel's architecture encourages third-party contributions for:</p> <ul> <li> <p>Plugin Development: Polish / Enhance / Extend existing   plugins or provide   additional   plugins for   existing API operations</p> </li> <li> <p>Transport Protocol Enhancements</p> </li> </ul> <p>vAccel\u2019s modularity allows integration with novel transports, custom accelerators, or domain-specific runtimes (e.g., FPGA toolchains, DSPs, AI frameworks).</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>vAccel provides prebuilt binaries for Ubuntu-based systems. If you want to use it with other distributions or build it manually you can follow Building from source.</p>"},{"location":"getting-started/installation/#binaries","title":"Binaries","text":"<p>You can get the latest vAccel binary release from the Releases page of the vAccel repository. Releases include DEB packages and binaries for x86_64/aarch64/armv7l Ubuntu-based systems.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>The prebuilt vAccel binaries depend on libcurl. You can install it with:</p> <pre><code>sudo apt install libcurl4\n</code></pre>"},{"location":"getting-started/installation/#deb","title":"DEB","text":"<p>To install the DEB package of the latest vAccel release:</p> x86ARM (64-bit)ARM (32-bit) <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel_0.7.1-1_amd64.deb\nsudo dpkg -i vaccel_0.7.1-1_amd64.deb\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel_0.7.1-1_arm64.deb\nsudo dpkg -i vaccel_0.7.1-1_arm64.deb\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel_0.7.1-1_armhf.deb\nsudo dpkg -i vaccel_0.7.1-1_armhf.deb\n</code></pre>"},{"location":"getting-started/installation/#tar","title":"TAR","text":"<p>To install the TAR binary package of the latest vAccel release:</p> x86ARM (64-bit)ARM (32-bit) <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel_0.7.1_amd64.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel_0.7.1_amd64.tar.gz --strip-components=2 -C /usr/local\n# Update pkg-config files with the correct prefix\nfind /usr/local -name \"vaccel*.pc\" -exec sed -i 's:^\\(prefix=\\).*:\\1/usr/local:g' {} \\;\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel_0.7.1_arm64.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel_0.7.1_arm64.tar.gz --strip-components=2 -C /usr/local\n# Update pkg-config files with the correct prefix\nfind /usr/local -name \"vaccel*.pc\" -exec sed -i 's:^\\(prefix=\\).*:\\1/usr/local:g' {} \\;\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel_0.7.1_armhf.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel_0.7.1_armhf.tar.gz --strip-components=2 -C /usr/local\n# Update pkg-config files with the correct prefix\nfind /usr/local -name \"vaccel*.pc\" -exec sed -i 's:^\\(prefix=\\).*:\\1/usr/local:g' {} \\;\n</code></pre>"},{"location":"getting-started/installation/#latest-artifacts","title":"Latest artifacts","text":"<p>You can also find prebuilt artifacts of the latest vAccel revision at:</p> x86ARM (64-bit)ARM (32-bit) <pre><code># DEB\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/rev/main/x86_64/debug/vaccel_latest_amd64.deb\n# TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/rev/main/x86_64/debug/vaccel-latest-bin.tar.gz\n</code></pre> <pre><code># DEB\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/rev/main/aarch64/debug/vaccel_latest_arm64.deb\n# TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/rev/main/aarch64/debug/vaccel-latest-bin.tar.gz\n</code></pre> <pre><code># DEB\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/rev/main/armv7l/debug/vaccel_latest_armhf.deb\n# TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/rev/main/armv7l/debug/vaccel-latest-bin.tar.gz\n</code></pre>"},{"location":"getting-started/installation/#building-from-source","title":"Building from source","text":""},{"location":"getting-started/installation/#requirements_1","title":"Requirements","text":"<p>vAccel uses the Meson build system and this is the main required dependency to build it. In Debian-based systems, you can install the required build tools with:</p> <pre><code>sudo apt install build-essential ninja-build pkg-config python3-pip\npip install meson\n</code></pre> <p>Optionally, to support file downloading you need the libcurl development files:</p> <pre><code>sudo apt install libcurl4-openssl-dev\n</code></pre> <p>To get working image inference examples you also need the stb header library:</p> <pre><code>sudo apt install libstb-dev\n</code></pre>"},{"location":"getting-started/installation/#building-the-source-code","title":"Building the source code","text":"<p>Get the source code:</p> <pre><code>git clone https://github.com/nubificus/vaccel\ncd vaccel\n</code></pre> <p>Build and install all vAccel components in the repository with:</p> <pre><code># Configure the build directory.\n# Enable all features and set build type to 'release'.\nmeson setup --buildtype=release -Dauto_features=enabled build\n\n# Compile the project\nmeson compile -C build\n\n# Install the project to the default directory (/usr/local)\nmeson install -C build\n</code></pre> <p>And you are set to go.</p> <p>If you want to select which components to build instead, you can continue reading below.</p>"},{"location":"getting-started/installation/#building-the-core-library","title":"Building the core library","text":"<p>The core library is the only component built by default. To only build the core library replace:</p> <pre><code>meson setup --buildtype=release -Dauto_features=enabled build\n</code></pre> <p>above, with:</p> <pre><code>meson setup --buildtype=release build\n</code></pre>"},{"location":"getting-started/installation/#building-the-plugins","title":"Building the plugins","text":"<p>Building of the included plugins is disabled, by default. You can enable building one or more plugins at configuration time by setting the corresponding options.</p> <p>To build the core library and all of the included plugins, replace:</p> <pre><code>meson setup --buildtype=release -Dauto_features=enabled build\n</code></pre> <p>above, with:</p> <pre><code>meson setup --buildtype=release -Dplugins=enabled build\n</code></pre> <p>You can also select which plugins to use. For example:</p> <pre><code>meson setup --buildtype=release -Dplugin-noop=enabled build\n</code></pre> <p>will select the core library and the noop backend plugin.</p>"},{"location":"getting-started/installation/#building-the-examples","title":"Building the examples","text":"<p>As with the plugins, building the examples is disabled by default. To build the core library and all of the examples, replace:</p> <pre><code>meson setup --buildtype=release -Dauto_features=enabled build\n</code></pre> <p>above, with:</p> <pre><code>meson setup --buildtype=release -Dexamples=enabled build\n</code></pre> <p>To view all the available options/values you can use:</p> <pre><code>meson setup --buildtype=release build\nmeson configure build\n</code></pre> <p>vAccel specific options can be found in the <code>Project Options</code> section.</p>"},{"location":"getting-started/introduction-to-plugins/","title":"Introduction to plugins","text":"<p>Plugins contain the implementations of vAccel operations. While the vAccel library itself is the only requirement to compile a vAccel application, you need to use a plugin for the application to actually do something useful.</p> <p>The use of plugins can become clearer by revisiting the image classification example from Running the examples.</p> <p>As we have already shown, to specify a backend plugin you have to set the <code>VACCEL_PLUGINS</code> environment variable.</p> <p>Ensure <code>VACCEL_PLUGINS</code> is not set in the environment while keeping debug logging enabled:</p> <pre><code>unset VACCEL_PLUGINS\nexport VACCEL_LOG_LEVEL=4\n</code></pre> <p>If you run the example, there will be no errors concerning the binaries themselves (ie. undefined symbols) but the operation will fail at runtime:</p> <pre><code>$ classify /usr/local/share/vaccel/images/example.jpg 1\n2025.04.05-19:25:04.80 - &lt;debug&gt; Initializing vAccel\n2025.04.05-19:25:04.80 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.05-19:25:04.80 - &lt;debug&gt; Config:\n2025.04.05-19:25:04.80 - &lt;debug&gt;   plugins = (null)\n2025.04.05-19:25:04.80 - &lt;debug&gt;   log_level = debug\n2025.04.05-19:25:04.80 - &lt;debug&gt;   log_file = (null)\n2025.04.05-19:25:04.80 - &lt;debug&gt;   profiling_enabled = false\n2025.04.05-19:25:04.80 - &lt;debug&gt;   version_ignore = false\n2025.04.05-19:25:04.80 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/k0R150\n2025.04.05-19:25:04.80 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/k0R150/session.1\n2025.04.05-19:25:04.80 - &lt;debug&gt; Initialized session 1\nInitialized session with id: 1\n2025.04.05-19:25:04.80 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.05-19:25:04.80 - &lt;warn&gt; None of the loaded plugins implement VACCEL_OP_IMAGE_CLASSIFY\nCould not run op: 95\n2025.04.05-19:25:04.80 - &lt;debug&gt; Released session 1\n2025.04.05-19:25:04.80 - &lt;debug&gt; Cleaning up vAccel\n2025.04.05-19:25:04.80 - &lt;debug&gt; Cleaning up sessions\n2025.04.05-19:25:04.80 - &lt;debug&gt; Cleaning up resources\n2025.04.05-19:25:04.80 - &lt;debug&gt; Cleaning up plugins\n</code></pre> <p>It is clear from the output that no implementation is found for the <code>VACCEL_OP_IMAGE_CLASSIFY</code> operation. By comparing the output with classify from the previous document, you can see that the reason is that no plugin has been loaded.</p> <p>You can find out more about the available plugins and their usage in the Plugins section.</p>"},{"location":"getting-started/introduction-to-plugins/#using-a-plugin-from-a-non-standard-library-path","title":"Using a plugin from a non-standard library path","text":"<p>It is recommended that vAccel and the vAccel plugins are installed in the standard library search paths for ease of use (ie. <code>/usr/lib</code>, <code>/usr/local/lib</code> etc.). If this is not possible or desirable there are two ways to use the plugins:</p> <ul> <li>Assuming vAccel is installed in a standard path, use the full path to specify   the plugin. For example, if the <code>NoOp</code> plugin is installed in <code>/opt/noop/lib</code>:     <pre><code>export VACCEL_PLUGINS=/opt/noop/lib/libvaccel-noop.so\n</code></pre></li> </ul> <p>or,</p> <ul> <li>Add the vAccel/plugin library paths to the library search paths and specify   the plugin as usual. For example, if vAccel and the <code>NoOp</code> plugin are   installed in <code>/opt/vaccel/lib</code>:     <pre><code>export LD_LIBRARY_PATH=/opt/vaccel/lib:$LD_LIBRARY_PATH\nexport VACCEL_PLUGINS=libvaccel-noop.so\n</code></pre></li> </ul>"},{"location":"getting-started/running-the-examples/","title":"Running the examples","text":"<p>vAccel comes with a set of examples for common acceleration operations like image classification, matrix multiplication etc. Besides providing common acceleration functionality, the examples are meant as a demonstration of how to use the different operations of the vAccel API.</p> <p>The bare minimum you have to configure in order to run the examples - or any vAccel application - is the backend plugin that will be used. You can do this by setting the <code>VACCEL_PLUGINS</code> environment variable:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-noop.so\n</code></pre> <p>This will select the <code>NoOp</code> dummy plugin as a backend.</p> <p>You are now ready to run any example.</p> <p>For example, assuming vAccel is installed in <code>/usr/local</code>, you can run an image classification operation with:</p> <pre><code>$ classify /usr/local/share/vaccel/images/example.jpg 1\nInitialized session with id: 1\nclassification tags: This is a dummy classification tag!\nclassification imagename: This is a dummy imgname!\n</code></pre> <p>By enabling debug level logging, you can get more details on what is happening in the background:</p> <pre><code>export VACCEL_LOG_LEVEL=4\n</code></pre> <p>The output will now be:</p> <p></p> <pre><code>$ classify /usr/local/share/vaccel/images/example.jpg 1\n2025.04.03-15:44:04.61 - &lt;debug&gt; Initializing vAccel\n2025.04.03-15:44:04.61 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.03-15:44:04.61 - &lt;debug&gt; Config:\n2025.04.03-15:44:04.61 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.03-15:44:04.61 - &lt;debug&gt;   log_level = debug\n2025.04.03-15:44:04.61 - &lt;debug&gt;   log_file = (null)\n2025.04.03-15:44:04.61 - &lt;debug&gt;   profiling_enabled = false\n2025.04.03-15:44:04.61 - &lt;debug&gt;   version_ignore = false\n2025.04.03-15:44:04.61 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/VC0Gxz\n2025.04.03-15:44:04.61 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op noop from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op blas_sgemm from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op image_classify from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op image_detect from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op image_segment from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op image_pose from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op image_depth from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op exec from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op tf_session_load from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op tf_session_run from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op tf_session_delete from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op minmax from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op fpga_arraycopy from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op fpga_vectoradd from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op fpga_parallel from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op fpga_mmult from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op exec_with_resource from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op torch_jitload_forward from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op torch_sgemm from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op opencv from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op tflite_session_load from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op tflite_session_run from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op tflite_session_delete from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n2025.04.03-15:44:04.62 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/VC0Gxz/session.1\n2025.04.03-15:44:04.62 - &lt;debug&gt; Initialized session 1\nInitialized session with id: 1\n2025.04.03-15:44:04.62 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.03-15:44:04.62 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.03-15:44:04.62 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] model: (null)\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] len_out_text: 512\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] len_out_imgname: 512\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] will return a dummy result\nclassification tags: This is a dummy classification tag!\nclassification imagename: This is a dummy imgname!\n2025.04.03-15:44:04.62 - &lt;debug&gt; Released session 1\n2025.04.03-15:44:04.62 - &lt;debug&gt; Cleaning up vAccel\n2025.04.03-15:44:04.62 - &lt;debug&gt; Cleaning up sessions\n2025.04.03-15:44:04.62 - &lt;debug&gt; Cleaning up resources\n2025.04.03-15:44:04.62 - &lt;debug&gt; Cleaning up plugins\n2025.04.03-15:44:04.62 - &lt;debug&gt; Unregistered plugin noop\n</code></pre> <p>You can find sample invocation commands for all the examples in the run-examples script. You can also clone the repo and run the script yourself with:</p> <pre><code>git clone https://github.com/nubificus/vaccel\ncd vaccel\n# Replace '/usr/local' with the vAccel installation prefix\n./scripts/run-examples.sh /usr/local\n</code></pre> <p>If you have already built vAccel from source, simply run:</p> <pre><code># Replace 'build' with your build directory\nninja run-examples -C build\n</code></pre> <p>in your <code>vaccel</code> directory.</p> <p>Info</p> <p>You can find more information on the environment variables you can use to configure vAccel in the Configuration page.</p>"},{"location":"language-bindings/","title":"Language bindings","text":"<p>You can use vAccel from more than C.</p> <p>The vAccel core library itself is written in C, but you can use the vAccel API from other popular programming languages through the provided bindings:</p> <ul> <li>Python bindings</li> <li>Go bindings</li> <li>Rust bindings</li> </ul>"},{"location":"language-bindings/go-bindings/","title":"Go bindings","text":"<p>Go bindings for vAccel wrap the vAccel C API and provide a native Go API to vAccel operations.</p> <ul> <li>Usage</li> <li>Writing a simple vAccel Go application</li> <li>API reference</li> </ul>"},{"location":"language-bindings/go-bindings/usage/","title":"Usage","text":"<p>The Go bindings are implemented in the <code>vaccel</code> Go package and are currently a WiP, supporting a subset of the vAccel operations.</p>"},{"location":"language-bindings/go-bindings/usage/#requirements","title":"Requirements","text":"<ul> <li>To use the <code>vaccel</code> Go package you need a valid vAccel installation. You can   find more information on how to install vAccel in the   Installation page.</li> </ul> <ul> <li>This package requires Go 1.20 or newer. Verify your Go version with:     <pre><code>go version\n</code></pre>     and update Go as needed using the     official instructions.</li> </ul>"},{"location":"language-bindings/go-bindings/usage/#using-the-vaccel-package","title":"Using the <code>vaccel</code> package","text":"<p>You can use the package in your Go code like any other Go package with:</p> <pre><code>import \"github.com/nubificus/vaccel-go/vaccel\"\n</code></pre>"},{"location":"language-bindings/go-bindings/usage/#running-the-examples","title":"Running the examples","text":"<p>You can find examples in the examples directory of the repository. The provided examples are similar to the C examples and you must configure vAccel in order to use them.</p> <p>To run an image classification, like the C <code>classify</code>, set:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-noop.so\n</code></pre> <p>and, assuming vAccel is installed at <code>/usr/local</code>, run with:</p> <pre><code>$ go run github.com/nubificus/vaccel-go/examples/classify \\\n      /usr/local/share/vaccel/images/example.jpg\nOutput(1):  This is a dummy classification tag!\nOutput(2):  This is a dummy classification tag!\n</code></pre> <p>By setting log level to debug:</p> <pre><code>export VACCEL_LOG_LEVEL=4\n</code></pre> <p>you can see the verbose vAccel output, very similar to the C <code>classify</code> output:</p> <pre><code>$ go run github.com/nubificus/vaccel-go/examples/classify \\\n      /usr/local/share/vaccel/images/example.jpg\n2025.04.15-16:51:03.74 - &lt;debug&gt; Initializing vAccel\n2025.04.15-16:51:03.74 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.15-16:51:03.74 - &lt;debug&gt; Config:\n2025.04.15-16:51:03.74 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.15-16:51:03.74 - &lt;debug&gt;   log_level = debug\n2025.04.15-16:51:03.74 - &lt;debug&gt;   log_file = (null)\n2025.04.15-16:51:03.74 - &lt;debug&gt;   profiling_enabled = false\n2025.04.15-16:51:03.74 - &lt;debug&gt;   version_ignore = false\n2025.04.15-16:51:03.74 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/37513G\n2025.04.15-16:51:03.75 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op noop from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op blas_sgemm from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op image_classify from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op image_detect from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op image_segment from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op image_pose from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op image_depth from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op exec from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op tf_session_load from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op tf_session_run from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op tf_session_delete from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op minmax from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op fpga_arraycopy from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op fpga_vectoradd from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op fpga_parallel from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op fpga_mmult from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op exec_with_resource from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op torch_jitload_forward from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op torch_sgemm from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op opencv from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op tflite_session_load from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op tflite_session_run from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Registered op tflite_session_delete from plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n2025.04.15-16:51:03.75 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/37513G/session.1\n2025.04.15-16:51:03.75 - &lt;debug&gt; Initialized session 1\n2025.04.15-16:51:03.75 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.15-16:51:03.75 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] model: (null)\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] len_out_text: 256\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] len_out_imgname: 256\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] will return a dummy result\nOutput(1):  This is a dummy classification tag!\n2025.04.15-16:51:03.75 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.15-16:51:03.75 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.15-16:51:03.75 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] model: (null)\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] len_out_text: 256\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] len_out_imgname: 256\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.15-16:51:03.75 - &lt;debug&gt; [noop] will return a dummy result\nOutput(2):  This is a dummy classification tag!\n2025.04.15-16:51:03.75 - &lt;debug&gt; Released session 1\n</code></pre>"},{"location":"language-bindings/go-bindings/usage/#installing-the-examples","title":"Installing the examples","text":"<p>If you want to install an example for local use, you can use <code>go install</code>. For example:</p> <pre><code>go install github.com/nubificus/vaccel-go/examples/classify\n</code></pre> <p>will install the <code>classify</code> example in your local Go binary path.</p>"},{"location":"language-bindings/go-bindings/usage/#building-the-examples-from-source","title":"Building the examples from source","text":"<p>You can also clone the repository locally to build the examples:</p> <pre><code>git clone https://github.com/nubificus/vaccel-go.git\ncd vaccel-go\nmake\n</code></pre> <p>If all went well, the examples' binaries should be available in <code>./bin</code>.</p>"},{"location":"language-bindings/go-bindings/writing-a-simple-vaccel-go-application/","title":"Writing a simple vAccel Go application","text":"<p>For a simple example of using the <code>vaccel</code> Go package, you can replicate in Go an image classification application similar to the image classification example from Running the examples.</p> <p>Initialize a new <code>vaccel-go-classify</code> project and module:</p> <pre><code>mkdir vaccel-go-classify\ncd vaccel-go-classify\ngo mod init vaccel-go-classify\n</code></pre> <p>Create a new Go file <code>main.go</code> with the following content:</p> main.go<pre><code>package main\n\nimport (\n        \"fmt\"\n        \"os\"\n\n        \"github.com/nubificus/vaccel-go/vaccel\"\n)\n\nfunc main() {\n\n        if len(os.Args) &lt; 2 {\n                fmt.Println(\"Usage: ./main &lt;filename&gt;\")\n                return\n        }\n\n        /* Get the filename from command line argument */\n        filePath := os.Args[1]\n\n        /* Session */\n        var session vaccel.Session\n\n        err := vaccel.SessionInit(&amp;session, 0)\n\n        if err != 0 {\n                fmt.Println(\"error initializing session\")\n                os.Exit(err)\n        }\n\n        var outText string\n\n        /* Read the image-bytes */\n        imageBytes, e := os.ReadFile(filePath)\n        if e != nil {\n                fmt.Printf(\"Error reading file: %s\\n\", e)\n                os.Exit(1)\n        }\n\n        /* Perform Image Classification */\n        outText, err = vaccel.ImageClassification(&amp;session, imageBytes)\n\n        if err != 0 {\n                fmt.Println(\"Image Classification failed\")\n                os.Exit(err)\n        }\n\n        fmt.Println(\"Output: \", outText)\n\n        /* Free Session */\n        if vaccel.SessionRelease(&amp;session) != 0 {\n                fmt.Println(\"An error occurred while releasing the session\")\n        }\n}\n</code></pre> <p>Add all Go dependencies for your package:</p> <pre><code>go get .\n</code></pre> <p>And you are ready to run your application.</p> <p>Same as with the upstream Go <code>classify</code>, configure vAccel:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-noop.so\n</code></pre> <p>and run with:</p> <pre><code>$ go run main.go /usr/local/share/vaccel/images/example.jpg\nOutput:  This is a dummy classification tag!\n</code></pre>"},{"location":"language-bindings/python-bindings/","title":"Python bindings","text":"<p>Python bindings for vAccel wrap the vAccel C API and provide a native Python API to vAccel operations.</p> <ul> <li>Installation</li> <li>Writing a simple vAccel Python application</li> <li>API reference</li> </ul>"},{"location":"language-bindings/python-bindings/installation/","title":"Installation","text":"<p>The Python bindings are implemented in the <code>vaccel</code> package and are currently a WiP, supporting a subset of the vAccel operations. The package is installable with <code>pip</code> by using the provided Wheels or from source.</p>"},{"location":"language-bindings/python-bindings/installation/#requirements","title":"Requirements","text":"<ul> <li>To use <code>vaccel</code> you need a valid vAccel installation. You can find more   information on how to install vAccel in the   Installation page.</li> </ul> <ul> <li>This package requires Python 3.10 or newer. Verify your Python version with:     <pre><code>python3 --version\n</code></pre>     and update Python as needed using the     official instructions</li> </ul>"},{"location":"language-bindings/python-bindings/installation/#wheel","title":"Wheel","text":"<p>You can get the latest <code>vaccel</code> Wheel package from the Releases page of the vAccel Python repository. Releases include Wheels for x86_64/aarch64/armv7l systems.</p> <p>To install the Wheel package of the latest <code>vaccel</code> release:</p> x86ARM (64-bit)ARM (32-bit) <pre><code>wget https://github.com/nubificus/vaccel-python/releases/download/v0.2.0/vaccel-0.2.0-cp310-abi3-linux_x86_64.whl\npip install vaccel-0.2.0-cp310-abi3-linux_x86_64.whl\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel-python/releases/download/v0.2.0/vaccel-0.2.0-cp310-abi3-linux_aarch64.whl\npip install vaccel-0.2.0-cp310-abi3-linux_aarch64.whl\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel-python/releases/download/v0.2.0/vaccel-0.2.0-cp310-abi3-linux_armv7l.whl\npip install vaccel-0.2.0-cp310-abi3-linux_armv7l.whl\n</code></pre>"},{"location":"language-bindings/python-bindings/installation/#latest-artifacts","title":"Latest artifacts","text":"<p>To install the Wheel artifact of the latest <code>vaccel</code> revision:</p> x86ARM (64-bit)ARM (32-bit) <pre><code>wget https://s3.nbfc.io/nbfc-assets/github/vaccel-python/main/x86_64/vaccel-latest-cp310-abi3-linux_x86_64.whl\npip install vaccel-latest-cp310-abi3-linux_x86_64.whl\n</code></pre> <pre><code>wget https://s3.nbfc.io/nbfc-assets/github/vaccel-python/main/aarch64/vaccel-latest-cp310-abi3-linux_aarch64.whl\npip install vaccel-latest-cp310-abi3-linux_aarch64.whl\n</code></pre> <pre><code>wget https://s3.nbfc.io/nbfc-assets/github/vaccel-python/main/armv7l/vaccel-latest-cp310-abi3-linux_armv7l.whl\npip install vaccel-latest-cp310-abi3-linux_armv7l.whl\n</code></pre>"},{"location":"language-bindings/python-bindings/installation/#building-from-source","title":"Building from source","text":"<p>You can build the package from source directly and install it using <code>pip</code>:</p> <pre><code>pip install git+https://github.com/nubificus/vaccel-python\n</code></pre>"},{"location":"language-bindings/python-bindings/installation/#running-the-examples","title":"Running the examples","text":"<p>Examples of using the package are provided in the examples directory.</p> <p>After cloning the repo:</p> <pre><code>git clone https://github.com/nubificus/vaccel-python\ncd vaccel-python\n</code></pre> <p>you can run all the available examples with sample arguments using:</p> <pre><code>python3 run-examples.py\n</code></pre>"},{"location":"language-bindings/python-bindings/writing-a-simple-vaccel-python-application/","title":"Writing a simple vAccel Python application","text":"<p>For a simple example of using the <code>vaccel</code> package, you can replicate in Python the image classification example from Running the examples.</p> <p>Create a new Python file called <code>classify.py</code> with the following content:</p> classify.py<pre><code>#!/usr/bin/python3\n\nimport sys\nfrom pathlib import Path\n\nfrom vaccel.session import Session\n\n\ndef main():\n    with Path(sys.argv[1]).open(\"rb\") as f:\n        image = f.read()\n\n    sess = Session()\n    print(f\"Session id is {sess.id}\")\n    res = sess.classify(image)\n    print(res)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>As with the original <code>classify</code> example, to execute <code>classify.py</code> you need to configure vAccel:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-noop.so\n</code></pre> <p>Assuming vAccel in installed at <code>/usr/local</code>, running the Python classification should give you:</p> <pre><code>$ python3 classify.py /usr/local/share/vaccel/images/example.jpg\nSession id is 1\n('This is a dummy classification tag!', 'This is a dummy imgname!')\n</code></pre> <p>By adding debug level logging:</p> <pre><code>export VACCEL_LOG_LEVEL=4\n</code></pre> <p>you can get the verbose version of the output:</p> <pre><code>$ python3 classify.py /usr/local/share/vaccel/images/example.jpg\n2025.04.13-21:21:39.87 - &lt;debug&gt; Initializing vAccel\n2025.04.13-21:21:39.87 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.13-21:21:39.87 - &lt;debug&gt; Config:\n2025.04.13-21:21:39.87 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.13-21:21:39.87 - &lt;debug&gt;   log_level = debug\n2025.04.13-21:21:39.87 - &lt;debug&gt;   log_file = (null)\n2025.04.13-21:21:39.87 - &lt;debug&gt;   profiling_enabled = false\n2025.04.13-21:21:39.87 - &lt;debug&gt;   version_ignore = false\n2025.04.13-21:21:39.87 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/WTLhQW\n2025.04.13-21:21:39.87 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op noop from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op blas_sgemm from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op image_classify from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op image_detect from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op image_segment from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op image_pose from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op image_depth from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op exec from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op tf_session_load from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op tf_session_run from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op tf_session_delete from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op minmax from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op fpga_arraycopy from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op fpga_vectoradd from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op fpga_parallel from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op fpga_mmult from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op exec_with_resource from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op torch_jitload_forward from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op torch_sgemm from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op opencv from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op tflite_session_load from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op tflite_session_run from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Registered op tflite_session_delete from plugin noop\n2025.04.13-21:21:39.87 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n2025.04.13-21:21:39.88 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/WTLhQW/session.1\n2025.04.13-21:21:39.88 - &lt;debug&gt; Initialized session 1\nSession id is 1\n2025.04.13-21:21:39.88 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.13-21:21:39.88 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.13-21:21:39.88 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.13-21:21:39.88 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.13-21:21:39.88 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.13-21:21:39.88 - &lt;debug&gt; [noop] model: (null)\n2025.04.13-21:21:39.88 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.13-21:21:39.88 - &lt;debug&gt; [noop] len_out_text: 500\n2025.04.13-21:21:39.88 - &lt;debug&gt; [noop] len_out_imgname: 500\n2025.04.13-21:21:39.88 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.13-21:21:39.88 - &lt;debug&gt; [noop] will return a dummy result\n('This is a dummy classification tag!', 'This is a dummy imgname!')\n2025.04.13-21:21:39.88 - &lt;debug&gt; Released session 1\n2025.04.13-21:21:39.89 - &lt;debug&gt; Cleaning up vAccel\n2025.04.13-21:21:39.89 - &lt;debug&gt; Cleaning up sessions\n2025.04.13-21:21:39.89 - &lt;debug&gt; Cleaning up resources\n2025.04.13-21:21:39.89 - &lt;debug&gt; Cleaning up plugins\n2025.04.13-21:21:39.89 - &lt;debug&gt; Unregistered plugin noop\n</code></pre> <p>The vAccel output of <code>classify</code> and <code>classify.py</code> should be almost identical.</p> <p>Info</p> <p>For a full example with near identical functionality to the C <code>classify</code> you can look at the image classification example of the <code>vaccel-python</code> repository,</p>"},{"location":"language-bindings/python-bindings/api-reference/","title":"API reference","text":"<ul> <li>vaccel</li> </ul>"},{"location":"language-bindings/rust-bindings/","title":"Rust bindings","text":"<p>Rust bindings for vAccel wrap the vAccel C API and provide a native Rust API to vAccel operations.</p> <ul> <li>Usage</li> <li>Writing a simple vAccel Rust application</li> </ul>"},{"location":"language-bindings/rust-bindings/usage/","title":"Usage","text":"<p>The Rust bindings are implemented in the <code>vaccel</code> Rust crate and feature a large subset of the vAccel operations.</p>"},{"location":"language-bindings/rust-bindings/usage/#requirements","title":"Requirements","text":"<ul> <li>To use the <code>vaccel</code> Rust crate you need a working vAccel installation. You can   find more information on how to install vAccel in the   Installation page.</li> </ul> <ul> <li>This package requires Rust 1.70 or newer. Verify your Rust version with:     <pre><code>rustc version\n</code></pre>     and update Rust as needed using the     official instructions.</li> </ul>"},{"location":"language-bindings/rust-bindings/usage/#using-the-vaccel-crate","title":"Using the <code>vaccel</code> crate","text":"<p>You can use the package in your Rust code like any other crate with:</p> <pre><code>[dependencies]\nvaccel = { git = \"https://github.com/nubificus/vaccel-rust\" }\n</code></pre> <p>Info</p> <p>To include a crate from a rust workspace repo, you need to specify the name of the crate as the dependency.</p>"},{"location":"language-bindings/rust-bindings/usage/#running-the-examples","title":"Running the examples","text":"<p>You can find examples in the examples directory of the repository. The provided examples are similar to the C examples and you must configure vAccel in order to use them.</p> <p>To run a simple session init/release, like the C <code>noop</code> example, clone the bindings repo:</p> <pre><code>git clone https://github.com/nubificus/vaccel-rust\ncd vaccel-rust/vaccel-bindings\n</code></pre> <p>Build the examples:</p> <pre><code>$ cargo build --examples\nwarning: virtual workspace defaulting to `resolver = \"1\"` despite one or more workspace members being on edition 2021 which implies `resolver = \"2\"`\nnote: to keep the current resolver, specify `workspace.resolver = \"1\"` in the workspace root's manifest\nnote: to use the edition 2021 resolver, specify `workspace.resolver = \"2\"` in the workspace root's manifest\nnote: for more details see https://doc.rust-lang.org/cargo/reference/resolver.html#resolver-versions\n    Updating crates.io index\n    Updating git repository `https://github.com/nubificus/ttrpc-rust.git`\n   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n[snipped]\n   Compiling vaccel v0.0.0 (/home/ananos/develop/fresh/playground/vaccel-rust/vaccel-bindings)\n   Compiling futures-executor v0.3.31\n   Compiling futures v0.3.31\n   Compiling protobuf-parse v3.7.2\n   Compiling tokio-vsock v0.4.0\n   Compiling protobuf-codegen v3.7.2\n   Compiling ttrpc-codegen v0.5.0 (https://github.com/nubificus/ttrpc-rust.git?branch=vaccel-dev#30b79e78)\n   Compiling ttrpc v0.8.3 (https://github.com/nubificus/ttrpc-rust.git?branch=vaccel-dev#30b79e78)\n   Compiling vaccel-rpc-proto v0.0.0 (/home/ananos/develop/fresh/playground/vaccel-rust/vaccel-rpc-proto)\n    Finished dev [unoptimized + debuginfo] target(s) in 24.59s\n</code></pre> <p>If all went well, the examples' binaries should be available in <code>../target/debug/examples</code>.</p> <p>Note</p> <p>The directory is one level up, in the <code>vaccel-rust</code> workspace.</p> <p>Set the config environment variables:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-noop.so\n</code></pre> <p>and, assuming vAccel is installed at <code>/usr/local</code>, run with:</p> <pre><code>$ ../target/debug/examples/session\n[2025-04-16T14:44:07Z INFO  session] Starting vAccel session handling example\n[2025-04-16T14:44:07Z INFO  session] Creating new vAccel session\n[2025-04-16T14:44:07Z INFO  session] Initialized session 1\n[2025-04-16T14:44:07Z INFO  session] Releasing session 1\n[2025-04-16T14:44:07Z INFO  session] Done\n</code></pre> <p>By setting log level to debug:</p> <pre><code>export VACCEL_LOG_LEVEL=4\n</code></pre> <p>you can see the verbose vAccel output:</p> <pre><code>$ ../target/debug/examples/session\n2025.04.16-14:43:15.99 - &lt;debug&gt; Initializing vAccel\n2025.04.16-14:43:15.99 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.16-14:43:15.99 - &lt;debug&gt; Config:\n2025.04.16-14:43:15.99 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.16-14:43:15.99 - &lt;debug&gt;   log_level = debug\n2025.04.16-14:43:15.99 - &lt;debug&gt;   log_file = (null)\n2025.04.16-14:43:15.99 - &lt;debug&gt;   profiling_enabled = true\n2025.04.16-14:43:15.99 - &lt;debug&gt;   version_ignore = true\n2025.04.16-14:43:15.99 - &lt;debug&gt; Created top-level rundir: /run/user/1000/vaccel/oOGHc5\n2025.04.16-14:43:15.99 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op noop from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op blas_sgemm from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op image_classify from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op image_detect from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op image_segment from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op image_pose from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op image_depth from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op exec from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op tf_session_load from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op tf_session_run from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op tf_session_delete from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op minmax from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op fpga_arraycopy from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op fpga_vectoradd from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op fpga_parallel from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op fpga_mmult from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op exec_with_resource from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op torch_jitload_forward from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op torch_sgemm from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op opencv from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op tflite_session_load from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op tflite_session_run from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Registered op tflite_session_delete from plugin noop\n2025.04.16-14:43:15.99 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n[2025-04-16T14:43:15Z INFO  session] Starting vAccel session handling example\n[2025-04-16T14:43:15Z INFO  session] Creating new vAccel session\n2025.04.16-14:43:15.99 - &lt;debug&gt; New rundir for session 1: /run/user/1000/vaccel/oOGHc5/session.1\n2025.04.16-14:43:15.99 - &lt;debug&gt; Initialized session 1\n[2025-04-16T14:43:15Z INFO  session] Initialized session 1\n[2025-04-16T14:43:15Z INFO  session] Releasing session 1\n2025.04.16-14:43:15.99 - &lt;debug&gt; Released session 1\n[2025-04-16T14:43:15Z INFO  session] Done\n2025.04.16-14:43:15.99 - &lt;debug&gt; Cleaning up vAccel\n2025.04.16-14:43:15.99 - &lt;debug&gt; Cleaning up sessions\n2025.04.16-14:43:15.99 - &lt;debug&gt; Cleaning up resources\n2025.04.16-14:43:15.99 - &lt;debug&gt; Cleaning up plugins\n2025.04.16-14:43:15.99 - &lt;debug&gt; Unregistered plugin noop\n</code></pre>"},{"location":"language-bindings/rust-bindings/writing-a-simple-vaccel-rust-application/","title":"Writing a simple vAccel Rust application","text":"<p>For a simple example of using the <code>vaccel</code> Rust crate, you can replicate in Rust an image classification application similar to the image classification example from Running the examples.</p> <p>Initialize a new <code>rust-vaccel-classify</code> project and module:</p> <pre><code>mkdir rust-vaccel-classify\ncd rust-vaccel-classify\ncargo init\n</code></pre> <p>You should get the following file/directory structure:</p> <pre><code>rust-vaccel-classify\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main.rs\n\n2 directories, 2 files\n</code></pre> <p>Edit the <code>Cargo.toml</code> file with the following content:</p> Cargo.toml<pre><code>[package]\nname = \"rust-vaccel-classify\"\nversion = \"0.1.0\"\nedition = \"2021\"\nlicense = \"Apache-2.0\"\n\n[features]\ndefault = [\"profiling\"]\nprofiling = []\n\n[dependencies]\nvaccel = { git = \"https://github.com/nubificus/vaccel-rust\" }\nprotobuf = \"3.1\"\nenv_logger = \"0.11\"\nlog = \"0.4\"\nlibc = \"0.2\"\nthiserror = \"1.0\"\n\n[build-dependencies]\nlibc = \"0.2\"\nbindgen = \"0.69\"\npkg-config = \"0.3\"\n\n[dev-dependencies]\nenv_logger = \"0.11\"\nlog = \"0.4\"\n</code></pre> <p>Edit the necessary logic into <code>src/main.rs</code>:</p> src/main.rs<pre><code>// SPDX-License-Identifier: Apache-2.0\nuse env_logger::Env;\nuse log::{error, info};\nuse std::env;\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\nuse vaccel::*;\n\nfn main() {\n    env_logger::Builder::from_env(Env::default().default_filter_or(\"debug\")).init();\n    info!(\"Starting vAccel classification example\");\n\n    let args: Vec&lt;String&gt; = env::args().collect();\n    if args.len() &lt; 2 {\n        error!(\"Usage: {} &lt;image_path&gt;\", args[0]);\n        return;\n    }\n\n    let image_path = &amp;args[1];\n    if !Path::new(image_path).exists() {\n        error!(\"Image file not found: {}\", image_path);\n        return;\n    }\n\n    info!(\"Creating new vAccel session\");\n    let mut sess = match Session::new(0) {\n        Ok(sess) =&gt; sess,\n        Err(e) =&gt; {\n            error!(\"Error creating session: {}\", e);\n            return;\n        }\n    };\n    info!(\"Initialized session {}\", sess.id());\n\n    info!(\"Reading image file: {}\", image_path);\n    let mut file = match File::open(image_path) {\n        Ok(file) =&gt; file,\n        Err(e) =&gt; {\n            error!(\"Failed to open image file: {}\", e);\n            return;\n        }\n    };\n\n    let mut image_data = Vec::new();\n    if let Err(e) = file.read_to_end(&amp;mut image_data) {\n        error!(\"Failed to read image data: {}\", e);\n        return;\n    }\n    info!(\"Read image data: {} bytes\", image_data.len());\n\n    info!(\"Performing image classification\");\n    let ret = sess.image_classification(&amp;mut image_data);\n\n    match ret {\n        Ok((first_vec, second_vec)) =&gt; {\n            let first_str = String::from_utf8_lossy(&amp;first_vec);\n            let second_str = String::from_utf8_lossy(&amp;second_vec);\n\n            info!(\"Classification completed successfully\");\n            println!(\"Classification tags: {}\", first_str);\n            println!(\"Annotated image: {}\", second_str);\n        }\n        Err(e) =&gt; {\n            error!(\"Classification failed: {:?}\", e);\n        }\n    }\n\n    info!(\"Releasing session {}\", sess.id());\n    match sess.release() {\n        Ok(()) =&gt; info!(\"Session released successfully\"),\n        Err(e) =&gt; error!(\"Error releasing session: {}\", e),\n    }\n}\n</code></pre> <p>Note</p> <p>You can omit <code>sess.release()</code> if you don't need custom error handling. The session will be released when the object is dropped.</p> <p>Build it:</p> <pre><code>$ cargo build\n    Updating crates.io index\n    Updating git repository `https://github.com/nubificus/vaccel-rust`\n    Updating git repository `https://github.com/nubificus/ttrpc-rust.git`\n   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling autocfg v1.4.0\n   Compiling cfg-if v1.0.0\n[snipped]\n   Compiling tokio-vsock v0.4.0\n   Compiling vaccel v0.0.0 (https://github.com/nubificus/vaccel-rust#0af1c664)\n   Compiling protobuf-parse v3.7.2\n   Compiling protobuf-codegen v3.7.2\n   Compiling ttrpc-codegen v0.5.0 (https://github.com/nubificus/ttrpc-rust.git?branch=vaccel-dev#30b79e78)\n   Compiling ttrpc v0.8.3 (https://github.com/nubificus/ttrpc-rust.git?branch=vaccel-dev#30b79e78)\n   Compiling vaccel-rpc-proto v0.0.0 (https://github.com/nubificus/vaccel-rust#0af1c664)\n   Compiling rust-vaccel-classify v0.1.0 (/home/ananos/develop/fresh/playground/rust-vaccel-classify)\n    Finished dev [unoptimized + debuginfo] target(s) in 25.90s\n</code></pre> <p>And you are ready to run your application.</p> <p>Configure vAccel:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-noop.so\nexport VACCEL_LOG_LEVEL=4\n</code></pre> <p>and run with:</p> <pre><code>$ cargo run /usr/share/vaccel/images/example.jpg\n    Finished dev [unoptimized + debuginfo] target(s) in 0.07s\n     Running `target/debug/rust-vaccel-classify /usr/share/vaccel/images/example.jpg`\n2025.04.16-14:39:45.13 - &lt;debug&gt; Initializing vAccel\n2025.04.16-14:39:45.13 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.16-14:39:45.13 - &lt;debug&gt; Config:\n2025.04.16-14:39:45.13 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.16-14:39:45.13 - &lt;debug&gt;   log_level = debug\n2025.04.16-14:39:45.13 - &lt;debug&gt;   log_file = (null)\n2025.04.16-14:39:45.13 - &lt;debug&gt;   profiling_enabled = true\n2025.04.16-14:39:45.13 - &lt;debug&gt;   version_ignore = true\n2025.04.16-14:39:45.13 - &lt;debug&gt; Created top-level rundir: /run/user/1000/vaccel/jesuwX\n2025.04.16-14:39:45.13 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op noop from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op blas_sgemm from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op image_classify from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op image_detect from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op image_segment from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op image_pose from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op image_depth from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op exec from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op tf_session_load from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op tf_session_run from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op tf_session_delete from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op minmax from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op fpga_arraycopy from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op fpga_vectoradd from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op fpga_parallel from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op fpga_mmult from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op exec_with_resource from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op torch_jitload_forward from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op torch_sgemm from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op opencv from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op tflite_session_load from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op tflite_session_run from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Registered op tflite_session_delete from plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n[2025-04-16T14:39:45Z INFO  rust_vaccel_classify] Starting vAccel classification example\n[2025-04-16T14:39:45Z INFO  rust_vaccel_classify] Creating new vAccel session\n2025.04.16-14:39:45.13 - &lt;debug&gt; New rundir for session 1: /run/user/1000/vaccel/jesuwX/session.1\n2025.04.16-14:39:45.13 - &lt;debug&gt; Initialized session 1\n[2025-04-16T14:39:45Z INFO  rust_vaccel_classify] Initialized session 1\n[2025-04-16T14:39:45Z INFO  rust_vaccel_classify] Reading image file: /usr/share/vaccel/images/example.jpg\n[2025-04-16T14:39:45Z INFO  rust_vaccel_classify] Read image data: 79281 bytes\n[2025-04-16T14:39:45Z INFO  rust_vaccel_classify] Performing image classification\n2025.04.16-14:39:45.13 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.16-14:39:45.13 - &lt;debug&gt; Start profiling region vaccel_image_op\n2025.04.16-14:39:45.13 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.16-14:39:45.13 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.16-14:39:45.13 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.16-14:39:45.13 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.16-14:39:45.13 - &lt;debug&gt; [noop] model: (null)\n2025.04.16-14:39:45.13 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.16-14:39:45.13 - &lt;debug&gt; [noop] len_out_text: 1024\n2025.04.16-14:39:45.13 - &lt;debug&gt; [noop] len_out_imgname: 1024\n2025.04.16-14:39:45.13 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.16-14:39:45.13 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.16-14:39:45.13 - &lt;debug&gt; Stop profiling region vaccel_image_op\n[2025-04-16T14:39:45Z INFO  rust_vaccel_classify] Classification completed successfully\nClassification tags: This is a dummy classification tag!\nAnnotated image: This is a dummy imgname!\n[2025-04-16T14:39:45Z INFO  rust_vaccel_classify] Releasing session 1\n2025.04.16-14:39:45.13 - &lt;debug&gt; Released session 1\n[2025-04-16T14:39:45Z INFO  rust_vaccel_classify] Session released successfully\n2025.04.16-14:39:45.13 - &lt;debug&gt; Cleaning up vAccel\n2025.04.16-14:39:45.13 - &lt;debug&gt; Cleaning up sessions\n2025.04.16-14:39:45.13 - &lt;debug&gt; Cleaning up resources\n2025.04.16-14:39:45.13 - &lt;debug&gt; Cleaning up plugins\n2025.04.16-14:39:45.13 - &lt;debug&gt; Unregistered plugin noop\n</code></pre> <p>The vAccel output of <code>classify</code> and <code>rust-vaccel-classify</code> should be almost identical.</p>"},{"location":"plugins/","title":"Plugins","text":"<p>Discover the available plugins and their usage.</p> <ul> <li>About plugins</li> <li>Available plugins</li> </ul>"},{"location":"plugins/about-plugins/","title":"About plugins","text":"<p>Plugins are an essential part of vAccel. They contain the implementations of the operations defined in the API. By keeping the implementation logic separate from the operation definition, vAccel enables the use of different acceleration frameworks without requiring the modification or recompilation of the application binaries. This means, that a compiled vAccel application can use any acceleration implementation available as a plugin by simply specifying the plugin at runtime.</p> <p>A vAccel plugin has the form of a shared object (library) that can be loaded with <code>dlopen()</code>. The object can be compiled from any language as long as the contained symbols/functions are callable from <code>C</code>.</p> <p>You can better understand the use of the plugin system by trying to run an example with different plugins.</p> <p>The image classification example is based on the relevant User API operation. The operation is supported by the <code>NoOp</code> plugin, that we used in Running the examples. It is also supported by the Torch and the TVM plugins. This means that the same <code>classify</code> binary can be used to run with the NoOp, the Torch and the TVM vAccel image classification implementations simply by specifying the relevant plugin (provided all dependencies are installed).</p>"},{"location":"plugins/available-plugins/","title":"Available plugins","text":"<p>There are different types of plugins available:</p> <ul> <li>Bundled plugins that come with the core vAccel   installation and are designed to help with development</li> <li>Acceleration plugins that provide   hardware-accelerated implementations of vAccel operations</li> <li>Transport plugins that implement transport   mechanisms for vAccel (ie. for remote execution)</li> </ul> <p>Make sure vAccel is installed before trying to use any of the plugins.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/","title":"Acceleration plugins","text":"<p>Acceleration plugins provide implementations of vAccel operations leveraging common acceleration frameworks:</p> <ul> <li>Torch plugin</li> <li>TVM plugin</li> <li>Tensorflow plugin</li> </ul>"},{"location":"plugins/available-plugins/acceleration-plugins/tf-plugin/","title":"Tensorflow Plugin","text":"<p>The Tensorflow plugin for vAccel implements basic Tensorflow and Tensorflow Lite support for vAccel operations.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/tf-plugin/#supported-operations","title":"Supported operations","text":"<ul> <li>TensorFlow model load</li> <li>TensorFlow model unload</li> <li>TensorFlow model run</li> <li>TensorFlow Lite model load</li> <li>TensorFlow Lite model unload</li> <li>TensorFlow Lite model run</li> </ul>"},{"location":"plugins/available-plugins/acceleration-plugins/tf-plugin/#installing-tensorflow-and-tensorflow-lite-cc-api-files","title":"Installing Tensorflow and Tensorflow Lite C/C++ API files","text":"<p>You can find instructions on how to install the required files on the Build and Install Tensorflow page. The rest of this guide assumes Tensorflow is installed at <code>/usr/local</code> and its' libraries are at <code>/usr/local/lib</code>.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/tf-plugin/#installing-the-plugin","title":"Installing the plugin","text":"<p>You can get the latest Tensorflow plugin binary release from the Releases page of the vAccel repository. Releases include binaries for x86_64/aarch64 Ubuntu-based systems.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/tf-plugin/#requirements","title":"Requirements","text":"<p>The prebuilt TF plugin binaries depend on libarchive. You can install it with:</p> <pre><code>sudo apt install libarchive13\n</code></pre>"},{"location":"plugins/available-plugins/acceleration-plugins/tf-plugin/#tar","title":"TAR","text":"<p>To install the TAR binary package of the latest Tensorflow plugin release:</p> x86ARM (64-bit) <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-tf_0.2.0_amd64.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel-tf_0.2.0_amd64.tar.gz --strip-components=2 -C /usr/local\n# Update pkg-config files with the correct prefix\nfind /usr/local -name \"vaccel-tf.pc\" -exec sed -i 's:^\\(prefix=\\).*:\\1/usr/local:g' {} \\;\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-tf_0.2.0_arm64.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel-tf_0.2.0_arm64.tar.gz --strip-components=2 -C /usr/local\n# Update pkg-config files with the correct prefix\nfind /usr/local -name \"vaccel-tf.pc\" -exec sed -i 's:^\\(prefix=\\).*:\\1/usr/local:g' {} \\;\n</code></pre>"},{"location":"plugins/available-plugins/acceleration-plugins/tf-plugin/#latest-artifacts","title":"Latest artifacts","text":"<p>You can also find prebuilt artifacts of the latest Tensorflow plugin revision at:</p> x86ARM (64-bit) <pre><code># TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/tf/rev/main/x86_64/release/vaccel-tf-latest-bin.tar.gz\n</code></pre> <pre><code># TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/tf/rev/main/aarch64/release/vaccel-tf-latest-bin.tar.gz\n</code></pre>"},{"location":"plugins/available-plugins/acceleration-plugins/tf-plugin/#usage","title":"Usage","text":"<p>To specify Tensorflow plugin as the selected plugin for vAccel execution:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-tf.so\n</code></pre> <p>Ensure Tensorflow, vAccel and the Tensorflow plugin libraries are in the library search paths before trying to use the plugin.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/tf-plugin/#running-an-example","title":"Running an example","text":"<p>Export the necessary variables:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-tf.so\n# Optionally, for verbose output\nexport VACCEL_LOG_LEVEL=4\n</code></pre> <p>Assuming vAccel is installed at <code>/usr/local</code>, you can run an image classification with a ResNet model from <code>https://s3.nbfc.io/models/tf/resnet18-v2-7_saved_model.tar.xz</code> with:</p> <pre><code>$ tf_inference \\\n      /usr/local/share/vaccel/images/example.jpg \\\n      https://s3.nbfc.io/models/tf/resnet18-v2-7_saved_model.tar.xz \\\n      /usr/local/share/vaccel/labels/imagenet.txt\n2025.07.19-20:55:09.21 - &lt;debug&gt; Initializing vAccel\n2025.07.19-20:55:09.21 - &lt;info&gt; vAccel 0.7.1-22-edced930\n2025.07.19-20:55:09.21 - &lt;debug&gt; Config:\n2025.07.19-20:55:09.21 - &lt;debug&gt;   plugins = libvaccel-tf.so\n2025.07.19-20:55:09.21 - &lt;debug&gt;   log_level = debug\n2025.07.19-20:55:09.21 - &lt;debug&gt;   log_file = (null)\n2025.07.19-20:55:09.21 - &lt;debug&gt;   profiling_enabled = false\n2025.07.19-20:55:09.21 - &lt;debug&gt;   version_ignore = false\n2025.07.19-20:55:09.21 - &lt;debug&gt; Created top-level rundir: /run/user/0/vaccel/sZDGgp\n2025-07-19 20:55:09.252594: I tensorflow/core/util/port.cc:153] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`.\n2025-07-19 20:55:09.274317: I tensorflow/core/util/port.cc:153] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`.\n2025.07.19-20:55:09.27 - &lt;info&gt; Registered plugin tf 0.2.0-4-4c18a4c1\n2025.07.19-20:55:09.27 - &lt;debug&gt; Registered op tf_model_load from plugin tf\n2025.07.19-20:55:09.27 - &lt;debug&gt; Registered op tf_model_unload from plugin tf\n2025.07.19-20:55:09.27 - &lt;debug&gt; Registered op tf_model_run from plugin tf\n2025.07.19-20:55:09.27 - &lt;debug&gt; Registered op tflite_model_load from plugin tf\n2025.07.19-20:55:09.27 - &lt;debug&gt; Registered op tflite_model_unload from plugin tf\n2025.07.19-20:55:09.27 - &lt;debug&gt; Registered op tflite_model_run from plugin tf\n2025.07.19-20:55:09.27 - &lt;debug&gt; Loaded plugin tf from libvaccel-tf.so\n2025.07.19-20:55:09.27 - &lt;debug&gt; Initialized resource 1\nInitialized model resource 1\n2025.07.19-20:55:09.27 - &lt;debug&gt; New rundir for session 1: /run/user/0/vaccel/sZDGgp/session.1\n2025.07.19-20:55:09.27 - &lt;debug&gt; Initialized session 1\nInitialized vAccel session 1\n2025.07.19-20:55:09.27 - &lt;debug&gt; New rundir for resource 1: /run/user/0/vaccel/sZDGgp/resource.1\n2025.07.19-20:55:09.27 - &lt;debug&gt; Downloading https://s3.nbfc.io/models/tf/resnet18-v2-7_saved_model.tar.xz\n2025.07.19-20:55:10.56 - &lt;debug&gt; Downloaded: 41.0 MB of 41.0 MB (100.0%) | Speed: 31.91 MB/sec\n2025.07.19-20:55:10.56 - &lt;debug&gt; Download completed successfully\n2025.07.19-20:55:10.56 - &lt;debug&gt; session:1 Registered resource 1\n2025.07.19-20:55:10.56 - &lt;debug&gt; session:1 Looking for plugin implementing op tf_model_load\n2025.07.19-20:55:10.56 - &lt;debug&gt; Returning func from hint plugin tf\n2025.07.19-20:55:10.56 - &lt;debug&gt; Found implementation in tf plugin\n2025.07.19-20:55:10.56 - &lt;debug&gt; [tf] Loading session from SavedModel\n2025.07.19-20:55:10.57 - &lt;debug&gt; [tf][archive] Extracting: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model/\n2025.07.19-20:55:10.57 - &lt;debug&gt; [tf][archive] Extracting: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model/assets/\n2025.07.19-20:55:10.57 - &lt;debug&gt; [tf][archive] Extracting: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model/fingerprint.pb\n2025.07.19-20:55:10.57 - &lt;debug&gt; [tf][archive] Extracting: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model/saved_model.pb\n2025.07.19-20:55:12.64 - &lt;debug&gt; [tf][archive] Extracting: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model/variables/\n2025.07.19-20:55:12.64 - &lt;debug&gt; [tf][archive] Extracting: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model/variables/variables.data-00000-of-00001\n2025.07.19-20:55:12.64 - &lt;debug&gt; [tf][archive] Extracting: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model/variables/variables.index\n2025-07-19 20:55:12.648567: I tensorflow/cc/saved_model/reader.cc:83] Reading SavedModel from: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model\n2025-07-19 20:55:12.668441: I tensorflow/cc/saved_model/reader.cc:52] Reading meta graph with tags { serve }\n2025-07-19 20:55:12.668473: I tensorflow/cc/saved_model/reader.cc:147] Reading SavedModel debug info (if present) from: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model\n2025-07-19 20:55:12.668536: I tensorflow/core/platform/cpu_feature_guard.cc:210] This TensorFlow binary is optimized to use available CPU instructions in performance-critical operations.\nTo enable the following instructions: SSE3 SSE4.1 SSE4.2 AVX AVX2 AVX_VNNI FMA, in other operations, rebuild TensorFlow with the appropriate compiler flags.\n2025-07-19 20:55:12.742341: I tensorflow/compiler/mlir/mlir_graph_optimization_pass.cc:388] MLIR V1 optimization pass is not enabled\n2025-07-19 20:55:12.743065: I tensorflow/cc/saved_model/loader.cc:236] Restoring SavedModel bundle.\n2025-07-19 20:55:12.776518: I tensorflow/cc/saved_model/loader.cc:220] Running initialization op on SavedModel bundle at path: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model\n2025-07-19 20:55:12.806477: I tensorflow/cc/saved_model/loader.cc:462] SavedModel load for tags { serve }; Status: success: OK. Took 157910 microseconds.\n2025.07.19-20:55:12.82 - &lt;debug&gt; [tf] Model loaded correctly\nSession load status =&gt; code:0 message:\n2025.07.19-20:55:12.86 - &lt;debug&gt; session:1 Looking for plugin implementing op tf_model_run\n2025.07.19-20:55:12.86 - &lt;debug&gt; Returning func from hint plugin tf\n2025.07.19-20:55:12.86 - &lt;debug&gt; Found implementation in tf plugin\n2025.07.19-20:55:12.86 - &lt;debug&gt; [tf] Running session\n2025.07.19-20:55:13.50 - &lt;debug&gt; [tf] Success\nSession run status =&gt; code:0 message:\nSuccess!\nOutput tensor =&gt; type:1 nr_dims:2 size:4000B\nPrediction: banana\n2025.07.19-20:55:13.50 - &lt;debug&gt; session:1 Looking for plugin implementing op tf_model_unload\n2025.07.19-20:55:13.50 - &lt;debug&gt; Returning func from hint plugin tf\n2025.07.19-20:55:13.50 - &lt;debug&gt; Found implementation in tf plugin\n2025.07.19-20:55:13.50 - &lt;debug&gt; [tf] Deleting session\n2025.07.19-20:55:13.50 - &lt;debug&gt; [tf][archive] Removed file: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model/fingerprint.pb\n2025.07.19-20:55:13.50 - &lt;debug&gt; [tf][archive] Removed file: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model/variables/variables.index\n2025.07.19-20:55:13.50 - &lt;debug&gt; [tf][archive] Removed file: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model/variables/variables.data-00000-of-00001\n2025.07.19-20:55:13.50 - &lt;debug&gt; [tf][archive] Removed directory: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model/variables\n2025.07.19-20:55:13.51 - &lt;debug&gt; [tf][archive] Removed file: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model/saved_model.pb\n2025.07.19-20:55:13.51 - &lt;debug&gt; [tf][archive] Removed directory: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model/assets\n2025.07.19-20:55:13.51 - &lt;debug&gt; [tf][archive] Removed directory: /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model\nSession delete status =&gt; code:0 message:\n2025.07.19-20:55:13.51 - &lt;debug&gt; session:1 Unregistered resource 1\n2025.07.19-20:55:13.51 - &lt;debug&gt; Released session 1\n2025.07.19-20:55:13.51 - &lt;debug&gt; Removing file /run/user/0/vaccel/sZDGgp/resource.1/resnet18-v2-7_saved_model.tar.xz\n2025.07.19-20:55:13.51 - &lt;debug&gt; Released resource 1\n2025.07.19-20:55:13.51 - &lt;debug&gt; Cleaning up vAccel\n2025.07.19-20:55:13.51 - &lt;debug&gt; Cleaning up sessions\n2025.07.19-20:55:13.51 - &lt;debug&gt; Cleaning up resources\n2025.07.19-20:55:13.51 - &lt;debug&gt; Cleaning up plugins\n2025.07.19-20:55:13.51 - &lt;debug&gt; Unregistered plugin tf\n</code></pre> <p>You can also run a similar inference example using Tensorflow Lite with:</p> <pre><code>$ tflite_inference \\\n      /usr/local/share/vaccel/images/example.jpg \\\n      https://s3.nbfc.io/models/tf/resnet18-v2-7_float32.tflite \\\n      /usr/local/share/vaccel/labels/imagenet.txt\n2025.07.19-20:55:13.54 - &lt;debug&gt; Initializing vAccel\n2025.07.19-20:55:13.54 - &lt;info&gt; vAccel 0.7.1-22-edced930\n2025.07.19-20:55:13.54 - &lt;debug&gt; Config:\n2025.07.19-20:55:13.54 - &lt;debug&gt;   plugins = libvaccel-tf.so\n2025.07.19-20:55:13.54 - &lt;debug&gt;   log_level = debug\n2025.07.19-20:55:13.54 - &lt;debug&gt;   log_file = (null)\n2025.07.19-20:55:13.54 - &lt;debug&gt;   profiling_enabled = false\n2025.07.19-20:55:13.54 - &lt;debug&gt;   version_ignore = false\n2025.07.19-20:55:13.54 - &lt;debug&gt; Created top-level rundir: /run/user/0/vaccel/hsuZdP\n2025-07-19 20:55:13.568854: I tensorflow/core/util/port.cc:153] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`.\n2025-07-19 20:55:13.595803: I tensorflow/core/util/port.cc:153] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`.\n2025.07.19-20:55:13.59 - &lt;info&gt; Registered plugin tf 0.2.0-4-4c18a4c1\n2025.07.19-20:55:13.59 - &lt;debug&gt; Registered op tf_model_load from plugin tf\n2025.07.19-20:55:13.59 - &lt;debug&gt; Registered op tf_model_unload from plugin tf\n2025.07.19-20:55:13.59 - &lt;debug&gt; Registered op tf_model_run from plugin tf\n2025.07.19-20:55:13.59 - &lt;debug&gt; Registered op tflite_model_load from plugin tf\n2025.07.19-20:55:13.59 - &lt;debug&gt; Registered op tflite_model_unload from plugin tf\n2025.07.19-20:55:13.59 - &lt;debug&gt; Registered op tflite_model_run from plugin tf\n2025.07.19-20:55:13.59 - &lt;debug&gt; Loaded plugin tf from libvaccel-tf.so\n2025.07.19-20:55:13.59 - &lt;debug&gt; Initialized resource 1\nInitialized model resource 1\n2025.07.19-20:55:13.59 - &lt;debug&gt; New rundir for session 1: /run/user/0/vaccel/hsuZdP/session.1\n2025.07.19-20:55:13.59 - &lt;debug&gt; Initialized session 1\nInitialized vAccel session 1\n2025.07.19-20:55:13.59 - &lt;debug&gt; New rundir for resource 1: /run/user/0/vaccel/hsuZdP/resource.1\n2025.07.19-20:55:13.59 - &lt;debug&gt; Downloading https://s3.nbfc.io/models/tf/resnet18-v2-7_float32.tflite\n2025.07.19-20:55:14.72 - &lt;debug&gt; Downloaded: 44.6 MB of 44.6 MB (100.0%) | Speed: 39.69 MB/sec\n2025.07.19-20:55:14.72 - &lt;debug&gt; Download completed successfully\n2025.07.19-20:55:14.72 - &lt;debug&gt; session:1 Registered resource 1\n2025.07.19-20:55:14.72 - &lt;debug&gt; session:1 Looking for plugin implementing op tflite_model_load\n2025.07.19-20:55:14.72 - &lt;debug&gt; Returning func from hint plugin tf\n2025.07.19-20:55:14.72 - &lt;debug&gt; Found implementation in tf plugin\n2025.07.19-20:55:14.72 - &lt;debug&gt; [tf][tflite] Loading session from model\n2025.07.19-20:55:14.72 - &lt;debug&gt; [tf][tflite] Model loaded correctly\n2025.07.19-20:55:14.73 - &lt;debug&gt; session:1 Looking for plugin implementing op tflite_model_run\n2025.07.19-20:55:14.73 - &lt;debug&gt; Returning func from hint plugin tf\n2025.07.19-20:55:14.73 - &lt;debug&gt; Found implementation in tf plugin\n2025.07.19-20:55:14.73 - &lt;debug&gt; [tf][tflite] Running session\n2025.07.19-20:55:14.83 - &lt;debug&gt; [tf][tflite] Success\nSession run status: 0\nSuccess!\nOutput tensor =&gt; type:1 nr_dims:2 size:4000B\nPrediction: banana\n2025.07.19-20:55:14.83 - &lt;debug&gt; session:1 Looking for plugin implementing op tflite_model_unload\n2025.07.19-20:55:14.83 - &lt;debug&gt; Returning func from hint plugin tf\n2025.07.19-20:55:14.83 - &lt;debug&gt; Found implementation in tf plugin\n2025.07.19-20:55:14.83 - &lt;debug&gt; session:1 Unregistered resource 1\n2025.07.19-20:55:14.83 - &lt;debug&gt; Released session 1\n2025.07.19-20:55:14.83 - &lt;debug&gt; Removing file /run/user/0/vaccel/hsuZdP/resource.1/resnet18-v2-7_float32.tflite\n2025.07.19-20:55:14.83 - &lt;debug&gt; Released resource 1\n2025.07.19-20:55:14.83 - &lt;debug&gt; Cleaning up vAccel\n2025.07.19-20:55:14.83 - &lt;debug&gt; Cleaning up sessions\n2025.07.19-20:55:14.83 - &lt;debug&gt; Cleaning up resources\n2025.07.19-20:55:14.83 - &lt;debug&gt; Cleaning up plugins\n2025.07.19-20:55:14.83 - &lt;debug&gt; Unregistered plugin tf\n</code></pre>"},{"location":"plugins/available-plugins/acceleration-plugins/tf-plugin/#using-the-vaccel-tensorflow-bindings","title":"Using the vAccel Tensorflow bindings","text":"<p>This plugin includes bindings that implement simple inference operations. The bindings can be used to run native Tensorflow application with vAccel. You can find more information in the relevant page.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/torch-plugin/","title":"Torch Plugin","text":"<p>The Torch plugin for vAccel implements basic PyTorch C++ API (LibTorch) support for vAccel operations.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/torch-plugin/#supported-operations","title":"Supported operations","text":"<ul> <li>Image classification</li> <li>Torch model load</li> <li>Torch model run</li> <li>Torch matrix-to-matrix multiplication</li> </ul>"},{"location":"plugins/available-plugins/acceleration-plugins/torch-plugin/#installing-pytorch-cc-api-files-libtorch","title":"Installing PyTorch C/C++ API files (LibTorch)","text":"<p>You can find instructions on how to install the required files on the Build and Install PyTorch page. The rest of this guide assumes PyTorch is installed at <code>/opt/pytorch</code> and its' libraries are at <code>/opt/pytorch/lib</code>.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/torch-plugin/#installing-the-plugin","title":"Installing the plugin","text":"<p>You can get the latest Torch plugin binary release from the Releases page of the vAccel repository. Releases include binaries for x86_64/aarch64 Ubuntu-based systems.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/torch-plugin/#requirements","title":"Requirements","text":"<p>The prebuilt Torch plugin binaries depend on libstb. You can install it with:</p> <pre><code>sudo apt install libstb0\n</code></pre>"},{"location":"plugins/available-plugins/acceleration-plugins/torch-plugin/#tar","title":"TAR","text":"<p>To install the TAR binary package of the latest Torch plugin release:</p> x86ARM (64-bit) <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-torch_0.2.0_amd64.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel-torch_0.2.0_amd64.tar.gz --strip-components=2 -C /usr/local\n# Update pkg-config files with the correct prefix\nfind /usr/local -name \"vaccel-torch.pc\" -exec sed -i 's:^\\(prefix=\\).*:\\1/usr/local:g' {} \\;\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-torch_0.2.0_arm64.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel-torch_0.2.0_arm64.tar.gz --strip-components=2 -C /usr/local\n# Update pkg-config files with the correct prefix\nfind /usr/local -name \"vaccel-torch.pc\" -exec sed -i 's:^\\(prefix=\\).*:\\1/usr/local:g' {} \\;\n</code></pre>"},{"location":"plugins/available-plugins/acceleration-plugins/torch-plugin/#latest-artifacts","title":"Latest artifacts","text":"<p>You can also find prebuilt artifacts of the latest Torch plugin revision at:</p> x86ARM (64-bit) <pre><code># TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/torch/rev/main/x86_64/release/vaccel-torch-latest-bin.tar.gz\n</code></pre> <pre><code># TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/torch/rev/main/aarch64/release/vaccel-torch-latest-bin.tar.gz\n</code></pre>"},{"location":"plugins/available-plugins/acceleration-plugins/torch-plugin/#usage","title":"Usage","text":"<p>To specify Torch plugin as the selected plugin for vAccel execution:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-torch.so\n</code></pre> <p>Ensure LibTorch, vAccel and the Torch plugin libraries are in the library search paths before trying to use the plugin.</p> <p>To run image classification you will also need to specify a file with labels using <code>VACCEL_TORCH_LABELS</code>. vAccel includes an file imagenet labels file. Assuming vAccel is installed at <code>/usr/local</code>, you can specify the file with:</p> <pre><code>export VACCEL_TORCH_LABELS=/usr/local/share/vaccel/labels/imagenet.txt\n</code></pre> <p>If vAccel is installed using the DEB package (at <code>/usr</code>) you can omit the variable.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/torch-plugin/#running-an-example","title":"Running an example","text":"<p>Export the necessary variables:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-torch.so\nexport VACCEL_TORCH_LABELS=/usr/local/share/vaccel/labels/imagenet.txt\n# Optionally, for verbose output\nexport VACCEL_LOG_LEVEL=4\n</code></pre> <p>Assuming vAccel is installed at <code>/usr/local</code>, you can run an image classification with a ResNet model from <code>https://s3.nbfc.io/torch/resnet18.pt</code> with:</p> <pre><code>$ classify /usr/local/share/vaccel/images/example.jpg 1 \\\n      https://s3.nbfc.io/torch/resnet18.pt\n2025.04.11-15:46:20.07 - &lt;debug&gt; Initializing vAccel\n2025.04.11-15:46:20.07 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.11-15:46:20.07 - &lt;debug&gt; Config:\n2025.04.11-15:46:20.07 - &lt;debug&gt;   plugins = libvaccel-torch.so\n2025.04.11-15:46:20.07 - &lt;debug&gt;   log_level = debug\n2025.04.11-15:46:20.07 - &lt;debug&gt;   log_file = (null)\n2025.04.11-15:46:20.07 - &lt;debug&gt;   profiling_enabled = false\n2025.04.11-15:46:20.07 - &lt;debug&gt;   version_ignore = false\n2025.04.11-15:46:20.07 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/w8BHSP\n2025.04.11-15:46:20.53 - &lt;info&gt; Registered plugin torch 0.1.0-25-ab85fa03\n2025.04.11-15:46:20.53 - &lt;debug&gt; Registered op torch_jitload_forward from plugin torch\n2025.04.11-15:46:20.53 - &lt;debug&gt; Registered op torch_sgemm from plugin torch\n2025.04.11-15:46:20.53 - &lt;debug&gt; Registered op image_classify from plugin torch\n2025.04.11-15:46:20.53 - &lt;debug&gt; Loaded plugin torch from libvaccel-torch.so\n2025.04.11-15:46:20.53 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/w8BHSP/session.1\n2025.04.11-15:46:20.53 - &lt;debug&gt; Initialized session 1\nInitialized session with id: 1\n2025.04.11-15:46:20.53 - &lt;debug&gt; Initialized resource 1\n2025.04.11-15:46:20.53 - &lt;debug&gt; New rundir for resource 1: /run/user/1002/vaccel/w8BHSP/resource.1\n2025.04.11-15:46:20.53 - &lt;debug&gt; Downloading https://s3.nbfc.io/torch/resnet18.pt\n...\n2025.04.11-15:48:41.53 - &lt;debug&gt; Download completed successfully\n2025.04.11-15:48:41.53 - &lt;debug&gt; session:1 Registered resource 1\n2025.04.11-15:48:41.53 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.11-15:48:41.53 - &lt;debug&gt; Returning func from hint plugin torch\n2025.04.11-15:48:41.53 - &lt;debug&gt; Found implementation in torch plugin\n2025.04.11-15:48:41.73 - &lt;debug&gt; [torch] Model loaded successfully from: /run/user/1002/vaccel/w8BHSP/resource.1/resnet18.pt\n2025.04.11-15:48:41.89 - &lt;debug&gt; [torch] Prediction: banana\nclassification tags: banana\nclassification imagename: PLACEHOLDER\n2025.04.11-15:48:41.91 - &lt;debug&gt; session:1 Unregistered resource 1\n2025.04.11-15:48:41.91 - &lt;debug&gt; Removing file /run/user/1002/vaccel/w8BHSP/resource.1/resnet18.pt\n2025.04.11-15:48:41.92 - &lt;debug&gt; Released resource 1\n2025.04.11-15:48:41.92 - &lt;debug&gt; Released session 1\n2025.04.11-15:48:42.06 - &lt;debug&gt; Cleaning up vAccel\n2025.04.11-15:48:42.06 - &lt;debug&gt; Cleaning up sessions\n2025.04.11-15:48:42.06 - &lt;debug&gt; Cleaning up resources\n2025.04.11-15:48:42.06 - &lt;debug&gt; Cleaning up plugins\n2025.04.11-15:48:42.06 - &lt;debug&gt; Unregistered plugin torch\n</code></pre> <p>To run a torch inference example with the generic <code>jitload_forward</code> operation:</p> <pre><code>$ torch_inference /usr/local/share/vaccel/images/example.jpg \\\n      https://s3.nbfc.io/torch/resnet18.pt \\\n      \"${VACCEL_TORCH_LABELS}\"\n2025.04.11-15:59:42.95 - &lt;debug&gt; Initializing vAccel\n2025.04.11-15:59:42.95 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.11-15:59:42.95 - &lt;debug&gt; Config:\n2025.04.11-15:59:42.95 - &lt;debug&gt;   plugins = libvaccel-torch.so\n2025.04.11-15:59:42.95 - &lt;debug&gt;   log_level = debug\n2025.04.11-15:59:42.95 - &lt;debug&gt;   log_file = (null)\n2025.04.11-15:59:42.95 - &lt;debug&gt;   profiling_enabled = false\n2025.04.11-15:59:42.95 - &lt;debug&gt;   version_ignore = false\n2025.04.11-15:59:42.95 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/fEe2aO\n2025.04.11-15:59:43.41 - &lt;info&gt; Registered plugin torch 0.1.0-25-ab85fa03\n2025.04.11-15:59:43.41 - &lt;debug&gt; Registered op torch_jitload_forward from plugin torch\n2025.04.11-15:59:43.41 - &lt;debug&gt; Registered op torch_sgemm from plugin torch\n2025.04.11-15:59:43.41 - &lt;debug&gt; Registered op image_classify from plugin torch\n2025.04.11-15:59:43.41 - &lt;debug&gt; Loaded plugin torch from libvaccel-torch.so\n2025.04.11-15:59:43.41 - &lt;debug&gt; Initialized resource 1\nInitialized model resource 1\n2025.04.11-15:59:43.41 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/fEe2aO/session.1\n2025.04.11-15:59:43.41 - &lt;debug&gt; Initialized session 1\nInitialized vAccel session 1\n2025.04.11-15:59:43.41 - &lt;debug&gt; New rundir for resource 1: /run/user/1002/vaccel/fEe2aO/resource.1\n2025.04.11-15:59:43.41 - &lt;debug&gt; Downloading https://s3.nbfc.io/torch/resnet18.pt\n...\n2025.04.11-16:05:21.23 - &lt;debug&gt; Download completed successfully\n2025.04.11-16:05:21.23 - &lt;debug&gt; session:1 Registered resource 1\n2025.04.11-16:05:21.27 - &lt;debug&gt; session:1 Looking for plugin implementing torch_jitload_forward operation\n2025.04.11-16:05:21.27 - &lt;debug&gt; Returning func from hint plugin torch\n2025.04.11-16:05:21.27 - &lt;debug&gt; Found implementation in torch plugin\n2025.04.11-16:05:21.27 - &lt;debug&gt; [torch] session:1 Jitload &amp; Forward Process\n2025.04.11-16:05:21.27 - &lt;debug&gt; [torch] Model: /run/user/1002/vaccel/1nB5aC/resource.1/resnet18.pt\n2025.04.11-16:05:21.27 - &lt;debug&gt; [torch] CUDA not available, running in CPU mode\nSuccess!\nResult Tensor :\nOutput tensor =&gt; type:7 nr_dims:2\nsize: 4000 B\nPrediction: banana\n2025.04.11-16:05:21.50 - &lt;debug&gt; session:1 Unregistered resource 1\n2025.04.11-16:05:21.50 - &lt;debug&gt; Released session 1\n2025.04.11-16:05:21.50 - &lt;debug&gt; Removing file /run/user/1002/vaccel/1nB5aC/resource.1/resnet18.pt\n2025.04.11-16:05:21.51 - &lt;debug&gt; Released resource 1\n2025.04.11-16:05:21.61 - &lt;debug&gt; Cleaning up vAccel\n2025.04.11-16:05:21.61 - &lt;debug&gt; Cleaning up sessions\n2025.04.11-16:05:21.61 - &lt;debug&gt; Cleaning up resources\n2025.04.11-16:05:21.61 - &lt;debug&gt; Cleaning up plugins\n2025.04.11-16:05:21.61 - &lt;debug&gt; Unregistered plugin torch\n</code></pre>"},{"location":"plugins/available-plugins/acceleration-plugins/tvm-plugin/","title":"TVM Plugin","text":"<p>The TVM plugin for vAccel implements image inference vAccel operations with TVM.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/tvm-plugin/#supported-operations","title":"Supported operations","text":"<ul> <li>Image classification</li> </ul>"},{"location":"plugins/available-plugins/acceleration-plugins/tvm-plugin/#installing-tvm-cc-api-files","title":"Installing TVM C/C++ API files","text":"<p>You can find instructions on how to install the required files on the Build and Install TVM page. The rest of this guide assumes TVM is installed at <code>/opt/tvm</code> and its' libraries are at <code>/opt/tvm/build</code>.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/tvm-plugin/#installing-the-plugin","title":"Installing the plugin","text":"<p>You can get the latest TVM plugin binary release from the Releases page of the vAccel repository. Releases include binaries for x86_64/aarch64 Ubuntu-based systems.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/tvm-plugin/#tar","title":"TAR","text":"<p>To install the TAR binary package of the latest TVM plugin release:</p> x86ARM (64-bit) <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-tvm_0.1.0_amd64.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel-tvm_0.1.0_amd64.tar.gz --strip-components=2 -C /usr/local\n# Update pkg-config files with the correct prefix\nfind /usr/local -name \"vaccel-tvm.pc\" -exec sed -i 's:^\\(prefix=\\).*:\\1/usr/local:g' {} \\;\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-tvm_0.1.0_arm64.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel-tvm_0.1.0_arm64.tar.gz --strip-components=2 -C /usr/local\n# Update pkg-config files with the correct prefix\nfind /usr/local -name \"vaccel-tvm.pc\" -exec sed -i 's:^\\(prefix=\\).*:\\1/usr/local:g' {} \\;\n</code></pre>"},{"location":"plugins/available-plugins/acceleration-plugins/tvm-plugin/#latest-artifacts","title":"Latest artifacts","text":"<p>You can also find prebuilt artifacts of the latest TVM plugin revision at:</p> x86ARM (64-bit) <pre><code># TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/tvm/rev/main/x86_64/release/vaccel-tvm-latest-bin.tar.gz\n</code></pre> <pre><code># TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/tvm/rev/main/aarch64/release/vaccel-tvm-latest-bin.tar.gz\n</code></pre>"},{"location":"plugins/available-plugins/acceleration-plugins/tvm-plugin/#usage","title":"Usage","text":"<p>To specify TVM plugin as the selected plugin for vAccel execution:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-tvm.so\n</code></pre> <p>Ensure TVM, vAccel and the TVM plugin libraries are in the library search paths before trying to use the plugin.</p>"},{"location":"plugins/available-plugins/acceleration-plugins/tvm-plugin/#running-an-example","title":"Running an example","text":"<p>Export the necessary variables:</p> <pre><code>export LD_LIBRARY_PATH=/opt/tvm/build\nexport VACCEL_PLUGINS=libvaccel-tvm.so\n# Optionally, for verbose output\nexport VACCEL_LOG_LEVEL=4\n</code></pre> <p>Assuming vAccel is installed at <code>/usr/local</code>, you can run an image classification with a ResNet model from <code>https://s3.nbfc.io/models/tvm/x86_64/resnet18-v2-7.so</code> with:</p> x86ARM (64-bit) <pre><code>$ classify /usr/local/share/vaccel/images/example.jpg 1 \\\n      https://s3.nbfc.io/models/tvm/x86_64/resnet18-v2-7.so\n2025.03.25-19:37:03.39 - &lt;debug&gt; Initializing vAccel\n2025.03.25-19:37:03.39 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.03.25-19:37:03.39 - &lt;debug&gt; Config:\n2025.03.25-19:37:03.39 - &lt;debug&gt;   plugins = libvaccel-tvm.so\n2025.03.25-19:37:03.39 - &lt;debug&gt;   log_level = debug\n2025.03.25-19:37:03.39 - &lt;debug&gt;   log_file = (null)\n2025.03.25-19:37:03.39 - &lt;debug&gt;   profiling_enabled = false\n2025.03.25-19:37:03.39 - &lt;debug&gt;   version_ignore = false\n2025.03.25-19:37:03.39 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/7CYHmR\n2025.03.25-19:37:03.40 - &lt;info&gt; Registered plugin tvm 0.0.0-19-d720e616\n2025.03.25-19:37:03.40 - &lt;debug&gt; Registered op image_classify from plugin tvm\n2025.03.25-19:37:03.40 - &lt;debug&gt; Loaded plugin tvm from libvaccel-tvm.so\n2025.03.25-19:37:03.40 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/7CYHmR/session.1\n2025.03.25-19:37:03.40 - &lt;debug&gt; Initialized session 1\nInitialized session with id: 1\n2025.03.25-19:37:03.40 - &lt;debug&gt; Initialized resource 1\n2025.03.25-19:37:03.40 - &lt;debug&gt; New rundir for resource 1: /run/user/1002/vaccel/7CYHmR/resource.1\n2025.03.25-19:37:03.40 - &lt;debug&gt; Downloading https://s3.nbfc.io/models/tvm/x86_64/resnet18-v2-7.so\n2025.03.25-19:37:08.40 - &lt;debug&gt; Downloaded: 9.0 MB of 45.8 MB (19.7%) | Speed: 1.80 MB/sec\n2025.03.25-19:37:13.40 - &lt;debug&gt; Downloaded: 20.2 MB of 45.8 MB (44.1%) | Speed: 2.02 MB/sec\n2025.03.25-19:37:18.40 - &lt;debug&gt; Downloaded: 31.1 MB of 45.8 MB (67.9%) | Speed: 2.07 MB/sec\n2025.03.25-19:37:23.40 - &lt;debug&gt; Downloaded: 40.2 MB of 45.8 MB (87.8%) | Speed: 2.01 MB/sec\n2025.03.25-19:37:26.28 - &lt;debug&gt; Downloaded: 45.8 MB of 45.8 MB (100.0%) | Speed: 2.00 MB/sec\n2025.03.25-19:37:26.28 - &lt;debug&gt; Download completed successfully\n2025.03.25-19:37:26.28 - &lt;debug&gt; session:1 Registered resource 1\n2025.03.25-19:37:26.28 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.03.25-19:37:26.28 - &lt;debug&gt; Returning func from hint plugin tvm\n2025.03.25-19:37:26.28 - &lt;debug&gt; Found implementation in tvm plugin\n2025.03.25-19:37:26.28 - &lt;debug&gt; [tvm] Resource path: /run/user/1002/vaccel/7CYHmR/resource.1/resnet18-v2-7.so\nloading file: /run/user/1002/vaccel/7CYHmR/resource.1/resnet18-v2-7.so\n2025.03.25-19:37:26.43 - &lt;debug&gt; [tvm] Prediction: banana\nclassification tags: banana\nclassification imagename: PLACEHOLDER\n2025.03.25-19:37:26.43 - &lt;debug&gt; session:1 Unregistered resource 1\n2025.03.25-19:37:26.43 - &lt;debug&gt; Removing file /run/user/1002/vaccel/7CYHmR/resource.1/resnet18-v2-7.so\n2025.03.25-19:37:26.44 - &lt;debug&gt; Released resource 1\n2025.03.25-19:37:26.44 - &lt;debug&gt; Released session 1\n2025.03.25-19:37:26.65 - &lt;debug&gt; Cleaning up vAccel\n2025.03.25-19:37:26.65 - &lt;debug&gt; Cleaning up sessions\n2025.03.25-19:37:26.65 - &lt;debug&gt; Cleaning up resources\n2025.03.25-19:37:26.65 - &lt;debug&gt; Cleaning up plugins\n2025.03.25-19:37:26.65 - &lt;debug&gt; Unregistered plugin tvm\n</code></pre> <pre><code>$ classify /usr/local/share/vaccel/images/example.jpg 1 \\\n      https://s3.nbfc.io/models/tvm/aarch64/resnet18-v2-7.so\n2025.03.25-19:37:03.39 - &lt;debug&gt; Initializing vAccel\n2025.03.25-19:37:03.39 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.03.25-19:37:03.39 - &lt;debug&gt; Config:\n2025.03.25-19:37:03.39 - &lt;debug&gt;   plugins = libvaccel-tvm.so\n2025.03.25-19:37:03.39 - &lt;debug&gt;   log_level = debug\n2025.03.25-19:37:03.39 - &lt;debug&gt;   log_file = (null)\n2025.03.25-19:37:03.39 - &lt;debug&gt;   profiling_enabled = false\n2025.03.25-19:37:03.39 - &lt;debug&gt;   version_ignore = false\n2025.03.25-19:37:03.39 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/7CYHmR\n2025.03.25-19:37:03.40 - &lt;info&gt; Registered plugin tvm 0.0.0-19-d720e616\n2025.03.25-19:37:03.40 - &lt;debug&gt; Registered op image_classify from plugin tvm\n2025.03.25-19:37:03.40 - &lt;debug&gt; Loaded plugin tvm from libvaccel-tvm.so\n2025.03.25-19:37:03.40 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/7CYHmR/session.1\n2025.03.25-19:37:03.40 - &lt;debug&gt; Initialized session 1\nInitialized session with id: 1\n2025.03.25-19:37:03.40 - &lt;debug&gt; Initialized resource 1\n2025.03.25-19:37:03.40 - &lt;debug&gt; New rundir for resource 1: /run/user/1002/vaccel/7CYHmR/resource.1\n2025.03.25-19:37:03.40 - &lt;debug&gt; Downloading https://s3.nbfc.io/models/tvm/x86_64/resnet18-v2-7.so\n2025.03.25-19:37:08.40 - &lt;debug&gt; Downloaded: 9.0 MB of 45.8 MB (19.7%) | Speed: 1.80 MB/sec\n2025.03.25-19:37:13.40 - &lt;debug&gt; Downloaded: 20.2 MB of 45.8 MB (44.1%) | Speed: 2.02 MB/sec\n2025.03.25-19:37:18.40 - &lt;debug&gt; Downloaded: 31.1 MB of 45.8 MB (67.9%) | Speed: 2.07 MB/sec\n2025.03.25-19:37:23.40 - &lt;debug&gt; Downloaded: 40.2 MB of 45.8 MB (87.8%) | Speed: 2.01 MB/sec\n2025.03.25-19:37:26.28 - &lt;debug&gt; Downloaded: 45.8 MB of 45.8 MB (100.0%) | Speed: 2.00 MB/sec\n2025.03.25-19:37:26.28 - &lt;debug&gt; Download completed successfully\n2025.03.25-19:37:26.28 - &lt;debug&gt; session:1 Registered resource 1\n2025.03.25-19:37:26.28 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.03.25-19:37:26.28 - &lt;debug&gt; Returning func from hint plugin tvm\n2025.03.25-19:37:26.28 - &lt;debug&gt; Found implementation in tvm plugin\n2025.03.25-19:37:26.28 - &lt;debug&gt; [tvm] Resource path: /run/user/1002/vaccel/7CYHmR/resource.1/resnet18-v2-7.so\nloading file: /run/user/1002/vaccel/7CYHmR/resource.1/resnet18-v2-7.so\n2025.03.25-19:37:26.43 - &lt;debug&gt; [tvm] Prediction: banana\nclassification tags: banana\nclassification imagename: PLACEHOLDER\n2025.03.25-19:37:26.43 - &lt;debug&gt; session:1 Unregistered resource 1\n2025.03.25-19:37:26.43 - &lt;debug&gt; Removing file /run/user/1002/vaccel/7CYHmR/resource.1/resnet18-v2-7.so\n2025.03.25-19:37:26.44 - &lt;debug&gt; Released resource 1\n2025.03.25-19:37:26.44 - &lt;debug&gt; Released session 1\n2025.03.25-19:37:26.65 - &lt;debug&gt; Cleaning up vAccel\n2025.03.25-19:37:26.65 - &lt;debug&gt; Cleaning up sessions\n2025.03.25-19:37:26.65 - &lt;debug&gt; Cleaning up resources\n2025.03.25-19:37:26.65 - &lt;debug&gt; Cleaning up plugins\n2025.03.25-19:37:26.65 - &lt;debug&gt; Unregistered plugin tvm\n</code></pre>"},{"location":"plugins/available-plugins/bundled-plugins/","title":"Bundled plugins","text":"<p>Bundled plugins come with the core vAccel installation and aim to facilitate development of vAccel applications:</p> <ul> <li>NoOp plugin</li> <li>Exec plugin</li> <li>MBench plugin</li> </ul>"},{"location":"plugins/available-plugins/bundled-plugins/exec-plugin/","title":"Exec Plugin","text":"<p>The Exec plugin for vAccel implements a backend to call functions from external libraries using vAccel operations.</p> <p>Warning</p> <p>This plugin enables users to call functions from arbitrary libraries. Use it only on environments where the users are trusted.</p>"},{"location":"plugins/available-plugins/bundled-plugins/exec-plugin/#supported-operations","title":"Supported operations","text":"<ul> <li>Exec</li> <li>Exec with resource</li> <li>Debug operation</li> </ul>"},{"location":"plugins/available-plugins/bundled-plugins/exec-plugin/#installing-the-plugin","title":"Installing the plugin","text":"<p>The plugin comes bundled with the core vAccel installation. Find out more on how to install vAccel at the Installation page.</p>"},{"location":"plugins/available-plugins/bundled-plugins/exec-plugin/#usage","title":"Usage","text":"<p>To specify Exec plugin as the selected plugin for vAccel execution:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-exec.so\n</code></pre> <p>Ensure vAccel and the Exec plugin libraries are in the library search paths before trying to use the plugin.</p>"},{"location":"plugins/available-plugins/bundled-plugins/exec-plugin/#running-an-example","title":"Running an example","text":"<p>Export the necessary variables for the plugin:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-exec.so\n# Optionally, for verbose output\nexport VACCEL_LOG_LEVEL=4\n</code></pre> <p>Assuming <code>pkg-config</code> is available, you can call <code>mytestfunc</code> from the provided <code>libmytestlib.so</code> with:</p> <pre><code>$ exec_with_res \"$(pkg-config --variable=libdir vaccel)/libmytestlib.so\"\n2025.04.15-19:37:37.77 - &lt;debug&gt; Initializing vAccel\n2025.04.15-19:37:37.77 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.15-19:37:37.77 - &lt;debug&gt; Config:\n2025.04.15-19:37:37.77 - &lt;debug&gt;   plugins = libvaccel-exec.so\n2025.04.15-19:37:37.77 - &lt;debug&gt;   log_level = debug\n2025.04.15-19:37:37.77 - &lt;debug&gt;   log_file = (null)\n2025.04.15-19:37:37.77 - &lt;debug&gt;   profiling_enabled = false\n2025.04.15-19:37:37.77 - &lt;debug&gt;   version_ignore = false\n2025.04.15-19:37:37.77 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/DYBt4h\n2025.04.15-19:37:37.77 - &lt;info&gt; Registered plugin exec 0.6.1-194-19056528\n2025.04.15-19:37:37.77 - &lt;debug&gt; Registered op noop from plugin exec\n2025.04.15-19:37:37.77 - &lt;debug&gt; Registered op exec from plugin exec\n2025.04.15-19:37:37.77 - &lt;debug&gt; Registered op exec_with_resource from plugin exec\n2025.04.15-19:37:37.77 - &lt;debug&gt; Loaded plugin exec from libvaccel-exec.so\n2025.04.15-19:37:37.77 - &lt;warn&gt; Path does not seem to have a `&lt;prefix&gt;://`\n2025.04.15-19:37:37.77 - &lt;warn&gt; Assuming /usr/local/lib/x86_64-linux-gnu/libmytestlib.so is a local path\n2025.04.15-19:37:37.77 - &lt;debug&gt; Initialized resource 1\n2025.04.15-19:37:37.77 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/DYBt4h/session.1\n2025.04.15-19:37:37.77 - &lt;debug&gt; Initialized session 1\nInitialized session with id: 1\n2025.04.15-19:37:37.77 - &lt;debug&gt; New rundir for resource 1: /run/user/1002/vaccel/DYBt4h/resource.1\n2025.04.15-19:37:37.77 - &lt;debug&gt; session:1 Registered resource 1\n2025.04.15-19:37:37.77 - &lt;debug&gt; New rundir for resource 2: /run/user/1002/vaccel/DYBt4h/resource.2\n2025.04.15-19:37:37.77 - &lt;debug&gt; Persisting file lib.so to /run/user/1002/vaccel/DYBt4h/resource.2/lib.so\n2025.04.15-19:37:37.77 - &lt;debug&gt; Initialized resource 2\n2025.04.15-19:37:37.77 - &lt;debug&gt; session:1 Registered resource 2\n2025.04.15-19:37:37.77 - &lt;debug&gt; session:1 Looking for plugin implementing exec with resource\n2025.04.15-19:37:37.77 - &lt;debug&gt; Returning func from hint plugin exec\n2025.04.15-19:37:37.77 - &lt;debug&gt; Found implementation in exec plugin\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] session:1 Calling exec_with_resource\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] Number of libraries: 1\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] Library: /usr/local/lib/x86_64-linux-gnu/libmytestlib.so\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] Symbol: mytestfunc\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] read[0].size: 4\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] read[0].argtype: 42\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] write[0].size: 4\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] write[0].argtype: 42\nI got nr_in: 1, nr_out: 1\nI got input: 10\nWill return output: 20\noutput1: 20\n2025.04.15-19:37:37.77 - &lt;debug&gt; session:1 Looking for plugin implementing exec with resource\n2025.04.15-19:37:37.77 - &lt;debug&gt; Returning func from hint plugin exec\n2025.04.15-19:37:37.77 - &lt;debug&gt; Found implementation in exec plugin\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] session:1 Calling exec_with_resource\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] Number of libraries: 1\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] Library: /run/user/1002/vaccel/DYBt4h/resource.2/lib.so\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] Symbol: mytestfunc\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] read[0].size: 4\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] read[0].argtype: 0\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] write[0].size: 4\n2025.04.15-19:37:37.77 - &lt;debug&gt; [exec_with_resource] write[0].argtype: 0\nI got nr_in: 1, nr_out: 1\nI got input: 10\nWill return output: 20\noutput2: 20\n2025.04.15-19:37:37.77 - &lt;debug&gt; session:1 Unregistered resource 2\n2025.04.15-19:37:37.77 - &lt;debug&gt; Removing file /run/user/1002/vaccel/DYBt4h/resource.2/lib.so\n2025.04.15-19:37:37.77 - &lt;debug&gt; Released resource 2\n2025.04.15-19:37:37.77 - &lt;debug&gt; session:1 Unregistered resource 1\n2025.04.15-19:37:37.77 - &lt;debug&gt; Released session 1\n2025.04.15-19:37:37.77 - &lt;debug&gt; Released resource 1\n2025.04.15-19:37:37.77 - &lt;debug&gt; Cleaning up vAccel\n2025.04.15-19:37:37.77 - &lt;debug&gt; Cleaning up sessions\n2025.04.15-19:37:37.77 - &lt;debug&gt; Cleaning up resources\n2025.04.15-19:37:37.77 - &lt;debug&gt; Cleaning up plugins\n2025.04.15-19:37:37.77 - &lt;debug&gt; Unregistered plugin exec\n</code></pre>"},{"location":"plugins/available-plugins/bundled-plugins/mbench-plugin/","title":"MBench Plugin","text":"<p>The MBench plugin for vAccel is microbenchmark plugin to measure operation overhead by simulating compute intensive workloads.</p>"},{"location":"plugins/available-plugins/bundled-plugins/mbench-plugin/#supported-operations","title":"Supported operations","text":"<ul> <li>Exec</li> </ul>"},{"location":"plugins/available-plugins/bundled-plugins/mbench-plugin/#installing-the-plugin","title":"Installing the plugin","text":"<p>The plugin comes bundled with the core vAccel installation. Find out more on how to install vAccel at the Installation page.</p>"},{"location":"plugins/available-plugins/bundled-plugins/mbench-plugin/#usage","title":"Usage","text":"<p>To specify MBench plugin as the selected plugin for vAccel execution:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-mbench.so\n</code></pre> <p>Ensure vAccel and the MBench plugin libraries are in the library search paths before trying to use the plugin.</p> <p>To get actual meauserement, you will probably also want to enable profiling:</p> <pre><code>export VACCEL_PROFILING_ENABLED=1\n</code></pre>"},{"location":"plugins/available-plugins/bundled-plugins/mbench-plugin/#running-an-example","title":"Running an example","text":"<p>Export the necessary variables for the plugin:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-mbench.so\nexport VACCEL_PROFILING_ENABLED=1\n# Optionally, for verbose output\nexport VACCEL_LOG_LEVEL=4\n</code></pre> <p>Assuming vAccel is installed at <code>/usr/local</code>, you can run an example to simulate 10ms of CPU usage for <code>example.jpg</code> with:</p> <pre><code>$ mbench 10 /usr/local/share/vaccel/images/example.jpg\n2025.04.15-19:55:11.29 - &lt;debug&gt; Initializing vAccel\n2025.04.15-19:55:11.29 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.15-19:55:11.29 - &lt;debug&gt; Config:\n2025.04.15-19:55:11.29 - &lt;debug&gt;   plugins = libvaccel-mbench.so\n2025.04.15-19:55:11.29 - &lt;debug&gt;   log_level = debug\n2025.04.15-19:55:11.29 - &lt;debug&gt;   log_file = (null)\n2025.04.15-19:55:11.29 - &lt;debug&gt;   profiling_enabled = true\n2025.04.15-19:55:11.29 - &lt;debug&gt;   version_ignore = false\n2025.04.15-19:55:11.29 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/19PFGM\n2025.04.15-19:55:11.29 - &lt;info&gt; Registered plugin mbench 0.6.1-194-19056528\n2025.04.15-19:55:11.29 - &lt;debug&gt; Registered op exec from plugin mbench\n2025.04.15-19:55:11.29 - &lt;debug&gt; Loaded plugin mbench from libvaccel-mbench.so\n2025.04.15-19:55:11.29 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/19PFGM/session.1\n2025.04.15-19:55:11.29 - &lt;debug&gt; Initialized session 1\nInitialized session with id: 1\n2025.04.15-19:55:11.29 - &lt;debug&gt; Start profiling region mbench\n2025.04.15-19:55:11.29 - &lt;debug&gt; session:1 Looking for plugin implementing exec\n2025.04.15-19:55:11.29 - &lt;debug&gt; Start profiling region vaccel_exec_op\n2025.04.15-19:55:11.29 - &lt;debug&gt; Returning func from hint plugin mbench\n2025.04.15-19:55:11.29 - &lt;debug&gt; Found implementation in mbench plugin\n2025.04.15-19:55:11.29 - &lt;debug&gt; Calling mbench for session 1\n2025.04.15-19:55:11.29 - &lt;debug&gt; Start profiling region vaccel_mbench_plugin\n2025.04.15-19:55:11.30 - &lt;debug&gt; [mbench] 10 ms elapsed\n2025.04.15-19:55:11.30 - &lt;debug&gt; Stop profiling region vaccel_mbench_plugin\n2025.04.15-19:55:11.30 - &lt;debug&gt; Stop profiling region vaccel_exec_op\n2025.04.15-19:55:11.30 - &lt;debug&gt; Stop profiling region mbench\n2025.04.15-19:55:11.30 - &lt;debug&gt; Released session 1\n2025.04.15-19:55:11.30 - &lt;info&gt; [prof] mbench: total_time: 10060333 nsec nr_entries: 1\n2025.04.15-19:55:11.30 - &lt;info&gt; [prof] vaccel_exec_op: total_time: 10040877 nsec nr_entries: 1\n2025.04.15-19:55:11.30 - &lt;debug&gt; Cleaning up vAccel\n2025.04.15-19:55:11.30 - &lt;debug&gt; Cleaning up sessions\n2025.04.15-19:55:11.30 - &lt;debug&gt; Cleaning up resources\n2025.04.15-19:55:11.30 - &lt;debug&gt; Cleaning up plugins\n2025.04.15-19:55:11.30 - &lt;info&gt; [prof] vaccel_mbench_plugin: total_time: 10010329 nsec nr_entries: 1\n2025.04.15-19:55:11.30 - &lt;debug&gt; Unregistered plugin mbench\n</code></pre>"},{"location":"plugins/available-plugins/bundled-plugins/noop-plugin/","title":"NoOp Plugin","text":"<p>The NoOp plugin for vAccel provides dummy implementations for vAccel operations. It is meant a way to verify vAccel setups and operation usage.</p>"},{"location":"plugins/available-plugins/bundled-plugins/noop-plugin/#supported-operations","title":"Supported operations","text":"<ul> <li>Image classification</li> <li>Image segmentation</li> <li>Object detection</li> <li>Pose estimation</li> <li> <p>Monocular depth</p> </li> <li> <p>Matrix-to-matrix multiplication</p> </li> <li>Array copy</li> <li>Matrix-to-matrix multiplication simple</li> <li>Matrix-to-matrix multiplication and addition simple</li> <li> <p>Vector add</p> </li> <li> <p>Exec</p> </li> <li> <p>Exec with resource</p> </li> <li> <p>TensorFlow model load</p> </li> <li>TensorFlow model unload</li> <li>TensorFlow model run</li> <li>TensorFlow Lite model load</li> <li>TensorFlow Lite model unload</li> <li> <p>TensorFlow Lite model run</p> </li> <li> <p>Torch model load</p> </li> <li>Torch model run</li> <li> <p>Torch matrix-to-matrix multiplication</p> </li> <li> <p>MinMax</p> </li> <li>Generic operation</li> <li>Debug operation</li> </ul>"},{"location":"plugins/available-plugins/bundled-plugins/noop-plugin/#installing-the-plugin","title":"Installing the plugin","text":"<p>The plugin comes bundled with the core vAccel installation. Find out more on how to install vAccel at the Installation page.</p>"},{"location":"plugins/available-plugins/bundled-plugins/noop-plugin/#usage","title":"Usage","text":"<p>To specify NoOp plugin as the selected plugin for vAccel execution:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-noop.so\n</code></pre> <p>Ensure vAccel and the NoOp plugin libraries are in the library search paths before trying to use the plugin.</p>"},{"location":"plugins/available-plugins/bundled-plugins/noop-plugin/#running-an-example","title":"Running an example","text":"<p>Export the necessary variables for the plugin:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-noop.so\n# Optionally, for verbose output\nexport VACCEL_LOG_LEVEL=4\n</code></pre> <p>Assuming vAccel is installed at <code>/usr/local</code>, you can run a dummy image classification with:</p> <pre><code>$ classify /usr/local/share/vaccel/images/example.jpg\n2025.04.03-15:44:04.61 - &lt;debug&gt; Initializing vAccel\n2025.04.03-15:44:04.61 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.03-15:44:04.61 - &lt;debug&gt; Config:\n2025.04.03-15:44:04.61 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.03-15:44:04.61 - &lt;debug&gt;   log_level = debug\n2025.04.03-15:44:04.61 - &lt;debug&gt;   log_file = (null)\n2025.04.03-15:44:04.61 - &lt;debug&gt;   profiling_enabled = false\n2025.04.03-15:44:04.61 - &lt;debug&gt;   version_ignore = false\n2025.04.03-15:44:04.61 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/VC0Gxz\n2025.04.03-15:44:04.61 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op noop from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op blas_sgemm from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op image_classify from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op image_detect from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op image_segment from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op image_pose from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op image_depth from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op exec from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op tf_session_load from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op tf_session_run from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op tf_session_delete from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op minmax from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op fpga_arraycopy from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op fpga_vectoradd from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op fpga_parallel from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op fpga_mmult from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op exec_with_resource from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op torch_jitload_forward from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op torch_sgemm from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op opencv from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op tflite_session_load from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op tflite_session_run from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Registered op tflite_session_delete from plugin noop\n2025.04.03-15:44:04.61 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n2025.04.03-15:44:04.62 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/VC0Gxz/session.1\n2025.04.03-15:44:04.62 - &lt;debug&gt; Initialized session 1\nInitialized session with id: 1\n2025.04.03-15:44:04.62 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.03-15:44:04.62 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.03-15:44:04.62 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] model: (null)\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] len_out_text: 512\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] len_out_imgname: 512\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] will return a dummy result\nclassification tags: This is a dummy classification tag!\nclassification imagename: This is a dummy imgname!\n2025.04.03-15:44:04.62 - &lt;debug&gt; Released session 1\n2025.04.03-15:44:04.62 - &lt;debug&gt; Cleaning up vAccel\n2025.04.03-15:44:04.62 - &lt;debug&gt; Cleaning up sessions\n2025.04.03-15:44:04.62 - &lt;debug&gt; Cleaning up resources\n2025.04.03-15:44:04.62 - &lt;debug&gt; Cleaning up plugins\n2025.04.03-15:44:04.62 - &lt;debug&gt; Unregistered plugin noop\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/","title":"Transport plugins","text":"<p>Transport plugins implement transport mechanisms for vAccel, to support remote execution, VM execution etc.:</p> <ul> <li>RPC plugin</li> <li>VirtIO plugin</li> </ul>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/","title":"RPC Plugin","text":"<p>The RPC plugin for vAccel implements RPC-based transport for vAccel operations. This plugin supports <code>vsock</code>, <code>unix</code> and <code>tcp</code> sockets.</p>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/#overview","title":"Overview","text":"<p>The plugin forwards vAccel calls from a host without accelerator access (ie. a VM) or a remote host, to a host with a hardware accelerator. In order to use the plugin you also need the vAccel RPC agent. The agent handles the plugin requests and translates the forwarded calls to host vAccel calls. Essentially, to use the RPC plugin the following components must be in place:</p> <ol> <li>Host w/o accelerator: vAccel + the RPC plugin, to forward the application    calls</li> <li>Host w/ accelerator: The vAccel RPC agent + vAccel + an acceleration    plugin, to handle the forwarded calls and perform the actual acceleration</li> </ol>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/#supported-operations","title":"Supported operations","text":"<ul> <li>Image classification</li> <li>Image segmentation</li> <li>Object detection</li> <li>Pose estimation</li> <li> <p>Monocular depth</p> </li> <li> <p>Matrix-to-matrix multiplication</p> </li> <li>Array copy</li> <li>Matrix-to-matrix multiplication simple</li> <li>Matrix-to-matrix multiplication and addition simple</li> <li> <p>Vector add</p> </li> <li> <p>Exec</p> </li> <li> <p>Exec with resource</p> </li> <li> <p>TensorFlow model load</p> </li> <li>TensorFlow model unload</li> <li>TensorFlow model run</li> <li>TensorFlow Lite model load</li> <li>TensorFlow Lite model unload</li> <li> <p>TensorFlow Lite model run</p> </li> <li> <p>Torch model load</p> </li> <li> <p>Torch model run</p> </li> <li> <p>MinMax</p> </li> <li>Generic operation</li> <li>Debug operation</li> </ul>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/#installing-the-plugin","title":"Installing the plugin","text":"<p>You can get the latest RPC plugin binary release from the Releases page of the vAccel repository. Releases include DEB packages and binaries for x86_64/aarch64/armv7l Ubuntu-based systems.</p>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/#deb","title":"DEB","text":"<p>To install the DEB package of the latest RPC plugin release:</p> x86ARM (64-bit)ARM (32-bit) <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-rpc_0.2.1-1_amd64.deb\nsudo dpkg -i vaccel-rpc_0.2.1-1_amd64.deb\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-rpc_0.2.1-1_arm64.deb\nsudo dpkg -i vaccel-rpc_0.2.1-1_arm64.deb\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-rpc_0.2.1-1_armhf.deb\nsudo dpkg -i vaccel-rpc_0.2.1-1_armhf.deb\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/#tar","title":"TAR","text":"<p>To install the TAR binary package of the latest RPC plugin release:</p> x86ARM (64-bit)ARM (32-bit) <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-rpc_0.2.1_amd64.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel-rpc_0.2.1_amd64.tar.gz --strip-components=2 -C /usr/local\n# Update pkg-config files with the correct prefix\nfind /usr/local -name \"vaccel-rpc.pc\" -exec sed -i 's:^\\(prefix=\\).*:\\1/usr/local:g' {} \\;\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-rpc_0.2.1_arm64.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel-rpc_0.2.1_arm64.tar.gz --strip-components=2 -C /usr/local\n# Update pkg-config files with the correct prefix\nfind /usr/local -name \"vaccel-rpc.pc\" -exec sed -i 's:^\\(prefix=\\).*:\\1/usr/local:g' {} \\;\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-rpc_0.2.1_armhf.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel-rpc_0.2.1_armhf.tar.gz --strip-components=2 -C /usr/local\n# Update pkg-config files with the correct prefix\nfind /usr/local -name \"vaccel-rpc.pc\" -exec sed -i 's:^\\(prefix=\\).*:\\1/usr/local:g' {} \\;\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/#latest-artifacts","title":"Latest artifacts","text":"<p>You can also find prebuilt artifacts of the latest RPC plugin revision at:</p> x86ARM (64-bit)ARM (32-bit) <pre><code># DEB\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/rpc/rev/main/x86_64/release/vaccel-rpc_latest_amd64.deb\n# TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/rpc/rev/main/x86_64/release/vaccel-rpc-latest-bin.tar.gz\n</code></pre> <pre><code># DEB\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/rpc/rev/main/aarch64/release/vaccel-rpc_latest_arm64.deb\n# TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/rpc/rev/main/aarch64/release/vaccel-rpc-latest-bin.tar.gz\n</code></pre> <pre><code># DEB\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/rpc/rev/main/armv7l/release/vaccel-rpc_latest_armhf.deb\n# TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/rpc/rev/main/armv7l/release/vaccel-rpc-latest-bin.tar.gz\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/#installing-the-rpc-agent","title":"Installing the RPC agent","text":"<p>You can get the latest RPC agent binary release from the Releases page of the vAccel Rust repository. Releases include DEB packages and binaries for x86_64/aarch64/armv7l Ubuntu-based systems.</p>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/#deb_1","title":"DEB","text":"<p>To install the DEB package of the latest RPC agent release:</p> x86ARM (64-bit)ARM (32-bit) <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-rpc-agent_0.4.1-1_amd64.deb\nsudo dpkg -i vaccel-rpc-agent_0.4.1-1_amd64.deb\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-rpc-agent_0.4.1-1_arm64.deb\nsudo dpkg -i vaccel-rpc-agent_0.4.1-1_arm64.deb\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-rpc-agent_0.4.1-1_armhf.deb\nsudo dpkg -i vaccel-rpc-agent_0.4.1-1_armhf.deb\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/#tar_1","title":"TAR","text":"<p>To install the TAR binary package of the latest RPC agent release:</p> x86ARM (64-bit)ARM (32-bit) <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-rpc-agent_0.4.1_amd64.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel-rpc-agent_0.4.1_amd64.tar.gz --strip-components=2 -C /usr/local\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-rpc-agent_0.4.1_arm64.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel-rpc-agent_0.4.1_arm64.tar.gz --strip-components=2 -C /usr/local\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-rpc-agent_0.4.1_armhf.tar.gz\n# Replace '/usr/local' below with the desired installation prefix\ntar xfv vaccel-rpc-agent_0.4.1_armhf.tar.gz --strip-components=2 -C /usr/local\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/#latest-artifacts_1","title":"Latest artifacts","text":"<p>You can also find prebuilt artifacts of the latest RPC agent revision at:</p> x86ARM (64-bit)ARM (32-bit) <pre><code># DEB\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/rust/rev/main/x86_64/release/vaccel-rpc-agent_latest_amd64.deb\n# TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/rust/rev/main/x86_64/release/vaccel-rpc-agent-latest-bin.tar.gz\n</code></pre> <pre><code># DEB\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/rust/rev/main/aarch64/release/vaccel-rpc-agent-latest-bin.tar.gz\n# TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/rust/rev/main/aarch64/release/vaccel-rpc-agent_latest_arm64.deb\n</code></pre> <pre><code># DEB\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/rust/rev/main/armv7l/release/vaccel-rpc-agent-latest-bin.tar.gz\n# TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/rust/rev/main/armv7l/release/vaccel-rpc-agent_latest_armhf.deb\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/#usage","title":"Usage","text":"<p>To specify RPC plugin as the selected plugin for vAccel execution:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-rpc.so\n</code></pre> <p>Ensure vAccel and the RPC plugin libraries are in the library search paths before trying to use the plugin. In order to use the plugin, an agent instance must be running.</p> <p>Additionally, you need to use a correct RPC address for the agent and the plugin. By default, the RPC components will use <code>tcp://127.0.0.1:65500</code> to communicate.</p> <p>The address is of the form:</p> <pre><code>\"&lt;prefix&gt;://&lt;address&gt;[:&lt;port&gt;]\"\n</code></pre> <p>where <code>&lt;prefix&gt;</code> is one of <code>tcp</code>, <code>unix</code> or <code>vsock</code> and <code>&lt;address&gt;</code>/<code>&lt;port&gt;</code> have the required format for the respective socket types.</p> <p>You can set an RPC address for the plugin by setting <code>VACCEL_RPC_ADDRESS</code>:</p> <pre><code>export VACCEL_RPC_ADDRESS=tcp://127.0.0.1:65500\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/#rpc-agent-usage","title":"RPC agent usage","text":"<p>The RPC agent must be installed in the host with the actual accelerator. Ensure, vAccel is also installed on the agent's host and present in the library search paths before trying to start the agent.</p> <p>To use the plugin, an RPC agent instance must be running and an acceleration plugin must be loaded. Therefore, an acceleration plugin must also be installed on the agent's host.</p> <p>To set an address for the RPC agent use the <code>-a</code> flag:</p> <pre><code>vaccel-rpc-agent -a \"tcp://127.0.0.1:65500\"\n</code></pre> <p>You can execute the RPC agent, ie. using the <code>NoOp</code> plugin on the same host as the plugin, with:</p> <pre><code>VACCEL_BOOTSTRAP_ENABLED=0 vaccel-rpc-agent \\\n    -a \"tcp://127.0.0.1:65500\" \\\n    --vaccel-config \"plugins=libvaccel-noop.so\"\n</code></pre> <p>You can use <code>--vaccel-config</code> with all the vaccel configuration variables in lowercase (preferred). You can also start the agent without <code>--vaccel-config</code> by setting configuration variables in the environment, as you would do for a plugin.</p> <p>The RPC agent provides usage information via:</p> <pre><code>vaccel-rpc-agent -h\n</code></pre> <p>Example configurations for different socket types:</p> <pre><code># unix socket\nADDRESS=\"unix:///path/to/unix/socket\"\nvaccel-rpc-agent -a \"${ADDRESS}\"\nexport VACCEL_RPC_ADDRESS=${ADDRESS}\n\n# tcp socket\nADDRESS=\"tcp://localhost:65500\"\nvaccel-rpc-agent -a \"${ADDRESS}\"\nexport VACCEL_RPC_ADDRESS=${ADDRESS}\n\n# vsock socket\n# NOTE: Address for vsock sockets is the host reserved address\nADDRESS=\"vsock://2:2048\"\nvaccel-rpc-agent -a \"${ADDRESS}\"\nexport VACCEL_RPC_ADDRESS=\"${ADDRESS}\"\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/rpc-plugin/#running-an-example","title":"Running an example","text":"<p>Start the RPC agent on the accelerator host, ie using the 'NoOp' plugin:</p> <pre><code>$ VACCEL_BOOTSTRAP_ENABLED=0 vaccel-rpc-agent \\\n      -a \"tcp://127.0.0.1:65500\" \\\n      --vaccel-config \"plugins=libvaccel-noop.so\"\n[2025-04-11T20:05:14Z INFO  ttrpc::sync::server] server listen started\n[2025-04-11T20:05:14Z INFO  ttrpc::sync::server] server started\n[2025-04-11T20:05:14Z INFO  vaccel_rpc_agent] vAccel RPC agent started\n[2025-04-11T20:05:14Z INFO  vaccel_rpc_agent] Listening on 'tcp://127.0.0.1:65500', press Ctrl+C to exit\n</code></pre> <p>On the same host, export the necessary variables for the plugin:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-rpc.so\nexport VACCEL_RPC_ADDRESS=tcp://127.0.0.1:65500\n# Optionally, for verbose output\nexport VACCEL_LOG_LEVEL=4\n</code></pre> <p>Assuming vAccel is installed at <code>/usr/local</code>, you can run a dummy image classification with:</p> <pre><code>$ classify /usr/local/share/vaccel/images/example.jpg\n2025.04.11-20:08:15.67 - &lt;debug&gt; Initializing vAccel\n2025.04.11-20:08:15.67 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.11-20:08:15.67 - &lt;debug&gt; Config:\n2025.04.11-20:08:15.67 - &lt;debug&gt;   plugins = libvaccel-rpc.so\n2025.04.11-20:08:15.67 - &lt;debug&gt;   log_level = debug\n2025.04.11-20:08:15.67 - &lt;debug&gt;   log_file = (null)\n2025.04.11-20:08:15.67 - &lt;debug&gt;   profiling_enabled = false\n2025.04.11-20:08:15.67 - &lt;debug&gt;   version_ignore = false\n2025.04.11-20:08:15.67 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/s0nza7\n2025.04.11-20:08:15.69 - &lt;info&gt; Registered plugin rpc 0.1.0-36-bbffdae6\n2025.04.11-20:08:15.69 - &lt;debug&gt; rpc is a VirtIO module\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op blas_sgemm from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op image_classify from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op image_detect from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op image_segment from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op image_depth from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op image_pose from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op tflite_session_load from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op tflite_session_delete from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op tflite_session_run from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op minmax from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op fpga_arraycopy from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op fpga_mmult from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op fpga_vectoradd from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op fpga_parallel from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op exec from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op exec_with_resource from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op torch_jitload_forward from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op opencv from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op tf_session_load from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op tf_session_delete from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Registered op tf_session_run from plugin rpc\n2025.04.11-20:08:15.69 - &lt;debug&gt; Loaded plugin rpc from libvaccel-rpc.so\n2025.04.11-20:08:15.70 - &lt;debug&gt; [rpc] Initializing new remote session\n2025.04.11-20:08:15.70 - &lt;debug&gt; [rpc] Initialized remote session 3\n2025.04.11-20:08:15.70 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/s0nza7/session.1\n2025.04.11-20:08:15.70 - &lt;debug&gt; Initialized session 1 with remote (id: 3)\nInitialized session with id: 1\n2025.04.11-20:08:15.70 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.11-20:08:15.70 - &lt;debug&gt; Returning func from hint plugin rpc\n2025.04.11-20:08:15.70 - &lt;debug&gt; Found implementation in rpc plugin\nclassification tags: This is a dummy classification tag!\nclassification imagename: This is a dummy imgname!\n2025.04.11-20:08:15.75 - &lt;debug&gt; [rpc] Releasing remote session 3\n2025.04.11-20:08:15.83 - &lt;debug&gt; Released session 1\n2025.04.11-20:08:15.83 - &lt;debug&gt; Cleaning up vAccel\n2025.04.11-20:08:15.83 - &lt;debug&gt; Cleaning up sessions\n2025.04.11-20:08:15.83 - &lt;debug&gt; Cleaning up resources\n2025.04.11-20:08:15.83 - &lt;debug&gt; Cleaning up plugins\n2025.04.11-20:08:15.83 - &lt;debug&gt; Unregistered plugin rpc\n</code></pre> <p>Info</p> <p>You can find detailed tutorials on how to run a vAccel application on a VM and remotely in the Tutorials section.</p>"},{"location":"plugins/available-plugins/transport-plugins/virtio-plugin/","title":"VirtIO Plugin","text":"<p>The VirtIO plugin for vAccel implements VirtIO-based transport for vAccel operations using the virtio-accel kernel module. This plugin is meant to be a more efficient alternative to standard VirtIO mechanisms like vSock.</p>"},{"location":"plugins/available-plugins/transport-plugins/virtio-plugin/#overview","title":"Overview","text":"<p>The plugin forwards vAccel calls from a VM to the virtualization host. To use this plugin you will need both the virtio-accel module (on the VM) and a custom VMM with a virtio-accel backend (on the host).</p> <p>The VMM handles the plugin requests and translates the forwarded calls to host vAccel calls. Essentially, to use the VirtIO plugin the following components must be in place:</p> <ol> <li>Guest: vAccel + the VirtIO plugin, to forward the application calls</li> <li>Host: VMM w/ virtio-accel support + vAccel + an acceleration plugin, to    handle the forwarded calls and perform the actual acceleration</li> </ol> <p>Currently, there is a custom QEMU implementation of the virtio-accel backend.</p>"},{"location":"plugins/available-plugins/transport-plugins/virtio-plugin/#supported-operations","title":"Supported operations","text":"<ul> <li>Image classification</li> <li>Image segmentation</li> <li>Object detection</li> <li>Pose estimation</li> <li> <p>Monocular depth</p> </li> <li> <p>Matrix-to-matrix multiplication</p> </li> <li>Array copy</li> <li>Matrix-to-matrix multiplication simple</li> <li>Matrix-to-matrix multiplication and addition simple</li> <li> <p>Vector add</p> </li> <li> <p>Exec</p> </li> <li> <p>Exec with resource</p> </li> <li> <p>MinMax</p> </li> <li>Generic operation</li> <li>Debug operation</li> </ul>"},{"location":"plugins/available-plugins/transport-plugins/virtio-plugin/#installing-the-plugin","title":"Installing the plugin","text":"<p>You can get the latest VirtIO plugin binary release from the Releases page of the vAccel repository. Releases include DEB packages for x86_64/aarch64 Ubuntu-based systems.</p>"},{"location":"plugins/available-plugins/transport-plugins/virtio-plugin/#deb","title":"DEB","text":"<p>To install the DEB package of the latest VirtIO plugin release:</p> x86ARM (64-bit) <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-virtio_0.2.0-1_amd64.deb\nsudo dpkg -i vaccel-virtio_0.2.0-1_amd64.deb\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-virtio_0.2.0-1_arm64.deb\nsudo dpkg -i vaccel-virtio_0.2.0-1_arm64.deb\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/virtio-plugin/#latest-artifacts","title":"Latest artifacts","text":"<p>You can also find prebuilt artifacts of the latest VirtIO plugin revision at:</p> x86ARM (64-bit) <pre><code># DEB\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/virtio/rev/main/x86_64/release/vaccel-virtio_latest_amd64.deb\n</code></pre> <pre><code># DEB\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/virtio/rev/main/aarch64/release/vaccel-virtio_latest_arm64.deb\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/virtio-plugin/#getting-the-prebuilt-vm-artifacts","title":"Getting the prebuilt VM artifacts","text":"<p>Besides the plugin binaries, you can find prebuilt x86_64/aarch64 artifacts for running a VM with the latest release. The provided artifacts contain an Ubuntu <code>rootfs.img</code> with the virtio-accel module, VirtIO plugin and vAccel pre-installed. A Linux kernel image that can be used to run a vAccel-enabled VM is also included.</p>"},{"location":"plugins/available-plugins/transport-plugins/virtio-plugin/#tar","title":"TAR","text":"<p>To get the TAR archive with the prebuilt VM artifacts of the latest VirtIO plugin release:</p> x86ARM (64-bit) <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-virtio-vm_0.2.0_amd64.tar.xz\n# Replace 'vm-artifacts' with the desired artifact directory\nmkdir -p vm-artifacts &amp;&amp; tar xfv vaccel-virtio_0.2.0_amd64.tar.gz -C vm-artifacts\nfind vm-artifacts -name \"virtio*.tar.xz\" -exec tar xfv {} -C vm-artifacts \\;\nrm -r vm-artifacts/virtio*.tar.xz\n</code></pre> <pre><code>wget https://github.com/nubificus/vaccel/releases/download/v0.7.1/vaccel-virtio-vm_0.2.0_arm64.tar.gz\n# Replace 'vm-artifacts' with the desired artifact directory\nmkdir -p vm-artifacts &amp;&amp; tar xfv vaccel-virtio_0.2.0_arm64.tar.gz -C vm-artifacts\nfind vm-artifacts -name \"virtio*.tar.xz\" -exec tar xfv {} -C vm-artifacts \\;\nrm -r vm-artifacts/virtio*.tar.xz\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/virtio-plugin/#latest-artifacts_1","title":"Latest artifacts","text":"<p>You can also find the prebuilt VM artifacts of the latest VirtIO plugin revision at:</p> x86ARM (64-bit) <pre><code># TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/virtio/rev/main/x86_64/release/vaccel-virtio-latest-vm.tar.xz\n</code></pre> <pre><code># TAR\nhttps://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/virtio/rev/main/aarch64/release/vaccel-virtio-latest-vm.tar.xz\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/virtio-plugin/#installing-a-virtio-accel-enabled-qemu","title":"Installing a virtio-accel-enabled QEMU","text":"<p>You can get a Docker image with a virtio-accel-enabled QEMU &amp; vAccel pre-installed for x86_64/aarch64 with:</p> <pre><code>docker pull harbor.nbfc.io/nubificus/qemu-vaccel\n</code></pre>"},{"location":"plugins/available-plugins/transport-plugins/virtio-plugin/#usage","title":"Usage","text":"<p>To specify VirtIO plugin as the selected plugin for vAccel execution:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-virtio.so\n</code></pre> <p>Ensure vAccel and the VirtIO plugin libraries are in the library search paths before trying to use the plugin. In order to use the plugin, the virtio-accel module must be loaded in the VM, the used VMM must have virtio-accel support and the respective <code>accel</code> device must exist.</p>"},{"location":"plugins/available-plugins/transport-plugins/virtio-plugin/#prebuilt-vm-artifacts-usage","title":"Prebuilt VM artifacts usage","text":"<p>Assuming KVM is enabled on your system and you have the prebuilt VM artifacts at <code>vm-artifacts</code>, you can boot a virtio-accel-enabled VM with vAccel &amp; the VirtIO plugin preinstalled using:</p> x86ARM (64-bit) <pre><code>cd vm-artifacts\ndocker run --rm --device=/dev/kvm -it \\\n    --mount type=bind,source=\"$(pwd)\",destination=/data \\\n    harbor.nbfc.io/nubificus/qemu-vaccel \\\n    -r rootfs.img --drive-cache -k bzImage* \\\n    -M pc,accel=kvm --vcpus 2 -m 2048 \\\n    /bin/bash\n</code></pre> <pre><code>cd vm-artifacts\ndocker run --rm --device=/dev/kvm -it \\\n    --mount type=bind,source=\"$(pwd)\",destination=/data \\\n    harbor.nbfc.io/nubificus/qemu-vaccel \\\n    -r rootfs.img --drive-cache -k Image* \\\n    --cmdline-append \"console=ttyAMA0,115200\" \\\n    -M virt --no-pci --vcpus 2 -m 2048 \\\n    /bin/bash\n</code></pre> <p>This will start the host vAccel with the <code>NoOp</code> plugin by default. To use plugins not bundled with vAccel you can install them in the current dir and use them by setting <code>VACCEL_PLUGINS</code> in the <code>docker run</code> env.</p>"},{"location":"plugins/available-plugins/transport-plugins/virtio-plugin/#running-an-example","title":"Running an example","text":"<p>You can run a command directly using the <code>-c</code> argument of the qemu-vaccel Docker image.</p> <p>Assuming you have the prebuilt VM artifacts at <code>vm-artifacts</code>, to run an image classification with the 'NoOp' plugin use:</p> x86ARM (64-bit) <pre><code>$ cd vm-artifacts\n$ docker run --rm --device=/dev/kvm -it \\\n      --mount type=bind,source=\"$(pwd)\",destination=/data \\\n      harbor.nbfc.io/nubificus/qemu-vaccel \\\n      -r rootfs.img --drive-cache -k bzImage* \\\n      -M pc,accel=kvm --vcpus 2 -m 2048 \\\n      -c \"classify /usr/local/share/vaccel/images/example.jpg\"\n2025.04.12-20:01:09.85 - &lt;debug&gt; Initializing vAccel\n2025.04.12-20:01:09.85 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.12-20:01:09.85 - &lt;debug&gt; Config:\n2025.04.12-20:01:09.85 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.12-20:01:09.85 - &lt;debug&gt;   log_level = debug\n2025.04.12-20:01:09.85 - &lt;debug&gt;   log_file = (null)\n2025.04.12-20:01:09.85 - &lt;debug&gt;   profiling_enabled = false\n2025.04.12-20:01:09.85 - &lt;debug&gt;   version_ignore = false\n2025.04.12-20:01:09.85 - &lt;debug&gt; Created top-level rundir: /run/user/0/vaccel/u05Rjf\n2025.04.12-20:01:09.85 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op noop from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op blas_sgemm from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op image_classify from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op image_detect from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op image_segment from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op image_pose from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op image_depth from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op exec from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op tf_session_load from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op tf_session_run from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op tf_session_delete from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op minmax from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op fpga_arraycopy from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op fpga_vectoradd from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op fpga_parallel from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op fpga_mmult from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op exec_with_resource from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op torch_jitload_forward from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op torch_sgemm from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op opencv from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op tflite_session_load from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op tflite_session_run from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op tflite_session_delete from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n2025.04.12-20:01:16.73 - &lt;debug&gt; New rundir for session 1: /run/user/0/vaccel/u05Rjf/session.1\n2025.04.12-20:01:16.73 - &lt;debug&gt; Initialized session 1\n2025.04.12-20:01:16.73 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.12-20:01:16.73 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.12-20:01:16.73 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] model: (null)\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] len_out_text: 512\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] len_out_imgname: 512\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.12-20:01:16.73 - &lt;debug&gt; Released session 1\nInitialized session with id: 1\nclassification tags: This is a dummy classification tag!\nclassification imagename: This is a dummy imgname!\n2025.04.12-20:01:17.06 - &lt;debug&gt; Cleaning up vAccel\n2025.04.12-20:01:17.06 - &lt;debug&gt; Cleaning up sessions\n2025.04.12-20:01:17.06 - &lt;debug&gt; Cleaning up resources\n2025.04.12-20:01:17.06 - &lt;debug&gt; Cleaning up plugins\n2025.04.12-20:01:17.06 - &lt;debug&gt; Unregistered plugin noop\n</code></pre> <pre><code>$ cd vm-artifacts\n$ docker run --rm --device=/dev/kvm -it \\\n      --mount type=bind,source=\"$(pwd)\",destination=/data \\\n      harbor.nbfc.io/nubificus/qemu-vaccel \\\n      -r rootfs.img --drive-cache -k Image* \\\n      --cmdline-append \"console=ttyAMA0,115200\" \\\n      -M virt --no-pci --vcpus 2 -m 2048 \\\n      -c \"classify /usr/local/share/vaccel/images/example.jpg\"\n2025.04.12-20:01:09.85 - &lt;debug&gt; Initializing vAccel\n2025.04.12-20:01:09.85 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.12-20:01:09.85 - &lt;debug&gt; Config:\n2025.04.12-20:01:09.85 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.12-20:01:09.85 - &lt;debug&gt;   log_level = debug\n2025.04.12-20:01:09.85 - &lt;debug&gt;   log_file = (null)\n2025.04.12-20:01:09.85 - &lt;debug&gt;   profiling_enabled = false\n2025.04.12-20:01:09.85 - &lt;debug&gt;   version_ignore = false\n2025.04.12-20:01:09.85 - &lt;debug&gt; Created top-level rundir: /run/user/0/vaccel/u05Rjf\n2025.04.12-20:01:09.85 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op noop from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op blas_sgemm from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op image_classify from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op image_detect from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op image_segment from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op image_pose from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op image_depth from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op exec from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op tf_session_load from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op tf_session_run from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op tf_session_delete from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op minmax from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op fpga_arraycopy from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op fpga_vectoradd from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op fpga_parallel from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op fpga_mmult from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op exec_with_resource from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op torch_jitload_forward from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op torch_sgemm from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op opencv from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op tflite_session_load from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op tflite_session_run from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Registered op tflite_session_delete from plugin noop\n2025.04.12-20:01:09.85 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n2025.04.12-20:01:16.73 - &lt;debug&gt; New rundir for session 1: /run/user/0/vaccel/u05Rjf/session.1\n2025.04.12-20:01:16.73 - &lt;debug&gt; Initialized session 1\n2025.04.12-20:01:16.73 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.12-20:01:16.73 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.12-20:01:16.73 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] model: (null)\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] len_out_text: 512\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] len_out_imgname: 512\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.12-20:01:16.73 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.12-20:01:16.73 - &lt;debug&gt; Released session 1\nInitialized session with id: 1\nclassification tags: This is a dummy classification tag!\nclassification imagename: This is a dummy imgname!\n2025.04.12-20:01:17.06 - &lt;debug&gt; Cleaning up vAccel\n2025.04.12-20:01:17.06 - &lt;debug&gt; Cleaning up sessions\n2025.04.12-20:01:17.06 - &lt;debug&gt; Cleaning up resources\n2025.04.12-20:01:17.06 - &lt;debug&gt; Cleaning up plugins\n2025.04.12-20:01:17.06 - &lt;debug&gt; Unregistered plugin noop\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Learn step-by-step how to perform common actions with vAccel.</p> <ul> <li>Running a vAccel application on a VM</li> <li>Running a vAccel application remotely</li> <li>Writing your first plugin</li> <li>Deploying vAccel applications using Kubernetes</li> </ul>"},{"location":"tutorials/deploying-vaccel-applications-using-kubernetes/","title":"Deploying vAccel applications using Kubernetes","text":"<p>This guide describes how to deploy a vAccel-enabled application, alongside the vAccel Agent with the Torch plugin using Kubernetes. It includes:</p> <ul> <li>Full explanation of the deployment architecture</li> <li>Sidecar-based co-location of client and agent</li> <li>Split deployment with remote agent access</li> <li>Dockerfiles for both client and agent</li> <li>Simple block diagram for visual reference</li> </ul>"},{"location":"tutorials/deploying-vaccel-applications-using-kubernetes/#architecture-overview","title":"Architecture Overview","text":"<p>The deployment includes:</p> <ul> <li>The vAccel Agent (running <code>vaccel-rpc-agent</code>) exposing a Unix socket or   TCP endpoint.</li> <li>The vAccel-enabled Application, packaged with the RPC plugin, which   connects to the agent.</li> <li>A sidecar option to colocate both agent and client in one pod for   latency-sensitive workloads.</li> <li>A split deployment option where the agent runs as a standalone DaemonSet.</li> </ul>"},{"location":"tutorials/deploying-vaccel-applications-using-kubernetes/#deployment-graph","title":"Deployment Graph","text":"<pre><code>flowchart TD\n  subgraph Node1[\"K8s Node\"]\n    subgraph PodA[\"Sidecar Pod\"]\n      A1[vAccel Client]\n      A2[vAccel RPC Agent]\n    end\n  end\n\n  subgraph Node2[\"K8s Node\"]\n    subgraph PodB[\"Client Only Pod\"]\n      B1[vAccel Client]\n    end\n    subgraph PodC[\"Agent Pod\"]\n      C1[vAccel RPC Agent]\n    end\n  end\n\n  B1 --&gt;|RPC over vsock/tcp| C1\n  A1 --&gt;|Unix socket| A2</code></pre> <p>We have gathered all necessary files in a Github repository. Its file structure is as follows:</p> <pre><code>\u251c\u2500\u2500 docker\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Dockerfile\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Dockerfile.agent\n\u251c\u2500\u2500 manifests\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 client.yaml\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 daemonset-agent.yaml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 sidecar.yaml\n\u2514\u2500\u2500 README.md\n</code></pre> <p>In the <code>docker</code> folder we include two <code>Dockerfiles</code>, one for the client application and one for the vaccel agent. Feel free to build on the client <code>Dockerfile</code> to create your own. To showcase our example we have already included our application binary in an example container image: <code>harbor.nbfc.io/nubificus/vaccel-torch-bert-example:x86_64</code>.</p> <p>The <code>manifests</code> folder contains YAML files to deploy this example in both modes of operation.</p>"},{"location":"tutorials/deploying-vaccel-applications-using-kubernetes/#vaccel-agent-as-a-sidecar-container","title":"vAccel Agent as a sidecar container","text":"<p>The agent runs alongside the client application, in a single pod (<code>sidecar.yaml</code>). Since this mode implicitly assumes that both containers share the same mount namespaces, we can use the <code>UNIX</code> socket RPC transport. See the following snippet from the YAML file:</p> <pre><code>    containers:\n        - name: vaccel-agent\n          volumeMounts:\n              - name: vaccel-sock\n                mountPath: /var/run/vaccel\n...\n        - name: vaccel-client\n...\n          volumeMounts:\n              - name: vaccel-sock\n                mountPath: /var/run/vaccel\n...\n    volumes:\n        - name: vaccel-sock\n          emptyDir: {}\n</code></pre> <p>Note: The <code>ENTRYPOINT</code> of the Agent's Dockerfile is the following:</p> <pre><code>ENTRYPOINT [\"vaccel-rpc-agent\", \"-a\", \"unix:///var/run/vaccel/vaccel.sock\"]\n</code></pre> <p>and the env var that points to the vAccel endpoint in the Client's Dockerfile is:</p> <pre><code>ENV VACCEL_RPC_ADDRESS=\"unix:///var/run/vaccel/vaccel.sock\"\n</code></pre> <p>Logs from an example deployment are shown below.</p> <p>Agent logs, before the client start:</p> <pre><code>$ kubectl logs vaccel-sidecar-pod -c vaccel-agent\n[2025-06-22T22:30:03Z INFO  ttrpc::sync::server] server listen started\n[2025-06-22T22:30:03Z INFO  ttrpc::sync::server] server started\n[2025-06-22T22:30:03Z INFO  vaccel_rpc_agent] vAccel RPC agent started\n[2025-06-22T22:30:03Z INFO  vaccel_rpc_agent] Listening on 'unix:///var/run/vaccel/vaccel.sock', press Ctrl+C to exit\n</code></pre> <p>Client logs:</p> <pre><code>$ kubectl logs vaccel-sidecar-pod -c vaccel-client\n2025.06.22-22:30:03.73 - &lt;info&gt; vAccel 0.7.0-7-e67e52b6\n2025.06.22-22:30:03.73 - &lt;info&gt; Registered plugin rpc 0.2.0-1-eca9e440\nProcessing 26954 lines from: /data/tweets.txt\n== [Vocab Loaded] ==\n2025.06.22-22:30:03.78 - &lt;warn&gt; Path does not seem to have a `&lt;prefix&gt;://`\n2025.06.22-22:30:03.78 - &lt;warn&gt; Assuming cnn_trace.pt is a local path\nvaccel_resource_new(): Time Taken: 68500 nanoseconds\nCreated new model resource 1\nInitialized vAccel session 1\nLine 1: Duration: 497.627 ms Prediction: neither\nLine 2: Duration: 198.996 ms Prediction: offensive-language\nLine 3: Duration: 359.865 ms Prediction: offensive-language\nLine 4: Duration: 69.7109 ms Prediction: offensive-language\n...\n</code></pre> <p>Agent logs, after client initial connection:</p> <pre><code>$ kubectl logs vaccel-sidecar-pod -c vaccel-agent\n[2025-06-22T22:30:03Z INFO  ttrpc::sync::server] server listen started\n[2025-06-22T22:30:03Z INFO  ttrpc::sync::server] server started\n[2025-06-22T22:30:03Z INFO  vaccel_rpc_agent] vAccel RPC agent started\n[2025-06-22T22:30:03Z INFO  vaccel_rpc_agent] Listening on 'unix:///var/run/vaccel/vaccel.sock', press Ctrl+C to exit\n[2025-06-22T22:30:03Z INFO  vaccel_rpc_agent::session] Created session 1\n[2025-06-22T22:30:05Z INFO  vaccel_rpc_agent::resource] Creating new resource\n[2025-06-22T22:30:05Z INFO  vaccel_rpc_agent::resource] Registering resource 1 with session 1\n[2025-06-22T22:30:06Z INFO  vaccel_rpc_agent::ops::torch] session:1 PyTorch jitload forward\n[2025-06-22T22:30:06Z INFO  vaccel_rpc_agent::ops::torch] session:1 PyTorch jitload forward\n[2025-06-22T22:30:06Z INFO  vaccel_rpc_agent::ops::torch] session:1 PyTorch jitload forward\n...\n</code></pre>"},{"location":"tutorials/deploying-vaccel-applications-using-kubernetes/#vaccel-agent-as-a-daemonset","title":"vAccel Agent as a daemonset","text":"<p>The Agent runs as a daemonset providing a service to the k8s cluster, available via a hostname and port. This mode offers a lot more flexibility, as it allows multiple agent deployments, on heterogeneous nodes, with diverse hardware characteristics. In our example we use a single <code>x86_64</code> node, but more complex scenarios can be supported, with multiple GPUs/FPGAs or custom acceleration nodes. In this mode of operation we have two YAML files:</p> <p>(a) one for the agent daemonset (<code>daemoneset-agent.yaml</code>) that includes the service:</p> <pre><code>apiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n    name: vaccel-agent\nspec:\n    selector:\n        matchLabels:\n            app: vaccel-agent\n    template:\n        metadata:\n            labels:\n                app: vaccel-agent\n        spec:\n            containers:\n                - name: vaccel-agent\n                  image: harbor.nbfc.io/nubificus/vaccel-torch-bert-example-agent:x86_64\n                  command: [\"vaccel-rpc-agent\"]\n                  args: [\"-a\", \"tcp://0.0.0.0:8888\"]\n                  ports:\n                      - containerPort: 8888\n                        name: rpc\n</code></pre> <p>and the service:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: vaccel-agent\n  labels:\n    app: vaccel-agent\nspec:\n  ports:\n  - name: vaccel-agent\n    port: 8888\n    protocol: TCP\n    targetPort: 8888\n  selector:\n    app: vaccel-agent\n  sessionAffinity: None\n</code></pre> <p>(b) one for the client application (<code>client.yaml</code>) that points to the respective vAccel agent service:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n    name: vaccel-client\nspec:\n    containers:\n        - name: vaccel-client\n          image: harbor.nbfc.io/nubificus/vaccel-torch-bert-example:x86_64\n          command: [\"./build/classifier\"]\n          args: [\"-m\", \"cnn_trace.pt\", \"-v\", \"bert_cased_vocab.txt\", \"-f\", \"/data/tweets.txt\"]\n          env:\n              - name: VACCEL_RPC_ADDRESS\n                value: \"tcp://vaccel-agent:8888\"\n          volumeMounts:\n              - name: tweets\n                mountPath: /data\n    volumes:\n        - name: tweets\n          hostPath:\n            path: /tmp/data\n</code></pre> <p>Deployment logs are shown below.</p> <p>Agent &amp; service instantiation:</p> <pre><code>$ kubectl apply -f daemonset-agent.yaml\ndaemonset.apps/vaccel-agent created\nservice/vaccel-agent created\n$ kubectl get pods -o wide\nNAME                             READY   STATUS         RESTARTS       AGE    IP              NODE      NOMINATED NODE   READINESS GATES\nvaccel-agent-p4zxg               1/1     Running        0              15s    10.244.43.21    node1     &lt;none&gt;           &lt;none&gt;\n$ kubectl logs vaccel-agent-p4zxg\n[2025-06-22T22:34:34Z INFO  ttrpc::sync::server] server listen started\n[2025-06-22T22:34:34Z INFO  ttrpc::sync::server] server started\n[2025-06-22T22:34:34Z INFO  vaccel_rpc_agent] vAccel RPC agent started\n[2025-06-22T22:34:34Z INFO  vaccel_rpc_agent] Listening on 'tcp://0.0.0.0:8888', press Ctrl+C to exit\n</code></pre> <pre><code>$ kubectl get svc -o wide\nNAME               TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE    SELECTOR\nvaccel-agent       ClusterIP   10.244.21.70   &lt;none&gt;        8888/TCP   64s    app=vaccel-agent\n</code></pre> <p>Client spawn:</p> <pre><code>$ kubectl apply -f client.yaml\npod/vaccel-client created\n$ kubectl get pods -o wide\nNAME                             READY   STATUS             RESTARTS       AGE    IP              NODE      NOMINATED NODE   READINESS GATES\nvaccel-agent-p4zxg               1/1     Running            0              2m9s   10.244.43.21    node1     &lt;none&gt;           &lt;none&gt;\nvaccel-client                    1/1     Running            0              11s    10.244.43.1     node1     &lt;none&gt;           &lt;none&gt;\n$ kubectl logs vaccel-client\n2025.06.22-22:36:32.01 - &lt;info&gt; vAccel 0.7.0-7-e67e52b6\n2025.06.22-22:36:32.02 - &lt;info&gt; Registered plugin rpc 0.2.0-1-eca9e440\nProcessing 26954 lines from: /data/tweets.txt\n== [Vocab Loaded] ==\n2025.06.22-22:36:32.07 - &lt;warn&gt; Path does not seem to have a `&lt;prefix&gt;://`\n2025.06.22-22:36:32.07 - &lt;warn&gt; Assuming cnn_trace.pt is a local path\nvaccel_resource_new(): Time Taken: 67057 nanoseconds\nCreated new model resource 1\nInitialized vAccel session 1\nLine 1: Duration: 551.823 ms Prediction: neither\nLine 2: Duration: 279.833 ms Prediction: offensive-language\nLine 3: Duration: 413.417 ms Prediction: offensive-language\nLine 4: Duration: 120.675 ms Prediction: offensive-language\nLine 5: Duration: 185.506 ms Prediction: neither\n...\n</code></pre>"},{"location":"tutorials/deploying-vaccel-applications-using-kubernetes/#next-steps","title":"Next Steps","text":"<ul> <li>Customize your Torch model or plugin inside the client image</li> <li>Test workloads in the sidecar first for simplified debugging</li> <li>Scale via Deployment/Job or integrate with KNative</li> </ul>"},{"location":"tutorials/running-a-vaccel-application-on-a-vm/","title":"Running a vAccel application on a VM","text":""},{"location":"tutorials/running-a-vaccel-application-on-a-vm/#overview","title":"Overview","text":"<p>To run a vAccel application on a VM you have to use a suitable transport plugin. The plugin components will handle the forwarding of the function call from the guest (VM) to the host system. Since a transport plugin will essentially forward a vAccel function call from one vAccel instance to another, a valid vAccel installation is required for both the guest and the host system. A visual representation of the execution flow is shown in Figure 1.</p> <p> </p> <p>Figure 1. vAccel VM execution flow  </p> <p>The easiest way to run a vAccel application on a VM is to use the <code>RPC</code> plugin. This plugin leverages the VirtIO vSock device for guest-host communication without requiring any kernel customization. Guest-host communication over vSock is handled by the the vAccel <code>RPC</code> plugin (guest) and the vAccel RPC agent (host). In order to use the <code>RPC</code> plugin the following components must be in place:</p> <ol> <li>Host: The vAccel RPC agent + vAccel + an acceleration plugin, to handle the    forwarded calls and perform the actual acceleration</li> <li>Guest: vAccel + the <code>RPC</code> plugin, to forward the application calls</li> </ol>"},{"location":"tutorials/running-a-vaccel-application-on-a-vm/#preparing-the-host","title":"Preparing the host","text":"<p>If you have not already installed vAccel, install it from binaries or from source. The rest of this guide assumes vAccel libraries exist in the standard library search paths.</p>"},{"location":"tutorials/running-a-vaccel-application-on-a-vm/#installing-vaccel-rpc-agent","title":"Installing vAccel RPC agent","text":"<p>vAccel RPC agent will handle the RPC requests and forward calls to the host vAccel instance. You can find more information on how to install the <code>vaccel-rpc-agent</code> binary at the relevant section.</p>"},{"location":"tutorials/running-a-vaccel-application-on-a-vm/#preparing-the-vm-artifacts","title":"Preparing the VM artifacts","text":"<p>To boot a working VM you will need at least a kernel and rootfs image. The <code>VirtIO</code> plugin artifacts are a good starting point for running a basic vAccel-enabled VM. You can get them with:</p> <pre><code>mkdir downloads\n\n# Download the artifacts.\n# You can replace `x86_64` with `aarch64` below for aarch64 VM artifacts\nwget -P downloads \\\n    https://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/virtio/rev/main/x86_64/debug/vaccel-virtio-latest-vm.tar.xz\n\n# Extract all of them in the current directory\ntar xfv downloads/vaccel-virtio-latest-vm.tar.xz\nfind -name \"virtio-accel*.tar.xz\" -exec tar xfv {} \\;\nrm virtio-accel*.tar.xz\n\n# Optionally, rename files for simplicity in the next steps\nfor file in linux-*.config bzImage-* vmlinux-*; do\n    new_name=$(echo \"$file\" | sed -E 's/-[0-9]+\\.[0-9]+\\.[0-9]+-/-/')\n    mv \"$file\" \"$new_name\"\ndone\nmv vmlinux-amd64-fc vmlinux\nmv bzImage-amd64 bzImage\n</code></pre> <p>This should leave you with 3 sets of files in the current directory:</p> <ul> <li>A <code>rootfs.img</code> containing Ubuntu with a vAccel installation</li> <li>A <code>vmlinux</code> and a <code>linux-amd64-fc.config</code> that correspond to a basic   (uncompressed) Linux kernel image meant to be used with Firecracker</li> <li>A <code>bzImage</code> and a <code>linux-amd64.config</code> that correspond to a basic (compressed)   Linux kernel image meant to be used with other VMMs</li> </ul> <p>To use the <code>rootfs.img</code> you will need to install the <code>RPC</code> plugin:</p> <pre><code># Mount the image\nmkdir temp\nsudo mount rootfs.img temp\n\n# Download and install the `RPC` plugin binaries.\n# You can replace `x86_64` with `aarch64` below if you used the aarch64 VM\n# artifacts\nwget -P downloads \\\n    https://s3.nbfc.io/nbfc-assets/github/vaccel/plugins/rpc/rev/main/x86_64/release/vaccel-rpc-latest-bin.tar.gz\nsudo tar xfv downloads/vaccel-rpc-latest-bin.tar.gz \\\n    --strip-components=2 -C ./temp/usr/local\n\n# Comment out unnecessary fstab entries\nsudo sed -i '/9p/s/^/#/' ./temp/etc/fstab\n\nsudo umount temp\nrm -r temp\n</code></pre> <p>Your current directory should look something like:</p> <pre><code>$ tree -L 1\n.\n\u251c\u2500\u2500 bzImage\n\u251c\u2500\u2500 downloads\n\u251c\u2500\u2500 linux-amd64-fc.config\n\u251c\u2500\u2500 linux-amd64.config\n\u251c\u2500\u2500 rootfs.img\n\u2514\u2500\u2500 vmlinux\n\n1 directory, 5 files\n</code></pre>"},{"location":"tutorials/running-a-vaccel-application-on-a-vm/#booting-a-vaccel-enabled-vm","title":"Booting a vAccel-enabled VM","text":"<p>With the required artifacts in place, you can run any of the VMMs we have tested: Firecracker, Cloud Hypervisor or QEMU. You will need access to <code>/dev/kvm</code> so make sure that your user is a member of the <code>kvm</code> group or launch the VM as the <code>root</code> user.</p>"},{"location":"tutorials/running-a-vaccel-application-on-a-vm/#firecracker","title":"Firecracker","text":"<p>You can get the latest Firecracker release from the official repo. Ie. to download and extract Firecracker v1.11.0 for amd64:</p> <pre><code>wget -P downloads \\\n    https://github.com/firecracker-microvm/firecracker/releases/download/v1.11.0/firecracker-v1.11.0-x86_64.tgz\nmkdir firecracker\ntar xfv downloads/firecracker-v1.11.0-x86_64.tgz \\\n    --strip-components=1 -C firecracker\n\n# Optionally, link to a common filename to simplify next steps\nln -s firecracker/firecracker-v1.11.0-x86_64 firecracker/firecracker\n</code></pre> <p>A json config is needed to boot a VM. You can download a sample config with:</p> <pre><code>wget https://s3.nbfc.io/nbfc-assets/github/vaccelrt/vm-example/x86_64/fc/config_vsock.json\n</code></pre> <p>The updated current directory should look like:</p> <pre><code>$ tree -L 1\n.\n\u251c\u2500\u2500 bzImage\n\u251c\u2500\u2500 config_vsock.json\n\u251c\u2500\u2500 downloads\n\u251c\u2500\u2500 firecracker\n\u251c\u2500\u2500 linux-amd64-fc.config\n\u251c\u2500\u2500 linux-amd64.config\n\u251c\u2500\u2500 rootfs.img\n\u2514\u2500\u2500 vmlinux\n\n2 directories, 6 files\n</code></pre> Note <p>If you have already run <code>firecracker</code> or these files exist for some reason, ensure that <code>./fc.sock</code> and <code>/tmp/vaccel.sock</code> are cleaned up before trying to launch the VM:</p> <pre><code>rm fc.sock /tmp/vaccel.sock\n</code></pre> <p>If you do not, <code>firecracker</code> will fail with errors like:</p> <pre><code>2025-03-30T17:56:21.871223256 [anonymous-instance:main] Running Firecracker v1.11.0\n2025-03-30T17:56:21.871393598 [anonymous-instance:main] RunWithApiError error: Failed to open the API socket at: fc.sock. Check that it is not already used.\nError: RunWithApi(FailedToBindSocket(\"fc.sock\"))\n2025-03-30T17:56:21.871438293 [anonymous-instance:main] Firecracker exiting with error. exit_code=1\n</code></pre> <p>or</p> <pre><code>2025-03-30T17:55:39.607508767 [anonymous-instance:main] Running Firecracker v1.11.0\n2025-03-30T17:55:39.608446159 [anonymous-instance:main] RunWithApiError error: Failed to build MicroVM from Json: Configuration for VMM from one single json failed: Vsock device error: Cannot create backend for vsock device: Error binding to the host-side Unix socket: Address in use (os error 98)\nError: RunWithApi(BuildFromJson(ParseFromJson(VsockDevice(CreateVsockBackend(UnixBind(Os { code: 98, kind: AddrInUse, message: \"Address in use\" }))))))\n2025-03-30T17:55:39.608572227 [anonymous-instance:main] Firecracker exiting with error. exit_code=1\n</code></pre> <p>Finally, to launch the VM use:</p> <pre><code>$ ./firecracker/firecracker --api-sock fc.sock --config-file config_vsock.json\n2025-03-30T18:14:06.845979099 [anonymous-instance:main] Running Firecracker v1.11.0\n2025-03-30T18:14:06.866599137 [anonymous-instance:main] Artificially kick devices.\n2025-03-30T18:14:06.866685961 [anonymous-instance:fc_vcpu 0] Received a VcpuEvent::Resume message with immediate_exit enabled. immediate_exit was disabled before proceeding\n2025-03-30T18:14:06.866735354 [anonymous-instance:fc_vcpu 1] Received a VcpuEvent::Resume message with immediate_exit enabled. immediate_exit was disabled before proceeding\n2025-03-30T18:14:06.866773907 [anonymous-instance:main] Successfully started microvm that was configured from one single json\n[    0.000000] Linux version 6.1.132 (root@buildkitsandbox) (gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, GNU ld (GNU Binutils for Ubuntu) 2.42) #1 SMP PREEMPT_DYNAMIC Sun Mar 30 00:13:16 UTC 2025\n[    0.000000] Command line: console=ttyS0 reboot=k panic=1 pci=off loglevel=8 root=/dev/vda random.trust_cpu=on root=/dev/vda rw virtio_mmio.device=4K@0xd0000000:5 virtio_mmio.device=4K@0xd0001000:6\n[...]\n[    0.448265] EXT4-fs (vda): mounted filesystem with ordered data mode. Quota mode: none.\n[    0.449018] VFS: Mounted root (ext4 filesystem) on device 254:0.\n[    0.450006] devtmpfs: mounted\n[    0.450969] Freeing unused kernel image (initmem) memory: 2476K\n[    0.451506] Write protecting the kernel read-only data: 18432k\n[    0.453970] Freeing unused kernel image (text/rodata gap) memory: 2044K\n[    0.457003] Freeing unused kernel image (rodata/data gap) memory: 1564K\n[    0.457615] Run /sbin/init as init process\n[    0.458012]   with arguments:\n[    0.458293]     /sbin/init\n[    0.458548]   with environment:\n[    0.458845]     HOME=/\n[    0.459071]     TERM=linux\nSELinux:  Could not open policy file &lt;= /etc/selinux/targeted/policy/policy.33:  No such file or directory\n[    0.496211] systemd[1]: systemd 255.4-1ubuntu8.5 running in system mode (+PAM +AUDIT +SELINUX +APPARMOR +IMA +SMACK +SECCOMP +GCRYPT -GNUTLS +OPENSSL +ACL +BLKID +CURL +ELFUTILS +FIDO2 +IDN2 -IDN +IPTC +KMOD +LIBCRYPTSETUP +LIBFDISK +PCRE2 -PWQUALITY +P11KIT +QRENCODE +TPM2 +BZIP2 +LZ4 +XZ +ZLIB +ZSTD -BPF_FRAMEWORK -XKBCOMMON +UTMP +SYSVINIT default-hierarchy=unified)\n[    0.499091] systemd[1]: Detected virtualization kvm.\n[    0.499603] systemd[1]: Detected architecture x86-64.\n\nWelcome to Ubuntu 24.04.1 LTS!\n\n[...]\n[  OK  ] Started getty@tty1.service - Getty on tty1.\n[  OK  ] Started getty@tty2.service - Getty on tty2.\n[  OK  ] Started getty@tty3.service - Getty on tty3.\n[  OK  ] Started getty@tty4.service - Getty on tty4.\n[  OK  ] Started getty@tty5.service - Getty on tty5.\n[  OK  ] Started getty@tty6.service - Getty on tty6.\n[  OK  ] Started serial-getty@ttyS0.service - Serial Getty on ttyS0.\n[  OK  ] Reached target getty.target - Login Prompts.\n[  OK  ] Reached target multi-user.target - Multi-User System.\n[  OK  ] Reached target graphical.target - Graphical Interface.\n         Starting systemd-update-utmp-runle\u2026- Record Runlevel Change in UTMP...\n[  OK  ] Finished systemd-update-utmp-runle\u2026e - Record Runlevel Change in UTMP.\n\nUbuntu 24.04.1 LTS localhost.localdomain ttyS0\n\nlocalhost login:\n</code></pre> <p>To continue proceed to Logging In.</p>"},{"location":"tutorials/running-a-vaccel-application-on-a-vm/#cloud-hypervisor","title":"Cloud hypervisor","text":"<p>You can get the latest Cloud Hypervisor release from the official repo. Ie. to download v44.0 for amd64:</p> <pre><code>wget -O cloud-hypervisor \\\n    https://github.com/cloud-hypervisor/cloud-hypervisor/releases/download/v44.0/cloud-hypervisor-static\nchmod u+x cloud-hypervisor\n</code></pre> <p>The updated current directory should look like:</p> <pre><code>$ tree -L 1\n.\n\u251c\u2500\u2500 bzImage\n\u251c\u2500\u2500 cloud-hypervisor\n\u251c\u2500\u2500 downloads\n\u251c\u2500\u2500 linux-amd64-fc.config\n\u251c\u2500\u2500 linux-amd64.config\n\u251c\u2500\u2500 rootfs.img\n\u2514\u2500\u2500 vmlinux\n\n1 directory, 6 files\n</code></pre> <p>To launch the VM you can use:</p> <pre><code>$ ./cloud-hypervisor --kernel bzImage --disk path=rootfs.img \\\n      --cpus boot=2 --memory size=4096M \\\n      --cmdline \"console=ttyS0 root=/dev/vda rw\" \\\n      --console off --serial tty \\\n      --vsock cid=42,socket=/tmp/vaccel.sock\n[    0.000000] Linux version 6.1.132 (root@buildkitsandbox) (gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, GNU ld (GNU Binutils for Ubuntu) 2.42) #1 SMP PREEMPT_DYNAMIC Sun Mar 30 00:13:19 UTC 2025\n[    0.000000] Command line: console=ttyS0 root=/dev/vda rw\n[...]\n[    0.582493] EXT4-fs (vda): mounted filesystem with ordered data mode. Quota mode: none.\n[    0.583313] VFS: Mounted root (ext4 filesystem) on device 254:0.\n[    0.584241] devtmpfs: mounted\n[    0.585398] Freeing unused kernel image (initmem) memory: 2484K\n[    0.586013] Write protecting the kernel read-only data: 20480k\n[    0.588863] Freeing unused kernel image (text/rodata gap) memory: 2044K\n[    0.591116] Freeing unused kernel image (rodata/data gap) memory: 1524K\n[    0.591787] Run /sbin/init as init process\nSELinux:  Could not open policy file &lt;= /etc/selinux/targeted/policy/policy.33:  No such file or directory\n[    0.623287] systemd[1]: systemd 255.4-1ubuntu8.5 running in system mode (+PAM +AUDIT +SELINUX +APPARMOR +IMA +SMACK +SECCOMP +GCRYPT -GNUTLS +OPENSSL +ACL +BLKID +CURL +ELFUTILS +FIDO2 +IDN2 -IDN +IPTC +KMOD +LIBCRYPTSETUP +LIBFDISK +PCRE2 -PWQUALITY +P11KIT +QRENCODE +TPM2 +BZIP2 +LZ4 +XZ +ZLIB +ZSTD -BPF_FRAMEWORK -XKBCOMMON +UTMP +SYSVINIT default-hierarchy=unified)\n[    0.626523] systemd[1]: Detected virtualization kvm.\n[    0.627092] systemd[1]: Detected architecture x86-64.\n\nWelcome to Ubuntu 24.04.1 LTS!\n\n[...]\n[  OK  ] Started getty@tty1.service - Getty on tty1.\n[  OK  ] Started getty@tty2.service - Getty on tty2.\n[  OK  ] Started getty@tty3.service - Getty on tty3.\n[  OK  ] Started getty@tty4.service - Getty on tty4.\n[  OK  ] Started getty@tty5.service - Getty on tty5.\n[  OK  ] Started getty@tty6.service - Getty on tty6.\n[  OK  ] Started serial-getty@ttyS0.service - Serial Getty on ttyS0.\n[  OK  ] Reached target getty.target - Login Prompts.\n[  OK  ] Reached target multi-user.target - Multi-User System.\n[  OK  ] Reached target graphical.target - Graphical Interface.\n         Starting systemd-update-utmp-runle\u2026- Record Runlevel Change in UTMP...\n[  OK  ] Finished systemd-update-utmp-runle\u2026e - Record Runlevel Change in UTMP.\n\nUbuntu 24.04.1 LTS localhost.localdomain ttyS0\n\nlocalhost login:\n</code></pre> <p>To continue proceed to Logging In.</p>"},{"location":"tutorials/running-a-vaccel-application-on-a-vm/#qemu","title":"QEMU","text":"<p>To install QEMU you can use your distribution's package manager:</p> <pre><code>sudo apt install qemu\n</code></pre> <p>QEMU can emulate different machines. We will show how to boot with two common machine options.</p>"},{"location":"tutorials/running-a-vaccel-application-on-a-vm/#qemu-with-pci-support","title":"QEMU with PCI support","text":"<p>If no machine is provided, QEMU will emulate the default machine depending on the platform architecture. For x86_64 this is a machine with PCI support.</p> <p>To launch a QEMU VM with PCI support use:</p> <pre><code>$ qemu-system-x86_64 -M pc,accel=kvm -cpu host \\\n      -nographic -vga none -nic none \\\n      -smp 2 -m 4096 \\\n      -kernel bzImage \\\n      -append \"console=ttyS0 earlyprintk=ttyS0 root=/dev/vda rw \" \\\n      -drive if=none,id=rootfs,file=rootfs.img,format=raw,cache=none \\\n      -device virtio-blk,drive=rootfs \\\n      -device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=42\nSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\nBooting from ROM..\nearly console in extract_kernel\ninput_data: 0x00000000024c52c4\ninput_len: 0x00000000007949f9\noutput: 0x0000000001000000\noutput_len: 0x0000000001c1ceb8\nkernel_total_size: 0x0000000001a2c000\nneeded_size: 0x0000000001e00000\ntrampoline_32bit: 0x0000000000000000\nPhysical KASLR using RDRAND RDTSC...\nVirtual KASLR using RDRAND RDTSC...\n\nDecompressing Linux... Parsing ELF... Performing relocations... done.\nBooting the kernel (entry_offset: 0x0000000000000000).\n[    0.000000] Linux version 6.1.132 (root@buildkitsandbox) (gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, GNU ld (GNU Binutils for Ubuntu) 2.42) #1 SMP PREEMPT_DYNAMIC Sun Mar 30 00:13:19 UTC 2025\n[    0.000000] Command line: console=ttyS0 root=/dev/vda rw\n[...]\n[    0.582493] EXT4-fs (vda): mounted filesystem with ordered data mode. Quota mode: none.\n[    0.583313] VFS: Mounted root (ext4 filesystem) on device 254:0.\n[    0.584241] devtmpfs: mounted\n[    0.585398] Freeing unused kernel image (initmem) memory: 2484K\n[    0.586013] Write protecting the kernel read-only data: 20480k\n[    0.588863] Freeing unused kernel image (text/rodata gap) memory: 2044K\n[    0.591116] Freeing unused kernel image (rodata/data gap) memory: 1524K\n[    0.591787] Run /sbin/init as init process\nSELinux:  Could not open policy file &lt;= /etc/selinux/targeted/policy/policy.33:  No such file or directory\n[    0.623287] systemd[1]: systemd 255.4-1ubuntu8.5 running in system mode (+PAM +AUDIT +SELINUX +APPARMOR +IMA +SMACK +SECCOMP +GCRYPT -GNUTLS +OPENSSL +ACL +BLKID +CURL +ELFUTILS +FIDO2 +IDN2 -IDN +IPTC +KMOD +LIBCRYPTSETUP +LIBFDISK +PCRE2 -PWQUALITY +P11KIT +QRENCODE +TPM2 +BZIP2 +LZ4 +XZ +ZLIB +ZSTD -BPF_FRAMEWORK -XKBCOMMON +UTMP +SYSVINIT default-hierarchy=unified)\n[    0.626523] systemd[1]: Detected virtualization kvm.\n[    0.627092] systemd[1]: Detected architecture x86-64.\n\nWelcome to Ubuntu 24.04.1 LTS!\n\n[...]\n[  OK  ] Started getty@tty1.service - Getty on tty1.\n[  OK  ] Started getty@tty2.service - Getty on tty2.\n[  OK  ] Started getty@tty3.service - Getty on tty3.\n[  OK  ] Started getty@tty4.service - Getty on tty4.\n[  OK  ] Started getty@tty5.service - Getty on tty5.\n[  OK  ] Started getty@tty6.service - Getty on tty6.\n[  OK  ] Started serial-getty@ttyS0.service - Serial Getty on ttyS0.\n[  OK  ] Reached target getty.target - Login Prompts.\n[  OK  ] Reached target multi-user.target - Multi-User System.\n[  OK  ] Reached target graphical.target - Graphical Interface.\n         Starting systemd-update-utmp-runle\u2026- Record Runlevel Change in UTMP...\n[  OK  ] Finished systemd-update-utmp-runle\u2026e - Record Runlevel Change in UTMP.\n\nUbuntu 24.04.1 LTS localhost.localdomain ttyS0\n\nlocalhost login:\n</code></pre> <p>To continue proceed to Logging In.</p>"},{"location":"tutorials/running-a-vaccel-application-on-a-vm/#qemu-microvm-nopci","title":"QEMU microVM, noPCI","text":"<p>Current versions of QEMU provide a microVM machine with no PCI support, meant to be used as a lightweight alternative to the default machine. This target aims to provide and experience similar to Firecracker.</p> <p>To launch a QEMU microVM (with no PCI support) use:</p> <pre><code>$ qemu-system-x86_64 -M microvm,accel=kvm -cpu host \\\n      -nographic -vga none -nic none \\\n      -smp 2 -m 4096 \\\n      -kernel bzImage \\\n      -append \"console=ttyS0 earlyprintk=ttyS0 root=/dev/vda rw \" \\\n      -drive if=none,id=rootfs,file=rootfs.img,format=raw,cache=none \\\n      -device virtio-blk-device,drive=rootfs \\\n      -device vhost-vsock-device,id=vhost-vsock,guest-cid=42\nSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\nBooting from ROM..\nearly console in extract_kernel\ninput_data: 0x00000000024c52c4\ninput_len: 0x00000000007949f9\noutput: 0x0000000001000000\noutput_len: 0x0000000001c1ceb8\nkernel_total_size: 0x0000000001a2c000\nneeded_size: 0x0000000001e00000\ntrampoline_32bit: 0x0000000000000000\nPhysical KASLR using RDRAND RDTSC...\nVirtual KASLR using RDRAND RDTSC...\n\nDecompressing Linux... Parsing ELF... Performing relocations... done.\nBooting the kernel (entry_offset: 0x0000000000000000).\n[    0.000000] Linux version 6.1.132 (root@buildkitsandbox) (gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, GNU ld (GNU Binutils for Ubuntu) 2.42) #1 SMP PREEMPT_DYNAMIC Sun Mar 30 00:13:19 UTC 2025\n[    0.000000] Command line: console=ttyS0 earlyprintk=ttyS0 root=/dev/vda rw\n[...]\n[    0.203882] VFS: Mounted root (ext4 filesystem) on device 254:0.\n[    0.205666] devtmpfs: mounted\n[    0.206459] Freeing unused kernel image (initmem) memory: 2484K\n[    0.207052] Write protecting the kernel read-only data: 20480k\n[    0.208129] Freeing unused kernel image (text/rodata gap) memory: 2044K\n[    0.209050] Freeing unused kernel image (rodata/data gap) memory: 1524K\n[    0.209702] Run /sbin/init as init process\nSELinux:  Could not open policy file &lt;= /etc/selinux/targeted/policy/policy.33:  No such file or directory\n[    0.316715] systemd[1]: systemd 255.4-1ubuntu8.5 running in system mode (+PAM +AUDIT +SELINUX +APPARMOR +IMA +SMAC)\n[    0.319763] systemd[1]: Detected virtualization kvm.\n[    0.320270] systemd[1]: Detected architecture x86-64.\n\nWelcome to Ubuntu 24.04.1 LTS!\n\n[...]\n[  OK  ] Started getty@tty1.service - Getty on tty1.\n[  OK  ] Started getty@tty2.service - Getty on tty2.\n[  OK  ] Started getty@tty3.service - Getty on tty3.\n[  OK  ] Started getty@tty4.service - Getty on tty4.\n[  OK  ] Started getty@tty5.service - Getty on tty5.\n[  OK  ] Started getty@tty6.service - Getty on tty6.\n[  OK  ] Started serial-getty@ttyS0.service - Serial Getty on ttyS0.\n[  OK  ] Reached target getty.target - Login Prompts.\n[  OK  ] Reached target multi-user.target - Multi-User System.\n[  OK  ] Reached target graphical.target - Graphical Interface.\n         Starting systemd-update-utmp-runle\u2026- Record Runlevel Change in UTMP...\n[  OK  ] Finished systemd-update-utmp-runle\u2026e - Record Runlevel Change in UTMP.\n\nUbuntu 24.04.1 LTS localhost.localdomain ttyS0\n\nlocalhost login:\n</code></pre>"},{"location":"tutorials/running-a-vaccel-application-on-a-vm/#logging-in","title":"Logging in","text":"<p>Since the provided image is meant for testing purposes the default user is <code>root</code>. To log in use <code>root</code> (no password required). You should be greeted with:</p> <pre><code>Welcome to Ubuntu 24.04.1 LTS (GNU/Linux 6.1.132 x86_64)\n\n * Documentation:  https://help.ubuntu.com\n * Management:     https://landscape.canonical.com\n * Support:        https://ubuntu.com/pro\n\nThis system has been minimized by removing packages and content that are\nnot required on a system that users do not log into.\n\nTo restore this content, you can run the 'unminimize' command.\n\nThe programs included with the Ubuntu system are free software;\nthe exact distribution terms for each program are described in the\nindividual files in /usr/share/doc/*/copyright.\n\nUbuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by\napplicable law.\n\nroot@localhost:~#\n</code></pre> <p>You can verify all required libraries are installed by looking at <code>/usr/local/lib/x86_64-linux-gnu</code>:</p> <pre><code># ls /usr/local/lib/x86_64-linux-gnu/\nlibmytestlib.so            libvaccel-noop.so.0        libvaccel-virtio.so\nlibvaccel-exec.so          libvaccel-noop.so.0.6.1    libvaccel-virtio.so.0\nlibvaccel-exec.so.0        libvaccel-python.so        libvaccel-virtio.so.0.1.0\nlibvaccel-exec.so.0.6.1    libvaccel-python.so.0      libvaccel.so\nlibvaccel-mbench.so        libvaccel-python.so.0.6.1  libvaccel.so.0\nlibvaccel-mbench.so.0      libvaccel-rpc.so           libvaccel.so.0.6.1\nlibvaccel-mbench.so.0.6.1  libvaccel-rpc.so.0         pkgconfig\nlibvaccel-noop.so          libvaccel-rpc.so.0.1.0\n</code></pre>"},{"location":"tutorials/running-a-vaccel-application-on-a-vm/#running-the-vaccel-rpc-agent","title":"Running the vAccel RPC agent","text":"<p>Before running a vAccel application on the guest, you need to first start the vAccel RPC agent. Since the VM console should be open in the current terminal by now, you will have to open a new terminal to execute the agent.</p> <p>Depending on the VMM being used, you have to set a valid RPC address for the agent. Firecracker and Cloud Hypervisor use a \"hybrid\" <code>unix</code> socket for vSock communication, while QEMU expects a proper <code>vsock</code> socket.</p> <p>To use <code>vaccel-rpc-agent</code> for the above Firecracker/Cloud Hypervisor setups use:</p> <pre><code>export VACCEL_RPC_ADDRESS=\"unix:///tmp/vaccel.sock_2048\"\n</code></pre> <p>where <code>/tmp/vaccel.sock</code> is the VMM's vsock socket we have configured in the previous steps.</p> <p>For QEMU, the variable should be set to:</p> <pre><code>export VACCEL_RPC_ADDRESS=\"vsock://2:2048\"\n</code></pre> <p>where <code>2</code> is the well-known vSock address of the host.</p> <p>For both cases, <code>2048</code> is the port number we have configured in the previous steps for the VMM.</p> <p>Since the agent will instantiate the host vAccel, you also need to configure vAccel in this step. You can configure vAccel by setting the related environment variables - as you would do for a plugin - or you can use the <code>vaccel-rpc-agent</code>'s CLI (preferred).</p> <p>Since the 'NoOp' plugin is included with vAccel, we will use this as the acceleration plugin for demonstration purposes.</p> <p>To start a <code>vaccel-rpc-agent</code> with the vAccel <code>NoOp</code> plugin use:</p> <pre><code>$ VACCEL_BOOTSTRAP_ENABLED=0 vaccel-rpc-agent \\\n      -a \"${VACCEL_RPC_ADDRESS}\" \\\n      --vaccel-config \"plugins=libvaccel-noop.so,log_level=4\"\n2025.04.08-19:34:05.40 - &lt;debug&gt; Initializing vAccel\n2025.04.08-19:34:05.40 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.08-19:34:05.40 - &lt;debug&gt; Config:\n2025.04.08-19:34:05.40 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.08-19:34:05.40 - &lt;debug&gt;   log_level = debug\n2025.04.08-19:34:05.40 - &lt;debug&gt;   log_file = (null)\n2025.04.08-19:34:05.40 - &lt;debug&gt;   profiling_enabled = false\n2025.04.08-19:34:05.40 - &lt;debug&gt;   version_ignore = false\n2025.04.08-19:34:05.40 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/j1Kwrv\n2025.04.08-19:34:05.40 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op noop from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op blas_sgemm from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op image_classify from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op image_detect from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op image_segment from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op image_pose from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op image_depth from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op exec from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op tf_session_load from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op tf_session_run from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op tf_session_delete from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op minmax from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op fpga_arraycopy from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op fpga_vectoradd from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op fpga_parallel from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op fpga_mmult from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op exec_with_resource from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op torch_jitload_forward from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op torch_sgemm from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op opencv from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op tflite_session_load from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op tflite_session_run from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Registered op tflite_session_delete from plugin noop\n2025.04.08-19:34:05.40 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n[2025-04-08T19:34:05Z INFO  ttrpc::sync::server] server listen started\n[2025-04-08T19:34:05Z INFO  ttrpc::sync::server] server started\n[2025-04-08T19:34:05Z INFO  vaccel_rpc_agent] vAccel RPC agent started\n[2025-04-08T19:34:05Z INFO  vaccel_rpc_agent] Listening on 'vsock://2:2048', press Ctrl+C to exit\n</code></pre>"},{"location":"tutorials/running-a-vaccel-application-on-a-vm/#running-the-application-on-the-guest","title":"Running the application on the guest","text":"<p>With the vAccel RPC agent running, you are ready to execute the application in the VM.</p> <p>Switching back to the initial terminal, you need to first configure the RPC address that will be used by the plugin:</p> <pre><code>export VACCEL_RPC_ADDRESS=\"vsock://2:2048\"\n</code></pre> <p>where <code>2</code> is the well-known vSock address of the host and this address is common for all the VMMs we have setup above.</p> <p>Next, you have to configure vAccel to use the plugin:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-rpc.so\n</code></pre> <p>Optionally, to get debug output:</p> <pre><code>export VACCEL_LOG_LEVEL=4\n</code></pre> <p>Finally, you can run an image classification example with:</p> <pre><code># classify /usr/local/share/vaccel/images/example.jpg 1\n2025.04.08-19:34:48.28 - &lt;debug&gt; Initializing vAccel\n2025.04.08-19:34:48.28 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.08-19:34:48.28 - &lt;debug&gt; Config:\n2025.04.08-19:34:48.28 - &lt;debug&gt;   plugins = libvaccel-rpc.so\n2025.04.08-19:34:48.28 - &lt;debug&gt;   log_level = debug\n2025.04.08-19:34:48.28 - &lt;debug&gt;   log_file = (null)\n2025.04.08-19:34:48.28 - &lt;debug&gt;   profiling_enabled = false\n2025.04.08-19:34:48.28 - &lt;debug&gt;   version_ignore = false\n2025.04.08-19:34:48.28 - &lt;debug&gt; Created top-level rundir: /run/user/0/vaccel/JE4UiS\n2025.04.08-19:34:48.30 - &lt;info&gt; Registered plugin rpc 0.1.0-36-bbffdae6\n2025.04.08-19:34:48.30 - &lt;debug&gt; rpc is a VirtIO module\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op blas_sgemm from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op image_classify from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op image_detect from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op image_segment from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op image_depth from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op image_pose from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op tflite_session_load from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op tflite_session_delete from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op tflite_session_run from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op minmax from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op fpga_arraycopy from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op fpga_mmult from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op fpga_vectoradd from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op fpga_parallel from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op exec from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op exec_with_resource from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op torch_jitload_forward from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op opencv from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op tf_session_load from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op tf_session_delete from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Registered op tf_session_run from plugin rpc\n2025.04.08-19:34:48.30 - &lt;debug&gt; Loaded plugin rpc from libvaccel-rpc.so\n2025.04.08-19:34:48.31 - &lt;debug&gt; [rpc] Initializing new remote session\n2025.04.08-19:34:48.34 - &lt;debug&gt; [rpc] Initialized remote session 1\n2025.04.08-19:34:48.34 - &lt;debug&gt; New rundir for session 1: /run/user/0/vaccel/JE4UiS/session.1\n2025.04.08-19:34:48.34 - &lt;debug&gt; Initialized session 1 with remote (id: 1)\nInitialized session with id: 1\n2025.04.08-19:34:48.34 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.08-19:34:48.34 - &lt;debug&gt; Returning func from hint plugin rpc\n2025.04.08-19:34:48.34 - &lt;debug&gt; Found implementation in rpc plugin\nclassification tags: This is a dummy classification tag!\nclassification imagename: This is a dummy imgname!\n2025.04.08-19:34:48.35 - &lt;debug&gt; [rpc] Releasing remote session 1\n2025.04.08-19:34:48.35 - &lt;debug&gt; Released session 1\n2025.04.08-19:34:48.35 - &lt;debug&gt; Cleaning up vAccel\n2025.04.08-19:34:48.35 - &lt;debug&gt; Cleaning up sessions\n2025.04.08-19:34:48.35 - &lt;debug&gt; Cleaning up resources\n2025.04.08-19:34:48.35 - &lt;debug&gt; Cleaning up plugins\n2025.04.08-19:34:48.35 - &lt;debug&gt; Unregistered plugin rpc\n</code></pre> <p>In the other terminal, where the vAccel RPC agent is running, you should also see the corresponding host vAccel output:</p> <pre><code>2025.04.08-19:34:48.36 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/j1Kwrv/session.1\n2025.04.08-19:34:48.36 - &lt;debug&gt; Initialized session 1\n[2025-04-08T19:34:48Z INFO  vaccel_rpc_agent::session] Created session 1\n[2025-04-08T19:34:48Z INFO  vaccel_rpc_agent::ops::genop] Genop session 1\n2025.04.08-19:34:48.37 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.08-19:34:48.37 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.08-19:34:48.37 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] model: (null)\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] len_out_text: 512\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] len_out_imgname: 512\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.08-19:34:48.38 - &lt;debug&gt; Released session 1\n[2025-04-08T19:34:48Z INFO  vaccel_rpc_agent::session] Destroyed session 1\n</code></pre> <p>If you compare the application output with the native execution case ignoring the vAccel log messages, you will notice that it is identical:</p> <pre><code># classify /usr/local/share/vaccel/images/example.jpg 1\n...\nInitialized session with id: 1\n...\nclassification tags: This is a dummy classification tag!\nclassification imagename: This is a dummy imgname!\n...\n</code></pre> <p>The debug log messages reveal that in the native execution case the <code>NoOp</code> plugin is used directly:</p> <pre><code>$ classify /usr/local/share/vaccel/images/example.jpg 1\n2025.04.03-15:44:04.61 - &lt;debug&gt; Initializing vAccel\n2025.04.03-15:44:04.61 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.03-15:44:04.61 - &lt;debug&gt; Config:\n2025.04.03-15:44:04.61 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.03-15:44:04.61 - &lt;debug&gt;   log_level = debug\n2025.04.03-15:44:04.61 - &lt;debug&gt;   log_file = (null)\n2025.04.03-15:44:04.61 - &lt;debug&gt;   profiling_enabled = false\n2025.04.03-15:44:04.61 - &lt;debug&gt;   version_ignore = false\n2025.04.03-15:44:04.61 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/VC0Gxz\n2025.04.03-15:44:04.61 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n...\n2025.04.03-15:44:04.61 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n...\n2025.04.03-15:44:04.62 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.03-15:44:04.62 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] model: (null)\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] len_out_text: 512\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] len_out_imgname: 512\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] will return a dummy result\n</code></pre> <p>whereas in the VM case, the <code>RPC</code> plugin is used on the guest:</p> <pre><code># classify /usr/local/share/vaccel/images/example.jpg 1\n2025.04.08-19:34:48.28 - &lt;debug&gt; Initializing vAccel\n2025.04.08-19:34:48.28 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.08-19:34:48.28 - &lt;debug&gt; Config:\n2025.04.08-19:34:48.28 - &lt;debug&gt;   plugins = libvaccel-rpc.so\n2025.04.08-19:34:48.28 - &lt;debug&gt;   log_level = debug\n2025.04.08-19:34:48.28 - &lt;debug&gt;   log_file = (null)\n2025.04.08-19:34:48.28 - &lt;debug&gt;   profiling_enabled = false\n2025.04.08-19:34:48.28 - &lt;debug&gt;   version_ignore = false\n2025.04.08-19:34:48.28 - &lt;debug&gt; Created top-level rundir: /run/user/0/vaccel/JE4UiS\n2025.04.08-19:34:48.30 - &lt;info&gt; Registered plugin rpc 0.1.0-36-bbffdae6\n...\n2025.04.08-19:34:48.30 - &lt;debug&gt; Loaded plugin rpc from libvaccel-rpc.so\n2025.04.08-19:34:48.31 - &lt;debug&gt; [rpc] Initializing new remote session\n2025.04.08-19:34:48.34 - &lt;debug&gt; [rpc] Initialized remote session 1\n...\n2025.04.08-19:34:48.34 - &lt;debug&gt; Returning func from hint plugin rpc\n2025.04.08-19:34:48.34 - &lt;debug&gt; Found implementation in rpc plugin\n...\n2025.04.08-19:34:48.35 - &lt;debug&gt; [rpc] Releasing remote session 1\n...\n</code></pre> <p>while the <code>NoOp</code> plugin is used on the host:</p> <pre><code>2025.04.08-19:34:05.40 - &lt;debug&gt; Initializing vAccel\n2025.04.08-19:34:05.40 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.08-19:34:05.40 - &lt;debug&gt; Config:\n2025.04.08-19:34:05.40 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.08-19:34:05.40 - &lt;debug&gt;   log_level = debug\n2025.04.08-19:34:05.40 - &lt;debug&gt;   log_file = (null)\n2025.04.08-19:34:05.40 - &lt;debug&gt;   profiling_enabled = false\n2025.04.08-19:34:05.40 - &lt;debug&gt;   version_ignore = false\n2025.04.08-19:34:05.40 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/j1Kwrv\n2025.04.08-19:34:05.40 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n...\n2025.04.08-19:34:05.40 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n...\n2025.04.08-19:34:48.37 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.08-19:34:48.37 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] model: (null)\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] len_out_text: 512\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] len_out_imgname: 512\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.08-19:34:48.37 - &lt;debug&gt; [noop] will return a dummy result\n...\n</code></pre>"},{"location":"tutorials/running-a-vaccel-application-remotely/","title":"Running a vAccel application remotely","text":""},{"location":"tutorials/running-a-vaccel-application-remotely/#overview","title":"Overview","text":"<p>As with the VM case, you can use the <code>RPC</code> plugin to run a vAccel application remotely. In this scenario, the plugin forwards function calls to a remote system. Figure 1 shows the execution flow:</p> <p> </p> <p>Figure 1. vAccel remote execution flow  </p> <p>The application runs on the <code>Remote Host</code> and uses the <code>RPC</code> plugin, while vAccel RPC agent runs on the host with hardware acceleration support and uses vAccel with an acceleration plugin.</p> <p>Similarly to executing an application from a VM, the following components must be in place to use the <code>RPC</code> plugin:</p> <ol> <li>Host: The vAccel RPC agent + vAccel + an acceleration plugin, to handle the    forwarded calls and perform the actual acceleration</li> <li>Remote host: vAccel + the <code>RPC</code> plugin, to forward the application calls</li> </ol>"},{"location":"tutorials/running-a-vaccel-application-remotely/#preparing-the-host","title":"Preparing the host","text":"<p>If you have not already installed vAccel, install it from binaries or from source. The rest of this guide assumes vAccel libraries exist in the standard library search paths.</p>"},{"location":"tutorials/running-a-vaccel-application-remotely/#installing-vaccel-rpc-agent","title":"Installing vAccel RPC agent","text":"<p>vAccel RPC agent will handle the RPC requests and forward calls to the host vAccel instance. You can find more information on how to install the <code>vaccel-rpc-agent</code> binary at the relevant section.</p>"},{"location":"tutorials/running-a-vaccel-application-remotely/#preparing-the-remote-host","title":"Preparing the remote host","text":"<p>As with the host above, the remote host should also have vAccel installed and the libraries should be in the standard library search paths.</p>"},{"location":"tutorials/running-a-vaccel-application-remotely/#installing-the-rpc-plugin","title":"Installing the <code>RPC</code> plugin","text":"<p>You can find instructions on how to install the <code>RPC</code> plugin in the relevant section. The rest of this guide assumes the plugin exists in the standard library search paths.</p>"},{"location":"tutorials/running-a-vaccel-application-remotely/#running-the-vaccel-rpc-agent","title":"Running the vAccel RPC agent","text":"<p>Before executing the remote application, the agent must be running on the host. The first thing to set is the address <code>vaccel-rpc-agent</code> will listen on:</p> <pre><code>export VACCEL_RPC_ADDRESS=\"tcp://0.0.0.0:65500\"\n</code></pre> <p>This configures the agent to listen on the <code>65500</code> TCP port and all IPv4 addresses. You can replace the IP and the port above with the desired ones.</p> <p>Since the agent will instantiate the host vAccel, you also need to configure vAccel in this step. You can configure vAccel by setting the related environment variables - as you would do for a plugin - or you can use the <code>vaccel-rpc-agent</code>'s CLI (preferred).</p> <p>Since the 'NoOp' plugin is included with vAccel, we will use this as the acceleration plugin for demonstration purposes.</p> <p>To start a <code>vaccel-rpc-agent</code> with the vAccel <code>NoOp</code> plugin use:</p> <pre><code>$ VACCEL_BOOTSTRAP_ENABLED=0 vaccel-rpc-agent \\\n      -a \"${VACCEL_RPC_ADDRESS}\" \\\n      --vaccel-config \"plugins=libvaccel-noop.so,log_level=4\"\n2025.04.07-17:19:53.56 - &lt;debug&gt; Initializing vAccel\n2025.04.07-17:19:53.56 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.07-17:19:53.56 - &lt;debug&gt; Config:\n2025.04.07-17:19:53.56 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.07-17:19:53.56 - &lt;debug&gt;   log_level = debug\n2025.04.07-17:19:53.56 - &lt;debug&gt;   log_file = (null)\n2025.04.07-17:19:53.56 - &lt;debug&gt;   profiling_enabled = false\n2025.04.07-17:19:53.56 - &lt;debug&gt;   version_ignore = false\n2025.04.07-17:19:53.56 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/YvIPeM\n2025.04.07-17:19:53.56 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op noop from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op blas_sgemm from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op image_classify from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op image_detect from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op image_segment from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op image_pose from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op image_depth from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op exec from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op tf_session_load from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op tf_session_run from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op tf_session_delete from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op minmax from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op fpga_arraycopy from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op fpga_vectoradd from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op fpga_parallel from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op fpga_mmult from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op exec_with_resource from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op torch_jitload_forward from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op torch_sgemm from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op opencv from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op tflite_session_load from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op tflite_session_run from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Registered op tflite_session_delete from plugin noop\n2025.04.07-17:19:53.56 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n[2025-04-07T17:19:53Z INFO  ttrpc::sync::server] server listen started\n[2025-04-07T17:19:53Z INFO  ttrpc::sync::server] server started\n[2025-04-07T17:19:53Z INFO  vaccel_rpc_agent] vAccel RPC agent started\n[2025-04-07T17:19:53Z INFO  vaccel_rpc_agent] Listening on 'tcp://0.0.0.0:65500', press Ctrl+C to exit\n</code></pre>"},{"location":"tutorials/running-a-vaccel-application-remotely/#running-the-application-on-the-remote-host","title":"Running the application on the remote host","text":"<p>With the vAccel RPC agent running, you are ready to execute the application in the remote host.</p> <p>On the remote host, you need to first configure the RPC address that will be used by the plugin - replace <code>192.0.2.1</code> with the IP address of the host running the vAccel RPC agent:</p> <pre><code>export VACCEL_RPC_ADDRESS=\"tcp://192.0.2.1:65500\"\n</code></pre> <p>The port must be the same port you have used for starting the agent.</p> <p>Next, configure vAccel to use the <code>RPC</code> plugin:</p> <pre><code>export VACCEL_PLUGINS=libvaccel-rpc.so\n</code></pre> <p>Optionally, to get debug output:</p> <pre><code>export VACCEL_LOG_LEVEL=4\n</code></pre> <p>Finally, you can run an image classification example with:</p> <pre><code>$ classify /usr/local/share/vaccel/images/example.jpg 1\n2025.04.07-17:23:51.51 - &lt;debug&gt; Initializing vAccel\n2025.04.07-17:23:51.51 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.07-17:23:51.51 - &lt;debug&gt; Config:\n2025.04.07-17:23:51.51 - &lt;debug&gt;   plugins = /usr/local/lib/x86_64-linux-gnu/libvaccel-rpc.so\n2025.04.07-17:23:51.51 - &lt;debug&gt;   log_level = debug\n2025.04.07-17:23:51.51 - &lt;debug&gt;   log_file = (null)\n2025.04.07-17:23:51.51 - &lt;debug&gt;   profiling_enabled = false\n2025.04.07-17:23:51.51 - &lt;debug&gt;   version_ignore = false\n2025.04.07-17:23:51.51 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/2Qc6ZB\n2025.04.07-17:23:51.51 - &lt;info&gt; Registered plugin rpc 0.1.0-36-bbffdae6\n2025.04.07-17:23:51.51 - &lt;debug&gt; rpc is a VirtIO module\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op blas_sgemm from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op image_classify from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op image_detect from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op image_segment from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op image_depth from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op image_pose from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op tflite_session_load from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op tflite_session_delete from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op tflite_session_run from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op minmax from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op fpga_arraycopy from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op fpga_mmult from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op fpga_vectoradd from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op fpga_parallel from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op exec from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op exec_with_resource from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op torch_jitload_forward from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op opencv from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op tf_session_load from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op tf_session_delete from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Registered op tf_session_run from plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Loaded plugin rpc from /usr/local/lib/x86_64-linux-gnu/libvaccel-rpc.so\n2025.04.07-17:23:51.51 - &lt;debug&gt; [rpc] Initializing new remote session\n2025.04.07-17:23:51.51 - &lt;debug&gt; [rpc] Initialized remote session 1\n2025.04.07-17:23:51.51 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/2Qc6ZB/session.1\n2025.04.07-17:23:51.51 - &lt;debug&gt; Initialized session 1 with remote (id: 1)\nInitialized session with id: 1\n2025.04.07-17:23:51.51 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.07-17:23:51.51 - &lt;debug&gt; Returning func from hint plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Found implementation in rpc plugin\nclassification tags: This is a dummy classification tag!\nclassification imagename: This is a dummy imgname!\n2025.04.07-17:23:51.55 - &lt;debug&gt; [rpc] Releasing remote session 1\n2025.04.07-17:23:51.64 - &lt;debug&gt; Released session 1\n2025.04.07-17:23:51.64 - &lt;debug&gt; Cleaning up vAccel\n2025.04.07-17:23:51.64 - &lt;debug&gt; Cleaning up sessions\n2025.04.07-17:23:51.64 - &lt;debug&gt; Cleaning up resources\n2025.04.07-17:23:51.64 - &lt;debug&gt; Cleaning up plugins\n2025.04.07-17:23:51.64 - &lt;debug&gt; Unregistered plugin rpc\n</code></pre> <p>In the host terminal, where the vAccel RPC agent is running, you should also see the corresponding host vAccel output:</p> <pre><code>2025.04.07-17:23:51.51 - &lt;debug&gt; New rundir for session 1: /run/user/1002/vaccel/YvIPeM/session.1\n2025.04.07-17:23:51.51 - &lt;debug&gt; Initialized session 1\n[2025-04-07T17:23:51Z INFO  vaccel_rpc_agent::session] Created session 1\n[2025-04-07T17:23:51Z INFO  vaccel_rpc_agent::ops::genop] Genop session 1\n2025.04.07-17:23:51.51 - &lt;debug&gt; session:1 Looking for plugin implementing VACCEL_OP_IMAGE_CLASSIFY\n2025.04.07-17:23:51.51 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.07-17:23:51.51 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] model: (null)\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] len_out_text: 512\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] len_out_imgname: 512\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.07-17:23:51.60 - &lt;debug&gt; Released session 1\n[2025-04-07T17:23:51Z INFO  vaccel_rpc_agent::session] Destroyed session 1\n</code></pre> <p>If you compare the application output with the native execution case ignoring the vAccel log messages, you will notice that it is identical:</p> <pre><code># classify /usr/local/share/vaccel/images/example.jpg 1\n...\nInitialized session with id: 1\n...\nclassification tags: This is a dummy classification tag!\nclassification imagename: This is a dummy imgname!\n...\n</code></pre> <p>The debug log messages reveal that in the native execution case the <code>NoOp</code> plugin is used directly:</p> <pre><code>$ classify /usr/local/share/vaccel/images/example.jpg 1\n2025.04.03-15:44:04.61 - &lt;debug&gt; Initializing vAccel\n2025.04.03-15:44:04.61 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.03-15:44:04.61 - &lt;debug&gt; Config:\n2025.04.03-15:44:04.61 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.03-15:44:04.61 - &lt;debug&gt;   log_level = debug\n2025.04.03-15:44:04.61 - &lt;debug&gt;   log_file = (null)\n2025.04.03-15:44:04.61 - &lt;debug&gt;   profiling_enabled = false\n2025.04.03-15:44:04.61 - &lt;debug&gt;   version_ignore = false\n2025.04.03-15:44:04.61 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/VC0Gxz\n2025.04.03-15:44:04.61 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n...\n2025.04.03-15:44:04.61 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n...\n2025.04.03-15:44:04.62 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.03-15:44:04.62 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] model: (null)\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] len_out_text: 512\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] len_out_imgname: 512\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.03-15:44:04.62 - &lt;debug&gt; [noop] will return a dummy result\n</code></pre> <p>whereas in the the remote execution case, the <code>RPC</code> plugin is used on the remote host:</p> <pre><code>$ classify /usr/local/share/vaccel/images/example.jpg 1\n2025.04.07-17:23:51.51 - &lt;debug&gt; Initializing vAccel\n2025.04.07-17:23:51.51 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.07-17:23:51.51 - &lt;debug&gt; Config:\n2025.04.07-17:23:51.51 - &lt;debug&gt;   plugins = /usr/local/lib/x86_64-linux-gnu/libvaccel-rpc.so\n2025.04.07-17:23:51.51 - &lt;debug&gt;   log_level = debug\n2025.04.07-17:23:51.51 - &lt;debug&gt;   log_file = (null)\n2025.04.07-17:23:51.51 - &lt;debug&gt;   profiling_enabled = false\n2025.04.07-17:23:51.51 - &lt;debug&gt;   version_ignore = false\n2025.04.07-17:23:51.51 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/2Qc6ZB\n2025.04.07-17:23:51.51 - &lt;info&gt; Registered plugin rpc 0.1.0-36-bbffdae6\n2025.04.07-17:23:51.51 - &lt;debug&gt; rpc is a VirtIO module\n...\n2025.04.07-17:23:51.51 - &lt;debug&gt; Loaded plugin rpc from /usr/local/lib/x86_64-linux-gnu/libvaccel-rpc.so\n2025.04.07-17:23:51.51 - &lt;debug&gt; [rpc] Initializing new remote session\n2025.04.07-17:23:51.51 - &lt;debug&gt; [rpc] Initialized remote session 1\n...\n2025.04.07-17:23:51.51 - &lt;debug&gt; Returning func from hint plugin rpc\n2025.04.07-17:23:51.51 - &lt;debug&gt; Found implementation in rpc plugin\n...\n2025.04.07-17:23:51.55 - &lt;debug&gt; [rpc] Releasing remote session 1\n</code></pre> <p>while the <code>NoOp</code> plugin is used on the host:</p> <pre><code>$ VACCEL_BOOTSTRAP_ENABLED=0 vaccel-rpc-agent \\\n      -a \"${VACCEL_RPC_ADDRESS}\" \\\n      --vaccel-config \"plugins=libvaccel-noop.so,log_level=4\"\n2025.04.07-17:19:53.56 - &lt;debug&gt; Initializing vAccel\n2025.04.07-17:19:53.56 - &lt;info&gt; vAccel 0.6.1-194-19056528\n2025.04.07-17:19:53.56 - &lt;debug&gt; Config:\n2025.04.07-17:19:53.56 - &lt;debug&gt;   plugins = libvaccel-noop.so\n2025.04.07-17:19:53.56 - &lt;debug&gt;   log_level = debug\n2025.04.07-17:19:53.56 - &lt;debug&gt;   log_file = (null)\n2025.04.07-17:19:53.56 - &lt;debug&gt;   profiling_enabled = false\n2025.04.07-17:19:53.56 - &lt;debug&gt;   version_ignore = false\n2025.04.07-17:19:53.56 - &lt;debug&gt; Created top-level rundir: /run/user/1002/vaccel/YvIPeM\n2025.04.07-17:19:53.56 - &lt;info&gt; Registered plugin noop 0.6.1-194-19056528\n...\n2025.04.07-17:19:53.56 - &lt;debug&gt; Loaded plugin noop from libvaccel-noop.so\n...\n2025.04.07-17:23:51.51 - &lt;debug&gt; Returning func from hint plugin noop\n2025.04.07-17:23:51.51 - &lt;debug&gt; Found implementation in noop plugin\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] Calling Image classification for session 1\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] Dumping arguments for Image classification:\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] model: (null)\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] len_img: 79281\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] len_out_text: 512\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] len_out_imgname: 512\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] will return a dummy result\n2025.04.07-17:23:51.51 - &lt;debug&gt; [noop] will return a dummy result\n</code></pre>"},{"location":"tutorials/writing-your-first-plugin/","title":"Writing your first plugin","text":"<p>vAccel plugins provide the glue code between vAccel User API operations and their hardware implementations. A vAccel plugin is a shared object, built in any programming language that can generate it.</p> <p>The required operations that need to be implemented for a shared object to be linked as a vAccel plugin, are the following:</p> <ul> <li> <p>An <code>init()</code> function, called upon plugin initialization</p> <pre><code>static int init(void) {\n...\n}\n</code></pre> </li> <li> <p>A <code>fini()</code> function, called before unloading the plugin</p> <pre><code>static int fini(void) {\n...\n}\n</code></pre> </li> <li> <p>A definition of the <code>VACCEL_PLUGIN</code> with:</p> <ul> <li><code>.name</code> : The name of the plugin</li> <li><code>.version</code> : The version of the plugin</li> <li><code>.vaccel_version</code> : The vAccel library version that the plugin was built   against</li> <li><code>.init</code> : The function to call upon plugin initialization (eg. <code>init()</code>)</li> <li><code>.fini</code> : The function to call before unloading the plugin (eg. on program   exit, <code>fini()</code>)</li> </ul> <pre><code>VACCEL_PLUGIN(\n    .name = \"vAccel template plugin\",\n    .version = \"0.9\",\n    .vaccel_version = VACCEL_VERSION,\n    .init = init,\n    .fini = fini\n)\n</code></pre> </li> </ul> <p>At initialization, the plugin needs to register the vAccel operations that it implements. To do that, we use an array of <code>struct vaccel_op</code>s, that map each function implementation to the respective API operation. An operation array could look like the following:</p> <pre><code>static struct vaccel_op ops[] = {\n    VACCEL_OP_INIT(ops[0], VACCEL_OP_NOOP, my_noop_function),\n    [...]\n};\n</code></pre> <p>where <code>VACCEL_OP_NOOP</code> is the operation <code>type</code> and <code>my_noop_function</code> is the <code>func</code>tion implementation:</p> <pre><code>struct vaccel_op {\n    /* operation type */\n    vaccel_op_type_t type;\n\n    /* function implementing the operation */\n    void *func;\n\n    [...]\n};\n</code></pre>"},{"location":"tutorials/writing-your-first-plugin/#implement-a-simple-noop-plugin","title":"Implement a simple <code>NOOP</code> plugin","text":"<p>To better understand how to implement an actual plugin we provide a vaccel-plugin-template. This repo is a good start for developing a vAccel plugin in C.</p> <p>Let's look into <code>src/vaccel.c</code> from the template repo:</p> <pre><code>#include &lt;inttypes.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;vaccel.h&gt; /* header with vAccel API */\n\n/* A function that will be mapped to a vAccel User API operation using\n * register_plugin_functions() */\nstatic int my_noop_function(struct vaccel_session *sess)\n{\n    fprintf(stderr, \"[my noop function] session: %\" PRId64 \"\\n\", sess-&gt;id);\n    return VACCEL_OK;\n}\n\n/* An array of the operations to be mapped */\nstruct vaccel_op ops[] = {\n    VACCEL_OP_INIT(ops[0], VACCEL_NO_OP, my_noop_function),\n};\n\n/* The init() function, called upon plugin initialization */\nstatic int init(void)\n{\n    /* This is where the static function above `my_noop_function()`\n     * gets mapped to the relevant vAccel User API operation. */\n    return vaccel_plugin_register_ops(ops, sizeof(ops) / sizeof(ops[0]));\n}\n\n/* The fini() function, called before unloading the plugin */\nstatic int fini(void)\n{\n    return VACCEL_OK;\n}\n\nVACCEL_PLUGIN(.name = \"template\", .version = \"0.9\",\n              .vaccel_version = VACCEL_VERSION, .init = init, .fini = fini)\n</code></pre> <p>The plugin registers <code>my_noop_function()</code> to serve as the implementation of the <code>VACCEL_OP_NOOP</code> API operation.</p>"},{"location":"tutorials/writing-your-first-plugin/#install-requirements","title":"Install requirements","text":"<p>Before building a vAccel plugin, you need to install the main vAccel library. Instructions on how to build vAccel can be found on the Installation page.</p> <p>You also need some packages to build the plugin itself:</p> <pre><code>sudo apt-get install build-essential ninja-build pkg-config python3-pip\nsudo pip install meson\n</code></pre>"},{"location":"tutorials/writing-your-first-plugin/#build-the-plugin","title":"Build the plugin","text":"<p>Now you can build the vAccel plugin template that implements the <code>NOOP</code> user API operation with your own custom function.</p> <p>First clone the repo:</p> <pre><code>git clone https://github.com/nubificus/vaccel-plugin-template\ncd vaccel-plugin-template\n</code></pre> <p>Use <code>meson</code> to prepare the <code>build</code> directory:</p> <pre><code>meson setup build\n</code></pre> <p>an build the plugin with:</p> <pre><code>meson compile -C build\n</code></pre> <p>This should output a shared object (<code>libvaccel-template.so</code>) in <code>./build/src/</code>.</p> <p>Info</p> <p>To use this plugin with vAccel, you need to select it using the environment variable <code>VACCEL_PLUGINS</code> when running our vAccel application (ie. <code>VACCEL_PLUGINS=/path/to/libvaccel-template.so</code>).</p> <p>See Running the examples for more information.</p>"},{"location":"useful-docs/","title":"Useful docs","text":"<p>Helpful instructions on how to setup external acceleration frameworks or software components used by vAccel and its plugins:</p> <ul> <li>Build and Install PyTorch</li> <li>Build and Install TVM</li> <li>Build and Install TensorFlow</li> </ul>"},{"location":"useful-docs/build-and-install-pytorch/","title":"Build and Install PyTorch","text":"<p>Official instructions for building and installing PyTorch can be found in the Installation section of the PyTorch README.</p> <p>In the sections below we provide a short version that can be used to build and install PyTorch C++ API files (LibTorch) for use with vAccel. We assume that the required dependencies are already installed.</p>"},{"location":"useful-docs/build-and-install-pytorch/#build-pytorch-c-api-files-libtorch","title":"Build PyTorch C++ API files (LibTorch)","text":"<p>Clone the PyTorch repo, adjusting <code>TORCH_VERSION</code> to the desired version:</p> <pre><code>TORCH_VERSION=2.6.0\ngit clone https://github.com/pytorch/pytorch --depth 1 --recursive \\\n    -b \"${TORCH_VERSION}\"\ncd pytorch\n</code></pre> <p>Build the source code:</p> <pre><code>export _GLIBCXX_USE_CXX11_ABI=1\n# If CUDA dependencies are installed set this to `1` for CUDA support\nexport USE_CUDA=0\n\ncmake -S . -B build\ncmake --build build --parallel \"$(nproc)\"\n</code></pre> <p>and install the binaries:</p> <pre><code>cmake --install build --prefix=/usr/local\n</code></pre>"},{"location":"useful-docs/build-and-install-pytorch/#alternative-install-pre-built-pytorch-c-api-files-libtorch","title":"[Alternative] Install pre-built PyTorch C++ API files (LibTorch)","text":"<p>PyTorch provides pre-built binaries for LibTorch. Ie. for version 2.6.0:</p> <p>Download and extract CPU-only binaries:</p> <pre><code>wget https://download.pytorch.org/libtorch/cpu/libtorch-cxx11-abi-shared-with-deps-2.6.0%2Bcpu.zip\nunzip libtorch-cxx11-abi-shared-with-deps-2.6.0+cpu.zip\n</code></pre> <p>or download and extract binaries with CUDA support (here for CUDA 11.8):</p> <pre><code>wget https://download.pytorch.org/libtorch/cu118/libtorch-cxx11-abi-shared-with-deps-2.6.0%2Bcu118.zip\nunzip libtorch-cxx11-abi-shared-with-deps-2.6.0+cu118.zip\n</code></pre> <p>and move files to the desired installation directory:</p> <pre><code>sudo mv libtorch /opt/torch\n</code></pre>"},{"location":"useful-docs/build-and-install-tensorflow/","title":"Build and Install Tensorflow","text":"<p>Official instructions for building and installing Tensorflow can be found on the Tensorflow Build from source page.</p> <p>In the sections below we provide a short version that can be used to build and install Tensorflow and Tensorflow Lite C/C++ API files for use with vAccel. We assume that the required package dependencies are already installed.</p>"},{"location":"useful-docs/build-and-install-tensorflow/#install-bazel","title":"Install Bazel","text":"<p>The easiest way to install the required Bazel version is to use Bazelisk. You can grab the latest version from the Releases page.</p> <p>Ie. for a Debian/Ubuntu-based system you can install Bazel 1.25.0 for x86_64 with:</p> <pre><code>wget https://github.com/bazelbuild/bazelisk/releases/download/v1.25.0/bazelisk-amd64.deb\nsudo dpkg i bazelisk-amd64.deb\n</code></pre> <p>This will provide a <code>bazel</code> executable that will automatically detect and install the required Bazel version for your Tensorflow build.</p>"},{"location":"useful-docs/build-and-install-tensorflow/#build-and-install-tensorflow-and-tensorflow-lite-cc-api-files","title":"Build and install Tensorflow and Tensorflow Lite C/C++ API files","text":"<p>Clone the Tensorflow repo, adjusting <code>TF_VERSION</code> to the desired version:</p> <pre><code>TF_VERSION=v2.17.0\ngit clone -b \"${TF_VERSION}\" --recursive --depth 1 \\\n        https://github.com/tensorflow/tensorflow.git\ncd tensorflow\n</code></pre> <p>Build the Tensorflow and Tensorflow Lite source code:</p> <pre><code>./configure\nbazel \\\n    --host_jvm_args=-Xmx2g \\\n    build --jobs=HOST_CPUS*.8 \\\n        --local_ram_resources=HOST_RAM*.4 \\\n        --config=v2 \\\n        --copt=-O3 \\\n        --verbose_failures \\\n        --discard_analysis_cache \\\n        -c opt \\\n        //tensorflow:libtensorflow.so \\\n        //tensorflow:libtensorflow_cc.so \\\n        //tensorflow:libtensorflow_framework.so \\\n        //tensorflow:install_headers \\\n        --config=monolithic \\\n        //tensorflow/lite/c:libtensorflowlite_c.so \\\n        //tensorflow/lite:libtensorflowlite.so \\\n        //tensorflow/lite/delegates/flex:tensorflowlite_flex\n</code></pre> <p>Note that the build process can take several hours to complete on a non-high-end machine.</p> <p>Copy TF Lite headers and install the generated files to <code>PREFIX</code>:</p> <pre><code># Manually copy TF Lite headers (since no related bazel target is provided)\nOUT_DIR=bazel-bin/tensorflow\nrsync -aPm \\\n    --exclude='internal' --exclude='testing' --exclude='ios' \\\n    --exclude='python' --exclude='java' --exclude='objc' --exclude='swift' \\\n    --exclude='*internal*.h' --exclude='*test*.h' \\\n    --include='*/' --include='*.h' \\\n--exclude='*' \\\n    tensorflow/lite/* \"${OUT_DIR}/include/tensorflow/lite\"\n\n# Install generated files\nPREFIX=/usr/local\ncp -r \"${OUT_DIR}\"/include \"${PREFIX}/\"\nfind \"${OUT_DIR}\" -path '*runfiles' -prune -o -name 'libtensorflow*.so*' \\\n    -exec cp -a {} \"${PREFIX}/lib/\" \\;\nrm -rf \"${PREFIX}\"/lib/*.params* \"${PREFIX}\"/lib/*.runfiles*\n</code></pre>"},{"location":"useful-docs/build-and-install-tvm/","title":"Build and Install TVM","text":"<p>Official instructions for building and installing TVM can be found on the TVM Install from Source page.</p> <p>In the sections below we provide a short version that can be used to build and install TVM C/C++ API files for use with vAccel.</p>"},{"location":"useful-docs/build-and-install-tvm/#install-dependencies","title":"Install dependencies","text":"<p>Install the required dependencies:</p> <pre><code>sudo apt update &amp;&amp; sudo apt install -y cmake git python3 python3-pip \\\n    libtinfo-dev zlib1g-dev libedit-dev\n\n# Optional, for CUDA builds\nsudo apt install libllvm15 and libllvm15-dev\n</code></pre>"},{"location":"useful-docs/build-and-install-tvm/#build-tvm-cc-api-files","title":"Build TVM C/C++ API files","text":"<p>Clone the repo, adjusting <code>TVM_VERSION</code> to the desired version:</p> <pre><code># Replace '/opt' below with the desired installation directory.\n# If installing in '/opt' or another root owned directory you will have to run\n# the rest of the commands as 'root'.\ncd /opt\n\nTVM_VERSION=\"v0.19.0\"\ngit clone https://github.com/apache/tvm --depth 1 --recursive \\\n    -b \"${TVM_VERSION}\"\ncd tvm\n</code></pre> <p>Build source code and install:</p> <pre><code># Configure build\ncmake -S . -B build\ncp cmake/config.cmake build/\necho &gt;&gt; build/config.cmake\necho \"set(CMAKE_BUILD_TYPE RelWithDebInfo)\" &gt;&gt; build/config.cmake\necho \"set(USE_LLVM \\\"llvm-config --ignore-libllvm --link-static\\\")\" \\\n    &gt;&gt; build/config.cmake\necho \"set(HIDE_PRIVATE_SYMBOLS ON)\" &gt;&gt; build/config.cmake\n\n# Optionally, enable CUDA\necho \"set(USE_CUDA   ON)\" &gt;&gt; build/config.cmake\n\n# Build C/C++ files\ncmake --build build --parallel \"$(nproc)\"\n\n# Install python files\nexport TVM_LIBRARY_PATH=/opt/tvm/build\npip install -e /opt/tvm/python\n</code></pre> <p>For convenience, the TVM library path can be added to system paths:</p> <pre><code>echo \"/opt/tvm/build\" | sudo tee /etc/ld.so.conf.d/tvm.conf &gt;/dev/null\nsudo ldconfig\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/","title":"vaccel","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel","title":"vaccel","text":"<p>Python API for vAccel.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Arg","title":"Arg","text":"<pre><code>Arg(data: Any)\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>vaccel_arg</code> C struct.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_arg</code> object and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The input data to be passed to the C struct.</p> required Source code in <code>                vaccel/arg.py</code> <pre><code>def __init__(self, data: Any):\n    \"\"\"Initializes a new `Arg` object.\n\n    Args:\n        data: The input data to be passed to the C struct.\n    \"\"\"\n    self._c_data = CAny(data)\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Arg(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Arg.buf","title":"buf  <code>property</code>","text":"<pre><code>buf: Any\n</code></pre> <p>Returns the buffer value from the underlying C struct.</p> <p>Retrieves the buffer (<code>buf</code>) stored in the <code>struct vaccel_arg</code> C object. If the original data type is a Python built-in type, the buffer is converted back to that type.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The buffer value from the C <code>struct vaccel_arg</code>.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Arg.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Arg.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_arg`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Config","title":"Config","text":"<pre><code>Config(\n    plugins: str = \"libvaccel-noop.so\",\n    log_level: int = 1,\n    log_file: str | None = None,\n    *,\n    profiling_enabled: bool = False,\n    version_ignore: bool = False,\n)\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_config</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_config</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Colon-separated list of plugin names to load.</p> <code>'libvaccel-noop.so'</code> <code>int</code> <p>Logging level (1=ERROR, 4=DEBUG).</p> <code>1</code> <code>str | None</code> <p>Path to log file or None to disable logging to file.</p> <code>None</code> <code>bool</code> <p>Enable or disable profiling.</p> <code>False</code> <code>bool</code> <p>Ignore version mismatches if True.</p> <code>False</code> Source code in <code>                vaccel/config.py</code> <pre><code>def __init__(\n    self,\n    plugins: str = \"libvaccel-noop.so\",\n    log_level: int = 1,\n    log_file: str | None = None,\n    *,\n    profiling_enabled: bool = False,\n    version_ignore: bool = False,\n):\n    \"\"\"Initializes a new `Config` object.\n\n    Args:\n        plugins (str): Colon-separated list of plugin names to load.\n        log_level (int): Logging level (1=ERROR, 4=DEBUG).\n        log_file (str | None): Path to log file or None to disable logging\n            to file.\n        profiling_enabled (bool): Enable or disable profiling.\n        version_ignore (bool): Ignore version mismatches if True.\n    \"\"\"\n    self._plugins = str(plugins)\n    self._log_level = log_level\n    self._log_file = log_file\n    self._profiling_enabled = profiling_enabled\n    self._version_ignore = version_ignore\n    self._c_obj_ptr = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Config(plugins)","title":"<code>plugins</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Config(log_level)","title":"<code>log_level</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Config(log_file)","title":"<code>log_file</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Config(profiling_enabled)","title":"<code>profiling_enabled</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Config(version_ignore)","title":"<code>version_ignore</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Config.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Config.log_file","title":"log_file  <code>property</code>","text":"<pre><code>log_file: str | None\n</code></pre> <p>The configured log file.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>The config's log file.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Config.log_level","title":"log_level  <code>property</code>","text":"<pre><code>log_level: int\n</code></pre> <p>The configured log level.</p> <p>Returns:</p> Type Description <code>int</code> <p>The config's log level.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Config.plugins","title":"plugins  <code>property</code>","text":"<pre><code>plugins: str\n</code></pre> <p>The configured plugins.</p> <p>Returns:</p> Type Description <code>str</code> <p>The config's plugins.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Config.profiling_enabled","title":"profiling_enabled  <code>property</code>","text":"<pre><code>profiling_enabled: bool\n</code></pre> <p>If profiling is enabled or disabled.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if profiling is enabled.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Config.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_config`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Config.version_ignore","title":"version_ignore  <code>property</code>","text":"<pre><code>version_ignore: bool\n</code></pre> <p>Whether a plugin/vAccel version mismatch is ignored.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if version mismatch is ignored.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Resource","title":"Resource","text":"<pre><code>Resource(paths: list[Path] | list[str] | Path | str, type_: ResourceType)\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_resource</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_resource</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>list[Path] | list[str] | Path | str</code> <p>The path(s) to the file(s) that will be represented by the resource.</p> required <code>ResourceType</code> <p>The type of the resource.</p> required Source code in <code>                vaccel/resource.py</code> <pre><code>def __init__(\n    self, paths: list[Path] | list[str] | Path | str, type_: ResourceType\n):\n    \"\"\"Initializes a new `Resource` object.\n\n    Args:\n        paths: The path(s) to the file(s) that will be represented by the\n            resource.\n        type_: The type of the resource.\n    \"\"\"\n    if isinstance(paths, list):\n        self._paths = [str(path) for path in paths]\n    else:\n        self._paths = [str(paths)]\n    self._c_paths = CList(self._paths)\n    self._type = type_\n    self.__sessions = []\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Resource(paths)","title":"<code>paths</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Resource(type_)","title":"<code>type_</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Resource.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Resource.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre> <p>The resource identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>The resource's unique ID.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Resource.remote_id","title":"remote_id  <code>property</code>","text":"<pre><code>remote_id: int\n</code></pre> <p>The remote resource identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>The resource's remote ID.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Resource.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_resource`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Resource.is_registered","title":"is_registered","text":"<pre><code>is_registered(session: BaseSession) -&gt; bool\n</code></pre> <p>Checks if the resource is registered with the session.</p> <p>Parameters:</p> Name Type Description Default <code>BaseSession</code> <p>The session to check for registration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the resource is registered with the session.</p> Source code in <code>          vaccel/resource.py</code> <pre><code>def is_registered(self, session: \"Session\") -&gt; bool:\n    \"\"\"Checks if the resource is registered with the session.\n\n    Args:\n        session: The session to check for registration.\n\n    Returns:\n        True if the resource is registered with the session.\n    \"\"\"\n    return session in self.__sessions\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Resource.is_registered(session)","title":"<code>session</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Resource.register","title":"register","text":"<pre><code>register(session: BaseSession) -&gt; None\n</code></pre> <p>Register the resource with a session.</p> <p>Parameters:</p> Name Type Description Default <code>BaseSession</code> <p>The session to register the resource with.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If resource registration fails.</p> Source code in <code>          vaccel/resource.py</code> <pre><code>def register(self, session: \"Session\") -&gt; None:\n    \"\"\"Register the resource with a session.\n\n    Args:\n        session: The session to register the resource with.\n\n    Raises:\n        FFIError: If resource registration fails.\n    \"\"\"\n    ret = lib.vaccel_resource_register(\n        self._c_ptr_or_raise,\n        session._c_ptr_or_raise,\n    )\n    if ret != 0:\n        raise FFIError(\n            ret,\n            f\"Could not register resource {self.id} \"\n            f\"with session {session.id}\",\n        )\n    self.__sessions.append(session)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Resource.register(session)","title":"<code>session</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Resource.unregister","title":"unregister","text":"<pre><code>unregister(session: BaseSession) -&gt; None\n</code></pre> <p>Unregister the resource from a session.</p> <p>Parameters:</p> Name Type Description Default <code>BaseSession</code> <p>The session to unregister the resource from.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If resource unregistration fails.</p> Source code in <code>          vaccel/resource.py</code> <pre><code>def unregister(self, session: \"Session\") -&gt; None:\n    \"\"\"Unregister the resource from a session.\n\n    Args:\n        session: The session to unregister the resource from.\n\n    Raises:\n        FFIError: If resource unregistration fails.\n    \"\"\"\n    ret = lib.vaccel_resource_unregister(\n        self._c_ptr_or_raise,\n        session._c_ptr_or_raise,\n    )\n    if ret != 0:\n        raise FFIError(\n            ret,\n            f\"Could not unregister resource {self.id} \"\n            f\"from session {session.id}\",\n        )\n    self.__sessions.remove(session)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Resource.unregister(session)","title":"<code>session</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session","title":"Session","text":"<pre><code>Session(flags: int = 0)\n</code></pre> <p>               Bases: <code>BaseSession</code>, <code>NoopMixin</code>, <code>GenopMixin</code>, <code>ExecMixin</code>, <code>ImageMixin</code>, <code>BlasMixin</code>, <code>FpgaMixin</code>, <code>MinmaxMixin</code>, <code>TFMixin</code>, <code>TFLiteMixin</code>, <code>TorchMixin</code></p> <p>Extended session with operations' functionalities.</p> <p>Inherits from <code>BaseSession</code> and the operation mixins, adding support for the operation functions.</p> Inherits <p>BaseSession: Core session management. NoopMixin: Debug operation. GenopMixin: Generic operation. ExecMixin: Exec operations. ImageMixin: Image-related operations. BlasMixin: BLAS operations. FpgaMixin: FPGA operations. MinmaxMixin: Minmax operations. TensorflowMixin: TensorFlow operations.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The flags to configure the session creation. Defaults to 0.</p> <code>0</code> Source code in <code>                vaccel/session.py</code> <pre><code>def __init__(self, flags: int = 0):\n    \"\"\"Initializes a new `BaseSession` object.\n\n    Args:\n        flags: The flags to configure the session creation. Defaults to 0.\n    \"\"\"\n    self._flags = flags\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session(flags)","title":"<code>flags</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.flags","title":"flags  <code>property</code>","text":"<pre><code>flags: int\n</code></pre> <p>The session flags.</p> <p>Returns:</p> Type Description <code>int</code> <p>The flags set during session creation.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre> <p>The session identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>The session's unique ID.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.remote_id","title":"remote_id  <code>property</code>","text":"<pre><code>remote_id: int\n</code></pre> <p>The remote session identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>The session's remote ID.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_session`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.classify","title":"classify","text":"<pre><code>classify(image: bytes) -&gt; (str, str)\n</code></pre> <p>Performs the image classification operation.</p> <p>Wraps the <code>vaccel_image_classification()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>(str, str)</code> <p>A tuple containing: - The classification tag. - The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def classify(self, image: bytes) -&gt; (str, str):\n    \"\"\"Performs the image classification operation.\n\n    Wraps the `vaccel_image_classification()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        A tuple containing:\n            - The classification tag.\n            - The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_text = CBytes(bytearray(self._out_len))\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_classification(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_text._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_text),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image classification failed\")\n\n    return out_text.to_str(), out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.classify(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.depth","title":"depth","text":"<pre><code>depth(image: bytes) -&gt; str\n</code></pre> <p>Performs the image depth estimation operation.</p> <p>Wraps the <code>vaccel_image_depth()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def depth(self, image: bytes) -&gt; str:\n    \"\"\"Performs the image depth estimation operation.\n\n    Wraps the `vaccel_image_depth()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_depth(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image depth estimation failed\")\n\n    return out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.depth(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.detect","title":"detect","text":"<pre><code>detect(image: bytes) -&gt; str\n</code></pre> <p>Performs the image detection operation.</p> <p>Wraps the <code>vaccel_image_detection()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def detect(self, image: bytes) -&gt; str:\n    \"\"\"Performs the image detection operation.\n\n    Wraps the `vaccel_image_detection()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_detection(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image detection failed\")\n\n    return out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.detect(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.exec","title":"exec","text":"<pre><code>exec(\n    library: str | Path,\n    symbol: str,\n    arg_read: list[Any] | None = None,\n    arg_write: list[Any] | None = None,\n) -&gt; list[Any] | None\n</code></pre> <p>Performs the Exec operation.</p> <p>Wraps the <code>vaccel_exec()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>str | Path</code> <p>The path to the shared object containing the function that will be called.</p> required <code>str</code> <p>The name of the function contained in the above shared object.</p> required <code>list[Any] | None</code> <p>The input arguments that will be passed to the called function.</p> <code>None</code> <code>list[Any] | None</code> <p>The output arguments that will be passed to the called function.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Any] | None</code> <p>The resulting outputs.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/exec.py</code> <pre><code>def exec(\n    self,\n    library: str | Path,\n    symbol: str,\n    arg_read: list[Any] | None = None,\n    arg_write: list[Any] | None = None,\n) -&gt; list[Any] | None:\n    \"\"\"Performs the Exec operation.\n\n    Wraps the `vaccel_exec()` C operation.\n\n    Args:\n        library: The path to the shared object containing the function that\n            will be called.\n        symbol: The name of the function contained in the above shared\n            object.\n        arg_read: The input arguments that will be passed to the\n            called function.\n        arg_write: The output arguments that will be passed to the\n            called function.\n\n    Returns:\n        The resulting outputs.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    if arg_read is not None:\n        c_arg_read = CList([Arg(arg) for arg in arg_read])\n        c_arg_read_ptr = c_arg_read._c_ptr\n        c_arg_read_len = len(c_arg_read)\n    else:\n        c_arg_read = None\n        c_arg_read_ptr = ffi.NULL\n        c_arg_read_len = 0\n\n    if arg_write is not None:\n        c_arg_write = CList([Arg(arg) for arg in arg_write])\n        c_arg_write_ptr = c_arg_write._c_ptr\n        c_arg_write_len = len(c_arg_write)\n    else:\n        c_arg_write = None\n        c_arg_write_ptr = ffi.NULL\n        c_arg_write_len = 0\n\n    ret = lib.vaccel_exec(\n        self._c_ptr_or_raise,\n        str(library).encode(),\n        symbol.encode(),\n        c_arg_read_ptr,\n        c_arg_read_len,\n        c_arg_write_ptr,\n        c_arg_write_len,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Exec operation failed\")\n\n    if c_arg_write is not None:\n        return [c_arg_write[i].buf for i in range(len(c_arg_write))]\n    return None\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.exec(library)","title":"<code>library</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.exec(symbol)","title":"<code>symbol</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.exec(arg_read)","title":"<code>arg_read</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.exec(arg_write)","title":"<code>arg_write</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.exec_with_resource","title":"exec_with_resource","text":"<pre><code>exec_with_resource(\n    resource: Resource,\n    symbol: str,\n    arg_read: list[Any] | None = None,\n    arg_write: list[Any] | None = None,\n) -&gt; list[Any] | None\n</code></pre> <p>Performs the Exec with resource operation.</p> <p>Wraps the <code>vaccel_exec_with_resource()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>The resource of the shared object containing the function that will be called.</p> required <code>str</code> <p>The name of the function contained in the above shared object.</p> required <code>list[Any] | None</code> <p>The input arguments that will be passed to the called function.</p> <code>None</code> <code>list[Any] | None</code> <p>The output arguments that will be passed to the called function.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Any] | None</code> <p>The resulting outputs.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/exec.py</code> <pre><code>def exec_with_resource(\n    self,\n    resource: Resource,\n    symbol: str,\n    arg_read: list[Any] | None = None,\n    arg_write: list[Any] | None = None,\n) -&gt; list[Any] | None:\n    \"\"\"Performs the Exec with resource operation.\n\n    Wraps the `vaccel_exec_with_resource()` C operation.\n\n    Args:\n        resource: The resource of the shared object containing the function\n            that will be called.\n        symbol: The name of the function contained in the above shared\n            object.\n        arg_read: The input arguments that will be passed to the\n            called function.\n        arg_write: The output arguments that will be passed to the\n            called function.\n\n    Returns:\n        The resulting outputs.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    if arg_read is not None:\n        c_arg_read = CList([Arg(arg) for arg in arg_read])\n        c_arg_read_ptr = c_arg_read._c_ptr\n        c_arg_read_len = len(c_arg_read)\n    else:\n        c_arg_read = None\n        c_arg_read_ptr = ffi.NULL\n        c_arg_read_len = 0\n\n    if arg_write is not None:\n        c_arg_write = CList([Arg(arg) for arg in arg_write])\n        c_arg_write_ptr = c_arg_write._c_ptr\n        c_arg_write_len = len(c_arg_write)\n    else:\n        c_arg_write = None\n        c_arg_write_ptr = ffi.NULL\n        c_arg_write_len = 0\n\n    ret = lib.vaccel_exec_with_resource(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        symbol.encode(),\n        c_arg_read_ptr,\n        c_arg_read_len,\n        c_arg_write_ptr,\n        c_arg_write_len,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Exec with resource operation failed\")\n\n    if c_arg_write is not None:\n        return [c_arg_write[i].buf for i in range(len(c_arg_write))]\n    return None\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.exec_with_resource(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.exec_with_resource(symbol)","title":"<code>symbol</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.exec_with_resource(arg_read)","title":"<code>arg_read</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.exec_with_resource(arg_write)","title":"<code>arg_write</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.fpga_arraycopy","title":"fpga_arraycopy","text":"<pre><code>fpga_arraycopy(a: list[int]) -&gt; list[int]\n</code></pre> <p>Performs the matrix copying operation.</p> <p>Wraps the <code>vaccel_fpga_arraycopy()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The matrix A to be copied.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>A copy of the matrix A.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/fpga.py</code> <pre><code>def fpga_arraycopy(self, a: list[int]) -&gt; list[int]:\n    \"\"\"Performs the matrix copying operation.\n\n    Wraps the `vaccel_fpga_arraycopy()` C operation.\n\n    Args:\n        a: The matrix A to be copied.\n\n    Returns:\n        A copy of the matrix A.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_out_a = CList([0] * len(a))\n\n    ret = lib.vaccel_fpga_arraycopy(\n        self._c_ptr_or_raise, c_a._c_ptr, c_out_a._c_ptr, len(c_a)\n    )\n    if ret != 0:\n        raise FFIError(ret, \"FPGA array copy failed\")\n\n    return [int(item) for item in c_out_a.value]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.fpga_arraycopy(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.fpga_mmult","title":"fpga_mmult","text":"<pre><code>fpga_mmult(a: list[float], b: list[float]) -&gt; list[float]\n</code></pre> <p>Performs the matrix multiplication operation.</p> <p>Wraps the <code>vaccel_fpga_mmult()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[float]</code> <p>A matrix A.</p> required <code>list[float]</code> <p>A matrix B.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The multiplication result of matrices A and B.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/fpga.py</code> <pre><code>def fpga_mmult(self, a: list[float], b: list[float]) -&gt; list[float]:\n    \"\"\"Performs the matrix multiplication operation.\n\n    Wraps the `vaccel_fpga_mmult()` C operation.\n\n    Args:\n        a: A matrix A.\n        b: A matrix B.\n\n    Returns:\n        The multiplication result of matrices A and B.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_b = CList(b)\n    c_c = CList([float(0)] * len(a))\n\n    ret = lib.vaccel_fpga_mmult(\n        self._c_ptr_or_raise, c_a._c_ptr, c_b._c_ptr, c_c._c_ptr, len(c_a)\n    )\n    if ret != 0:\n        raise FFIError(ret, \"FPGA matrix multiplication failed\")\n\n    return [float(item) for item in c_c.value]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.fpga_mmult(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.fpga_mmult(b)","title":"<code>b</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.fpga_parallel","title":"fpga_parallel","text":"<pre><code>fpga_parallel(a: list[float], b: list[float]) -&gt; (list[float], list[float])\n</code></pre> <p>Performs the parallel matrix addition and multiplication operation.</p> <p>Wraps the <code>vaccel_fpga_parallel()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[float]</code> <p>A matrix A.</p> required <code>list[float]</code> <p>A matrix B.</p> required <p>Returns:</p> Type Description <code>(list[float], list[float])</code> <p>A tuple containing: - The result of the addition of matrices A and B. - The result of the multiplication of matrices A and B.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/fpga.py</code> <pre><code>def fpga_parallel(\n    self, a: list[float], b: list[float]\n) -&gt; (list[float], list[float]):\n    \"\"\"Performs the parallel matrix addition and multiplication operation.\n\n    Wraps the `vaccel_fpga_parallel()` C operation.\n\n    Args:\n        a: A matrix A.\n        b: A matrix B.\n\n    Returns:\n        A tuple containing:\n            - The result of the addition of matrices A and B.\n            - The result of the multiplication of matrices A and B.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_b = CList(b)\n    c_add_output = CList([float(0)] * len(a))\n    c_mult_output = CList([float(0)] * len(a))\n\n    ret = lib.vaccel_fpga_parallel(\n        self._c_ptr_or_raise,\n        c_a._c_ptr,\n        c_b._c_ptr,\n        c_add_output._c_ptr,\n        c_mult_output._c_ptr,\n        len(c_a),\n    )\n    if ret != 0:\n        raise FFIError(\n            ret, \"FPGA parallel matrix addition and multiplication failed\"\n        )\n\n    return (\n        [float(item) for item in c_add_output.value],\n        [float(item) for item in c_mult_output.value],\n    )\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.fpga_parallel(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.fpga_parallel(b)","title":"<code>b</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.fpga_vadd","title":"fpga_vadd","text":"<pre><code>fpga_vadd(a: list[float], b: list[float]) -&gt; list[float]\n</code></pre> <p>Performs the matrix addition operation.</p> <p>Wraps the <code>vaccel_fpga_vadd()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[float]</code> <p>A matrix A.</p> required <code>list[float]</code> <p>A matrix B.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The addition result of matrices A and B.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/fpga.py</code> <pre><code>def fpga_vadd(self, a: list[float], b: list[float]) -&gt; list[float]:\n    \"\"\"Performs the matrix addition operation.\n\n    Wraps the `vaccel_fpga_vadd()` C operation.\n\n    Args:\n        a: A matrix A.\n        b: A matrix B.\n\n    Returns:\n        The addition result of matrices A and B.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_b = CList(b)\n    c_c = CList([float(0)] * len(a))\n\n    ret = lib.vaccel_fpga_vadd(\n        self._c_ptr_or_raise,\n        c_a._c_ptr,\n        c_b._c_ptr,\n        c_c._c_ptr,\n        len(c_a),\n        len(c_b),\n    )\n    if ret != 0:\n        raise FFIError(ret, \"FPGA vector addition failed\")\n\n    return [float(item) for item in c_c.value]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.fpga_vadd(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.fpga_vadd(b)","title":"<code>b</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.genop","title":"genop","text":"<pre><code>genop(arg_read: list[Arg], arg_write: list[Arg]) -&gt; None\n</code></pre> <p>Performs the Generic operation.</p> <p>Wraps the <code>vaccel_genop()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[Arg]</code> <p>The input arguments of the operation.</p> required <code>list[Arg]</code> <p>The output arguments of the operation. Modified in place.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/genop.py</code> <pre><code>def genop(self, arg_read: list[Arg], arg_write: list[Arg]) -&gt; None:\n    \"\"\"Performs the Generic operation.\n\n    Wraps the `vaccel_genop()` C operation.\n\n    Args:\n        arg_read: The input arguments of the operation.\n        arg_write: The output arguments of the operation. Modified in place.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_args_read = CList(arg_read)\n    c_args_write = CList(arg_write)\n\n    ret = lib.vaccel_genop(\n        self._c_ptr_or_raise,\n        c_args_read._c_ptr,\n        len(c_args_read),\n        c_args_write._c_ptr,\n        len(c_args_write),\n    )\n    if ret:\n        raise FFIError(ret, \"Generic operation failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.genop(arg_read)","title":"<code>arg_read</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.genop(arg_write)","title":"<code>arg_write</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.has_resource","title":"has_resource","text":"<pre><code>has_resource(resource: Resource) -&gt; bool\n</code></pre> <p>Check if a resource is registered with the session.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>The resource to check for registration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the resource is registered.</p> Source code in <code>          vaccel/session.py</code> <pre><code>def has_resource(self, resource: Resource) -&gt; bool:\n    \"\"\"Check if a resource is registered with the session.\n\n    Args:\n        resource: The resource to check for registration.\n\n    Returns:\n        True if the resource is registered.\n    \"\"\"\n    return (\n        lib.vaccel_session_has_resource(\n            self._c_ptr_or_raise, resource._c_ptr\n        )\n        != 0\n    )\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.has_resource(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.minmax","title":"minmax","text":"<pre><code>minmax(\n    indata: bytes, ndata: int, low_threshold: int, high_threshold: int\n) -&gt; (bytes, float, float)\n</code></pre> <p>Performs the minmax operation.</p> <p>Wraps the <code>vaccel_minmax()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The input data as a <code>bytes</code> object.</p> required <code>int</code> <p>The number of data to be read provided data object.</p> required <code>int</code> <p>The threshold for the min value.</p> required <code>int</code> <p>The threshold for the max value.</p> required <p>Returns:</p> Type Description <code>(bytes, float, float)</code> <p>A tuple containing: - The resulting output data. - The detected min value of the data. - The detected max value of the data.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/minmax.py</code> <pre><code>def minmax(\n    self, indata: bytes, ndata: int, low_threshold: int, high_threshold: int\n) -&gt; (bytes, float, float):\n    \"\"\"Performs the minmax operation.\n\n    Wraps the `vaccel_minmax()` C operation.\n\n    Args:\n        indata: The input data as a `bytes` object.\n        ndata: The number of data to be read provided data object.\n        low_threshold: The threshold for the min value.\n        high_threshold: The threshold for the max value.\n\n    Returns:\n        A tuple containing:\n            - The resulting output data.\n            - The detected min value of the data.\n            - The detected max value of the data.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_indata = CBytes(indata)\n    c_outdata = CBytes(bytearray(ndata * ffi.sizeof(\"double\")))\n    c_min = CFloat(float(0), \"double\")\n    c_max = CFloat(float(0), \"double\")\n\n    ret = lib.vaccel_minmax(\n        self._c_ptr_or_raise,\n        c_indata._as_c_array(\"double\"),\n        ndata,\n        low_threshold,\n        high_threshold,\n        c_outdata._as_c_array(\"double\"),\n        c_min._c_ptr,\n        c_max._c_ptr,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Minmax operation failed\")\n\n    return (c_outdata.value, c_min.value, c_max.value)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.minmax(indata)","title":"<code>indata</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.minmax(ndata)","title":"<code>ndata</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.minmax(low_threshold)","title":"<code>low_threshold</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.minmax(high_threshold)","title":"<code>high_threshold</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.noop","title":"noop","text":"<pre><code>noop() -&gt; None\n</code></pre> <p>Performs the NoOp operation.</p> <p>Wraps the <code>vaccel_noop()</code> C operation.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/noop.py</code> <pre><code>def noop(self) -&gt; None:\n    \"\"\"Performs the NoOp operation.\n\n    Wraps the `vaccel_noop()` C operation.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_noop(self._c_ptr_or_raise)\n    if ret != 0:\n        raise FFIError(ret, \"NoOp operation failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.pose","title":"pose","text":"<pre><code>pose(image: bytes) -&gt; str\n</code></pre> <p>Performs the image pose estimation operation.</p> <p>Wraps the <code>vaccel_image_pose()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def pose(self, image: bytes) -&gt; str:\n    \"\"\"Performs the image pose estimation operation.\n\n    Wraps the `vaccel_image_pose()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_pose(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image pose estimation failed\")\n\n    return out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.pose(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.segment","title":"segment","text":"<pre><code>segment(image: bytes) -&gt; str\n</code></pre> <p>Performs the image segmentation operations.</p> <p>Wraps the <code>vaccel_image_segmentation()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def segment(self, image: bytes) -&gt; str:\n    \"\"\"Performs the image segmentation operations.\n\n    Wraps the `vaccel_image_segmentation()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_segmentation(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image segmentation failed\")\n\n    return out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.segment(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.sgemm","title":"sgemm","text":"<pre><code>sgemm(\n    m: int,\n    n: int,\n    k: int,\n    alpha: float,\n    a: list[float],\n    lda: int,\n    b: list[float],\n    ldb: int,\n    beta: float,\n    ldc: int,\n) -&gt; list[float]\n</code></pre> <p>Performs the SGEMM operation.</p> <p>Wraps the <code>vaccel_sgemm()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The number of rows in matrix A and matrix C.</p> required <code>int</code> <p>The number of columns in matrix B and matrix C.</p> required <code>int</code> <p>The number of columns in matrix A and rows in matrix B.</p> required <code>float</code> <p>Scalar multiplier for the matrix product A * B.</p> required <code>list[float]</code> <p>The matrix A in row-major order with shape (m, k).</p> required <code>int</code> <p>The leading dimension of matrix A (usually m).</p> required <code>list[float]</code> <p>The matrix B in row-major order with shape (k, n).</p> required <code>int</code> <p>The leading dimension of matrix B (usually k).</p> required <code>float</code> <p>Scalar multiplier for matrix C.</p> required <code>int</code> <p>The leading dimension of matrix C (usually m).</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The resulting matrix C in row-major order with shape (m, n).</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/blas.py</code> <pre><code>def sgemm(\n    self,\n    m: int,\n    n: int,\n    k: int,\n    alpha: float,\n    a: list[float],\n    lda: int,\n    b: list[float],\n    ldb: int,\n    beta: float,\n    ldc: int,\n) -&gt; list[float]:\n    \"\"\"Performs the SGEMM operation.\n\n    Wraps the `vaccel_sgemm()` C operation.\n\n    Args:\n        m: The number of rows in matrix A and matrix C.\n        n: The number of columns in matrix B and matrix C.\n        k: The number of columns in matrix A and rows in matrix B.\n        alpha: Scalar multiplier for the matrix product A * B.\n        a: The matrix A in row-major order with shape (m, k).\n        lda: The leading dimension of matrix A (usually m).\n        b: The matrix B in row-major order with shape (k, n).\n        ldb: The leading dimension of matrix B (usually k).\n        beta: Scalar multiplier for matrix C.\n        ldc: The leading dimension of matrix C (usually m).\n\n    Returns:\n        The resulting matrix C in row-major order with shape (m, n).\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_b = CList(b)\n    c_c = CList([float(0)] * m * n)\n\n    ret = lib.vaccel_sgemm(\n        self._c_ptr_or_raise,\n        m,\n        n,\n        k,\n        alpha,\n        c_a._c_ptr,\n        lda,\n        c_b._c_ptr,\n        ldb,\n        beta,\n        c_c._c_ptr,\n        ldc,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"SGEMM failed\")\n\n    return c_c.value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.sgemm(m)","title":"<code>m</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.sgemm(n)","title":"<code>n</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.sgemm(k)","title":"<code>k</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.sgemm(alpha)","title":"<code>alpha</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.sgemm(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.sgemm(lda)","title":"<code>lda</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.sgemm(b)","title":"<code>b</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.sgemm(ldb)","title":"<code>ldb</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.sgemm(beta)","title":"<code>beta</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.sgemm(ldc)","title":"<code>ldc</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tf_model_load","title":"tf_model_load","text":"<pre><code>tf_model_load(resource: Resource) -&gt; Status\n</code></pre> <p>Performs the Tensorflow model load operation.</p> <p>Wraps the <code>vaccel_tf_model_load()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to load.</p> required <p>Returns:</p> Type Description <code>Status</code> <p>The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/mixin.py</code> <pre><code>def tf_model_load(self, resource: Resource) -&gt; Status:\n    \"\"\"Performs the Tensorflow model load operation.\n\n    Wraps the `vaccel_tf_model_load()` C operation.\n\n    Args:\n        resource: A resource with the model to load.\n\n    Returns:\n        The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    status = Status()\n    ret = lib.vaccel_tf_model_load(\n        self._c_ptr_or_raise, resource._c_ptr, status._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow model load failed\")\n    return status\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tf_model_load(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tf_model_run","title":"tf_model_run","text":"<pre><code>tf_model_run(\n    resource: Resource,\n    in_nodes: list[Node],\n    in_tensors: list[Tensor],\n    out_nodes: list[Node],\n    run_options: Buffer | None = None,\n) -&gt; (list[Tensor], Status)\n</code></pre> <p>Performs the Tensorflow model run operation.</p> <p>Wraps the <code>vaccel_tf_model_run()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to run.</p> required <code>list[Node]</code> <p>The input nodes for the inference.</p> required <code>list[Tensor]</code> <p>The input tensors for the inference.</p> required <code>list[Node]</code> <p>The output nodes for the inference.</p> required <code>Buffer | None</code> <p>The inference options.</p> <code>None</code> <p>Returns:</p> Type Description <code>(list[Tensor], Status)</code> <p>A tuple containing: - The output tensors - The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/mixin.py</code> <pre><code>def tf_model_run(\n    self,\n    resource: Resource,\n    in_nodes: list[Node],\n    in_tensors: list[Tensor],\n    out_nodes: list[Node],\n    run_options: Buffer | None = None,\n) -&gt; (list[Tensor], Status):\n    \"\"\"Performs the Tensorflow model run operation.\n\n    Wraps the `vaccel_tf_model_run()` C operation.\n\n    Args:\n        resource: A resource with the model to run.\n        in_nodes: The input nodes for the inference.\n        in_tensors: The input tensors for the inference.\n        out_nodes: The output nodes for the inference.\n        run_options: The inference options.\n\n    Returns:\n        A tuple containing:\n            - The output tensors\n            - The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    run_options_ptr = (\n        ffi.NULL if run_options is None else run_options._c_ptr\n    )\n    c_in_nodes = CList(in_nodes)\n    c_in_tensors = CList.from_ptrs(in_tensors)\n    c_out_nodes = CList(out_nodes)\n    c_out_tensors = CList.from_ptrs([Tensor.empty()] * len(c_out_nodes))\n    status = Status()\n\n    ret = lib.vaccel_tf_model_run(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        run_options_ptr,\n        c_in_nodes._c_ptr,\n        c_in_tensors._c_ptr,\n        len(c_in_nodes),\n        c_out_nodes._c_ptr,\n        c_out_tensors._c_ptr,\n        len(c_out_nodes),\n        status._c_ptr,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow model run failed\")\n\n    out_tensors = [Tensor.from_c_obj(t) for t in c_out_tensors.value]\n    return (out_tensors, status)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tf_model_run(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tf_model_run(in_nodes)","title":"<code>in_nodes</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tf_model_run(in_tensors)","title":"<code>in_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tf_model_run(out_nodes)","title":"<code>out_nodes</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tf_model_run(run_options)","title":"<code>run_options</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tf_model_unload","title":"tf_model_unload","text":"<pre><code>tf_model_unload(resource: Resource) -&gt; Status\n</code></pre> <p>Performs the Tensorflow model unload operation.</p> <p>Wraps the <code>vaccel_tf_model_unload()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to unload.</p> required <p>Returns:</p> Type Description <code>Status</code> <p>The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/mixin.py</code> <pre><code>def tf_model_unload(self, resource: Resource) -&gt; Status:\n    \"\"\"Performs the Tensorflow model unload operation.\n\n    Wraps the `vaccel_tf_model_unload()` C operation.\n\n    Args:\n        resource: A resource with the model to unload.\n\n    Returns:\n        The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    status = Status()\n    ret = lib.vaccel_tf_model_unload(\n        self._c_ptr_or_raise, resource._c_ptr, status._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow model unload failed\")\n    return status\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tf_model_unload(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tflite_model_load","title":"tflite_model_load","text":"<pre><code>tflite_model_load(resource: Resource) -&gt; None\n</code></pre> <p>Performs the Tensorflow Lite model load operation.</p> <p>Wraps the <code>vaccel_tflite_model_load()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to load.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/lite/mixin.py</code> <pre><code>def tflite_model_load(self, resource: Resource) -&gt; None:\n    \"\"\"Performs the Tensorflow Lite model load operation.\n\n    Wraps the `vaccel_tflite_model_load()` C operation.\n\n    Args:\n        resource: A resource with the model to load.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_tflite_model_load(\n        self._c_ptr_or_raise, resource._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow Lite model load failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tflite_model_load(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tflite_model_run","title":"tflite_model_run","text":"<pre><code>tflite_model_run(\n    resource: Resource, in_tensors: list[Tensor], nr_out_tensors: int = 1\n) -&gt; (list[Tensor], int)\n</code></pre> <p>Performs the Tensorflow Lite model run operation.</p> <p>Wraps the <code>vaccel_tflite_model_run()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to run.</p> required <code>list[Tensor]</code> <p>The input tensors for the inference.</p> required <code>int</code> <p>The number of output tensors. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>(list[Tensor], int)</code> <p>A tuple containing: - The output tensors - The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/lite/mixin.py</code> <pre><code>def tflite_model_run(\n    self,\n    resource: Resource,\n    in_tensors: list[Tensor],\n    nr_out_tensors: int = 1,\n) -&gt; (list[Tensor], int):\n    \"\"\"Performs the Tensorflow Lite model run operation.\n\n    Wraps the `vaccel_tflite_model_run()` C operation.\n\n    Args:\n        resource: A resource with the model to run.\n        in_tensors: The input tensors for the inference.\n        nr_out_tensors: The number of output tensors. Defaults to 1.\n\n    Returns:\n        A tuple containing:\n            - The output tensors\n            - The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_in_tensors = CList.from_ptrs(in_tensors)\n    c_out_tensors = CList.from_ptrs([Tensor.empty()] * nr_out_tensors)\n    status = CInt(0, \"uint8_t\")\n\n    ret = lib.vaccel_tflite_model_run(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        c_in_tensors._c_ptr,\n        len(c_in_tensors),\n        c_out_tensors._c_ptr,\n        len(c_out_tensors),\n        status._c_ptr,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow Lite model run failed\")\n\n    out_tensors = [Tensor.from_c_obj(t) for t in c_out_tensors.value]\n    return (out_tensors, status.value)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tflite_model_run(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tflite_model_run(in_tensors)","title":"<code>in_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tflite_model_run(nr_out_tensors)","title":"<code>nr_out_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tflite_model_unload","title":"tflite_model_unload","text":"<pre><code>tflite_model_unload(resource: Resource) -&gt; None\n</code></pre> <p>Performs the Tensorflow Lite model unload operation.</p> <p>Wraps the <code>vaccel_tflite_model_unload()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to unload.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/lite/mixin.py</code> <pre><code>def tflite_model_unload(self, resource: Resource) -&gt; None:\n    \"\"\"Performs the Tensorflow Lite model unload operation.\n\n    Wraps the `vaccel_tflite_model_unload()` C operation.\n\n    Args:\n        resource: A resource with the model to unload.\n\n    Returns:\n        The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_tflite_model_unload(\n        self._c_ptr_or_raise, resource._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow Lite model unload failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.tflite_model_unload(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.torch_model_load","title":"torch_model_load","text":"<pre><code>torch_model_load(resource: Resource) -&gt; None\n</code></pre> <p>Performs the Torch model load operation.</p> <p>Wraps the <code>vaccel_torch_model_load()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to load.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/torch/mixin.py</code> <pre><code>def torch_model_load(self, resource: Resource) -&gt; None:\n    \"\"\"Performs the Torch model load operation.\n\n    Wraps the `vaccel_torch_model_load()` C operation.\n\n    Args:\n        resource: A resource with the model to load.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_torch_model_load(self._c_ptr_or_raise, resource._c_ptr)\n    if ret != 0:\n        raise FFIError(ret, \"Torch model load failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.torch_model_load(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.torch_model_run","title":"torch_model_run","text":"<pre><code>torch_model_run(\n    resource: Resource,\n    in_tensors: list[Tensor],\n    nr_out_tensors: int = 1,\n    run_options: Buffer | None = None,\n) -&gt; list[Tensor]\n</code></pre> <p>Performs the Torch model run operation.</p> <p>Wraps the <code>vaccel_torch_model_run()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to run.</p> required <code>list[Tensor]</code> <p>The input tensors for the inference.</p> required <code>int</code> <p>The number of output tensors. Defaults to 1.</p> <code>1</code> <code>Buffer | None</code> <p>The inference options.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Tensor]</code> <p>The output tensors</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/torch/mixin.py</code> <pre><code>def torch_model_run(\n    self,\n    resource: Resource,\n    in_tensors: list[Tensor],\n    nr_out_tensors: int = 1,\n    run_options: Buffer | None = None,\n) -&gt; list[Tensor]:\n    \"\"\"Performs the Torch model run operation.\n\n    Wraps the `vaccel_torch_model_run()` C operation.\n\n    Args:\n        resource: A resource with the model to run.\n        in_tensors: The input tensors for the inference.\n        nr_out_tensors: The number of output tensors. Defaults to 1.\n        run_options: The inference options.\n\n    Returns:\n        The output tensors\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    run_options_ptr = (\n        ffi.NULL if run_options is None else run_options._c_ptr\n    )\n    c_in_tensors = CList.from_ptrs(in_tensors)\n    c_out_tensors = CList.from_ptrs([Tensor.empty()] * nr_out_tensors)\n\n    ret = lib.vaccel_torch_model_run(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        run_options_ptr,\n        c_in_tensors._c_ptr,\n        len(c_in_tensors),\n        c_out_tensors._c_ptr,\n        len(c_out_tensors),\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Torch jitload forward operation failed\")\n\n    return [Tensor.from_c_obj(t) for t in c_out_tensors.value]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.torch_model_run(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.torch_model_run(in_tensors)","title":"<code>in_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.torch_model_run(nr_out_tensors)","title":"<code>nr_out_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.Session.torch_model_run(run_options)","title":"<code>run_options</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.bootstrap","title":"bootstrap","text":"<pre><code>bootstrap(config: Config | None = None) -&gt; None\n</code></pre> <p>Initializes the vAccel library.</p> <p>Parameters:</p> Name Type Description Default <code>Config | None</code> <p>A configuration object for the library. If None, defaults are used.</p> <code>None</code> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/vaccel.py</code> <pre><code>def bootstrap(config: Config | None = None) -&gt; None:\n    \"\"\"Initializes the vAccel library.\n\n    Args:\n        config (Config | None): A configuration object for the library. If None,\n            defaults are used.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    if config is None:\n        ret = lib.vaccel_bootstrap()\n    else:\n        ret = lib.vaccel_bootstrap_with_config(config._c_ptr)\n    if ret != 0:\n        raise FFIError(ret, \"Could not bootstrap vAccel library\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.bootstrap(config)","title":"<code>config</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/#vaccel.cleanup","title":"cleanup","text":"<pre><code>cleanup() -&gt; None\n</code></pre> <p>Cleans up the vAccel library resources.</p> <p>This function is called automatically at program exit, but can also be invoked explicitly if needed.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/vaccel.py</code> <pre><code>@atexit.register\ndef cleanup() -&gt; None:\n    \"\"\"Cleans up the vAccel library resources.\n\n    This function is called automatically at program exit, but can also be\n    invoked explicitly if needed.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_cleanup()\n    if ret != 0:\n        raise FFIError(ret, \"Could not cleanup vAccel library objects\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/arg/","title":"arg","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/arg/#vaccel.arg","title":"arg","text":"<p>Interface to the <code>struct vaccel_arg</code> C object.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/arg/#vaccel.arg.Arg","title":"Arg","text":"<pre><code>Arg(data: Any)\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>vaccel_arg</code> C struct.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_arg</code> object and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The input data to be passed to the C struct.</p> required Source code in <code>                vaccel/arg.py</code> <pre><code>def __init__(self, data: Any):\n    \"\"\"Initializes a new `Arg` object.\n\n    Args:\n        data: The input data to be passed to the C struct.\n    \"\"\"\n    self._c_data = CAny(data)\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/arg/#vaccel.arg.Arg(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/arg/#vaccel.arg.Arg.buf","title":"buf  <code>property</code>","text":"<pre><code>buf: Any\n</code></pre> <p>Returns the buffer value from the underlying C struct.</p> <p>Retrieves the buffer (<code>buf</code>) stored in the <code>struct vaccel_arg</code> C object. If the original data type is a Python built-in type, the buffer is converted back to that type.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The buffer value from the C <code>struct vaccel_arg</code>.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/arg/#vaccel.arg.Arg.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/arg/#vaccel.arg.Arg.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_arg`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/","title":"config","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config","title":"config","text":"<p>Interface to the <code>struct vaccel_config</code> C object.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config.Config","title":"Config","text":"<pre><code>Config(\n    plugins: str = \"libvaccel-noop.so\",\n    log_level: int = 1,\n    log_file: str | None = None,\n    *,\n    profiling_enabled: bool = False,\n    version_ignore: bool = False,\n)\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_config</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_config</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Colon-separated list of plugin names to load.</p> <code>'libvaccel-noop.so'</code> <code>int</code> <p>Logging level (1=ERROR, 4=DEBUG).</p> <code>1</code> <code>str | None</code> <p>Path to log file or None to disable logging to file.</p> <code>None</code> <code>bool</code> <p>Enable or disable profiling.</p> <code>False</code> <code>bool</code> <p>Ignore version mismatches if True.</p> <code>False</code> Source code in <code>                vaccel/config.py</code> <pre><code>def __init__(\n    self,\n    plugins: str = \"libvaccel-noop.so\",\n    log_level: int = 1,\n    log_file: str | None = None,\n    *,\n    profiling_enabled: bool = False,\n    version_ignore: bool = False,\n):\n    \"\"\"Initializes a new `Config` object.\n\n    Args:\n        plugins (str): Colon-separated list of plugin names to load.\n        log_level (int): Logging level (1=ERROR, 4=DEBUG).\n        log_file (str | None): Path to log file or None to disable logging\n            to file.\n        profiling_enabled (bool): Enable or disable profiling.\n        version_ignore (bool): Ignore version mismatches if True.\n    \"\"\"\n    self._plugins = str(plugins)\n    self._log_level = log_level\n    self._log_file = log_file\n    self._profiling_enabled = profiling_enabled\n    self._version_ignore = version_ignore\n    self._c_obj_ptr = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config.Config(plugins)","title":"<code>plugins</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config.Config(log_level)","title":"<code>log_level</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config.Config(log_file)","title":"<code>log_file</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config.Config(profiling_enabled)","title":"<code>profiling_enabled</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config.Config(version_ignore)","title":"<code>version_ignore</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config.Config.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config.Config.log_file","title":"log_file  <code>property</code>","text":"<pre><code>log_file: str | None\n</code></pre> <p>The configured log file.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>The config's log file.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config.Config.log_level","title":"log_level  <code>property</code>","text":"<pre><code>log_level: int\n</code></pre> <p>The configured log level.</p> <p>Returns:</p> Type Description <code>int</code> <p>The config's log level.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config.Config.plugins","title":"plugins  <code>property</code>","text":"<pre><code>plugins: str\n</code></pre> <p>The configured plugins.</p> <p>Returns:</p> Type Description <code>str</code> <p>The config's plugins.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config.Config.profiling_enabled","title":"profiling_enabled  <code>property</code>","text":"<pre><code>profiling_enabled: bool\n</code></pre> <p>If profiling is enabled or disabled.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if profiling is enabled.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config.Config.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_config`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/config/#vaccel.config.Config.version_ignore","title":"version_ignore  <code>property</code>","text":"<pre><code>version_ignore: bool\n</code></pre> <p>Whether a plugin/vAccel version mismatch is ignored.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if version mismatch is ignored.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/error/","title":"error","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/error/#vaccel.error","title":"error","text":"<p>Common error types.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/error/#vaccel.error.FFIError","title":"FFIError","text":"<pre><code>FFIError(error_code: int, message: str)\n</code></pre> <p>               Bases: <code>RuntimeError</code></p> <p>Exception raised when a vAccel runtime error occurs.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The code associated with the runtime error.</p> required <code>str</code> <p>A message describing the error.</p> required Source code in <code>                vaccel/error.py</code> <pre><code>def __init__(self, error_code: int, message: str):\n    \"\"\"Initializes a new `FFIError` object.\n\n    Args:\n        error_code: The code associated with the runtime error.\n        message: A message describing the error.\n    \"\"\"\n    self.code = error_code\n    self.message = message\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/error/#vaccel.error.FFIError(error_code)","title":"<code>error_code</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/error/#vaccel.error.FFIError(message)","title":"<code>message</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/error/#vaccel.error.NullPointerError","title":"NullPointerError","text":"<pre><code>NullPointerError(context: str)\n</code></pre> <p>               Bases: <code>RuntimeError</code></p> <p>Exception raised when a C pointer is unexpectedly NULL.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Name or description of the variable that was NULL.</p> required Source code in <code>                vaccel/error.py</code> <pre><code>def __init__(self, context: str):\n    \"\"\"Initializes a new `NullPointerError` object.\n\n    Args:\n        context: Name or description of the variable that was NULL.\n    \"\"\"\n    super().__init__(f\"Unexpected NULL pointer encountered in {context}\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/error/#vaccel.error.NullPointerError(context)","title":"<code>context</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/error/#vaccel.error.ptr_or_raise","title":"ptr_or_raise","text":"<pre><code>ptr_or_raise(ptr: CData, context: str = 'pointer') -&gt; CData\n</code></pre> <p>Validates a C pointer and raises an error if it is NULL.</p> <p>Parameters:</p> Name Type Description Default <code>CData</code> <p>A CFFI pointer to validate.</p> required <code>str</code> <p>A description of the pointer or its role for debugging purposes.</p> <code>'pointer'</code> <p>Returns:</p> Type Description <code>CData</code> <p>The original <code>ptr</code> if it is not NULL.</p> <p>Raises:</p> Type Description <code>NullPointerError</code> <p>If <code>ptr</code> is NULL.</p> Source code in <code>          vaccel/error.py</code> <pre><code>def ptr_or_raise(ptr: ffi.CData, context: str = \"pointer\") -&gt; ffi.CData:\n    \"\"\"Validates a C pointer and raises an error if it is NULL.\n\n    Args:\n        ptr: A CFFI pointer to validate.\n        context: A description of the pointer or its role for debugging\n            purposes.\n\n    Returns:\n        The original `ptr` if it is not NULL.\n\n    Raises:\n        NullPointerError: If `ptr` is NULL.\n    \"\"\"\n    if ptr == ffi.NULL:\n        raise NullPointerError(context)\n    return ptr\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/error/#vaccel.error.ptr_or_raise(ptr)","title":"<code>ptr</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/error/#vaccel.error.ptr_or_raise(context)","title":"<code>context</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/op/","title":"op","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/op/#vaccel.op","title":"op","text":"<p>Interface to the <code>struct vaccel_op</code> C object.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/","title":"ops","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/#vaccel.ops","title":"ops","text":"<p>Operations.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/","title":"blas","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/#vaccel.ops.blas","title":"blas","text":"<p>Blas operations.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/#vaccel.ops.blas.BlasMixin","title":"BlasMixin","text":"<p>Mixin providing Blas operations for a <code>Session</code>.</p> <p>This mixin is intended to be used in combination with <code>BaseSession</code> and should not be instantiated on its own.</p> Intended usage <p>class Session(BaseSession, BlasMixin):     ...</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/#vaccel.ops.blas.BlasMixin.sgemm","title":"sgemm","text":"<pre><code>sgemm(\n    m: int,\n    n: int,\n    k: int,\n    alpha: float,\n    a: list[float],\n    lda: int,\n    b: list[float],\n    ldb: int,\n    beta: float,\n    ldc: int,\n) -&gt; list[float]\n</code></pre> <p>Performs the SGEMM operation.</p> <p>Wraps the <code>vaccel_sgemm()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The number of rows in matrix A and matrix C.</p> required <code>int</code> <p>The number of columns in matrix B and matrix C.</p> required <code>int</code> <p>The number of columns in matrix A and rows in matrix B.</p> required <code>float</code> <p>Scalar multiplier for the matrix product A * B.</p> required <code>list[float]</code> <p>The matrix A in row-major order with shape (m, k).</p> required <code>int</code> <p>The leading dimension of matrix A (usually m).</p> required <code>list[float]</code> <p>The matrix B in row-major order with shape (k, n).</p> required <code>int</code> <p>The leading dimension of matrix B (usually k).</p> required <code>float</code> <p>Scalar multiplier for matrix C.</p> required <code>int</code> <p>The leading dimension of matrix C (usually m).</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The resulting matrix C in row-major order with shape (m, n).</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/blas.py</code> <pre><code>def sgemm(\n    self,\n    m: int,\n    n: int,\n    k: int,\n    alpha: float,\n    a: list[float],\n    lda: int,\n    b: list[float],\n    ldb: int,\n    beta: float,\n    ldc: int,\n) -&gt; list[float]:\n    \"\"\"Performs the SGEMM operation.\n\n    Wraps the `vaccel_sgemm()` C operation.\n\n    Args:\n        m: The number of rows in matrix A and matrix C.\n        n: The number of columns in matrix B and matrix C.\n        k: The number of columns in matrix A and rows in matrix B.\n        alpha: Scalar multiplier for the matrix product A * B.\n        a: The matrix A in row-major order with shape (m, k).\n        lda: The leading dimension of matrix A (usually m).\n        b: The matrix B in row-major order with shape (k, n).\n        ldb: The leading dimension of matrix B (usually k).\n        beta: Scalar multiplier for matrix C.\n        ldc: The leading dimension of matrix C (usually m).\n\n    Returns:\n        The resulting matrix C in row-major order with shape (m, n).\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_b = CList(b)\n    c_c = CList([float(0)] * m * n)\n\n    ret = lib.vaccel_sgemm(\n        self._c_ptr_or_raise,\n        m,\n        n,\n        k,\n        alpha,\n        c_a._c_ptr,\n        lda,\n        c_b._c_ptr,\n        ldb,\n        beta,\n        c_c._c_ptr,\n        ldc,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"SGEMM failed\")\n\n    return c_c.value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/#vaccel.ops.blas.BlasMixin.sgemm(m)","title":"<code>m</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/#vaccel.ops.blas.BlasMixin.sgemm(n)","title":"<code>n</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/#vaccel.ops.blas.BlasMixin.sgemm(k)","title":"<code>k</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/#vaccel.ops.blas.BlasMixin.sgemm(alpha)","title":"<code>alpha</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/#vaccel.ops.blas.BlasMixin.sgemm(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/#vaccel.ops.blas.BlasMixin.sgemm(lda)","title":"<code>lda</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/#vaccel.ops.blas.BlasMixin.sgemm(b)","title":"<code>b</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/#vaccel.ops.blas.BlasMixin.sgemm(ldb)","title":"<code>ldb</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/#vaccel.ops.blas.BlasMixin.sgemm(beta)","title":"<code>beta</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/blas/#vaccel.ops.blas.BlasMixin.sgemm(ldc)","title":"<code>ldc</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/exec/","title":"exec","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/exec/#vaccel.ops.exec","title":"exec","text":"<p>Exec operations.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/exec/#vaccel.ops.exec.ExecMixin","title":"ExecMixin","text":"<p>Mixin providing the Exec operations for a <code>Session</code>.</p> <p>This mixin is intended to be used in combination with <code>BaseSession</code> and should not be instantiated on its own.</p> Intended usage <p>class Session(BaseSession, ExecMixin):     ...</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/exec/#vaccel.ops.exec.ExecMixin.exec","title":"exec","text":"<pre><code>exec(\n    library: str | Path,\n    symbol: str,\n    arg_read: list[Any] | None = None,\n    arg_write: list[Any] | None = None,\n) -&gt; list[Any] | None\n</code></pre> <p>Performs the Exec operation.</p> <p>Wraps the <code>vaccel_exec()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>str | Path</code> <p>The path to the shared object containing the function that will be called.</p> required <code>str</code> <p>The name of the function contained in the above shared object.</p> required <code>list[Any] | None</code> <p>The input arguments that will be passed to the called function.</p> <code>None</code> <code>list[Any] | None</code> <p>The output arguments that will be passed to the called function.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Any] | None</code> <p>The resulting outputs.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/exec.py</code> <pre><code>def exec(\n    self,\n    library: str | Path,\n    symbol: str,\n    arg_read: list[Any] | None = None,\n    arg_write: list[Any] | None = None,\n) -&gt; list[Any] | None:\n    \"\"\"Performs the Exec operation.\n\n    Wraps the `vaccel_exec()` C operation.\n\n    Args:\n        library: The path to the shared object containing the function that\n            will be called.\n        symbol: The name of the function contained in the above shared\n            object.\n        arg_read: The input arguments that will be passed to the\n            called function.\n        arg_write: The output arguments that will be passed to the\n            called function.\n\n    Returns:\n        The resulting outputs.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    if arg_read is not None:\n        c_arg_read = CList([Arg(arg) for arg in arg_read])\n        c_arg_read_ptr = c_arg_read._c_ptr\n        c_arg_read_len = len(c_arg_read)\n    else:\n        c_arg_read = None\n        c_arg_read_ptr = ffi.NULL\n        c_arg_read_len = 0\n\n    if arg_write is not None:\n        c_arg_write = CList([Arg(arg) for arg in arg_write])\n        c_arg_write_ptr = c_arg_write._c_ptr\n        c_arg_write_len = len(c_arg_write)\n    else:\n        c_arg_write = None\n        c_arg_write_ptr = ffi.NULL\n        c_arg_write_len = 0\n\n    ret = lib.vaccel_exec(\n        self._c_ptr_or_raise,\n        str(library).encode(),\n        symbol.encode(),\n        c_arg_read_ptr,\n        c_arg_read_len,\n        c_arg_write_ptr,\n        c_arg_write_len,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Exec operation failed\")\n\n    if c_arg_write is not None:\n        return [c_arg_write[i].buf for i in range(len(c_arg_write))]\n    return None\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/exec/#vaccel.ops.exec.ExecMixin.exec(library)","title":"<code>library</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/exec/#vaccel.ops.exec.ExecMixin.exec(symbol)","title":"<code>symbol</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/exec/#vaccel.ops.exec.ExecMixin.exec(arg_read)","title":"<code>arg_read</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/exec/#vaccel.ops.exec.ExecMixin.exec(arg_write)","title":"<code>arg_write</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/exec/#vaccel.ops.exec.ExecMixin.exec_with_resource","title":"exec_with_resource","text":"<pre><code>exec_with_resource(\n    resource: Resource,\n    symbol: str,\n    arg_read: list[Any] | None = None,\n    arg_write: list[Any] | None = None,\n) -&gt; list[Any] | None\n</code></pre> <p>Performs the Exec with resource operation.</p> <p>Wraps the <code>vaccel_exec_with_resource()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>The resource of the shared object containing the function that will be called.</p> required <code>str</code> <p>The name of the function contained in the above shared object.</p> required <code>list[Any] | None</code> <p>The input arguments that will be passed to the called function.</p> <code>None</code> <code>list[Any] | None</code> <p>The output arguments that will be passed to the called function.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Any] | None</code> <p>The resulting outputs.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/exec.py</code> <pre><code>def exec_with_resource(\n    self,\n    resource: Resource,\n    symbol: str,\n    arg_read: list[Any] | None = None,\n    arg_write: list[Any] | None = None,\n) -&gt; list[Any] | None:\n    \"\"\"Performs the Exec with resource operation.\n\n    Wraps the `vaccel_exec_with_resource()` C operation.\n\n    Args:\n        resource: The resource of the shared object containing the function\n            that will be called.\n        symbol: The name of the function contained in the above shared\n            object.\n        arg_read: The input arguments that will be passed to the\n            called function.\n        arg_write: The output arguments that will be passed to the\n            called function.\n\n    Returns:\n        The resulting outputs.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    if arg_read is not None:\n        c_arg_read = CList([Arg(arg) for arg in arg_read])\n        c_arg_read_ptr = c_arg_read._c_ptr\n        c_arg_read_len = len(c_arg_read)\n    else:\n        c_arg_read = None\n        c_arg_read_ptr = ffi.NULL\n        c_arg_read_len = 0\n\n    if arg_write is not None:\n        c_arg_write = CList([Arg(arg) for arg in arg_write])\n        c_arg_write_ptr = c_arg_write._c_ptr\n        c_arg_write_len = len(c_arg_write)\n    else:\n        c_arg_write = None\n        c_arg_write_ptr = ffi.NULL\n        c_arg_write_len = 0\n\n    ret = lib.vaccel_exec_with_resource(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        symbol.encode(),\n        c_arg_read_ptr,\n        c_arg_read_len,\n        c_arg_write_ptr,\n        c_arg_write_len,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Exec with resource operation failed\")\n\n    if c_arg_write is not None:\n        return [c_arg_write[i].buf for i in range(len(c_arg_write))]\n    return None\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/exec/#vaccel.ops.exec.ExecMixin.exec_with_resource(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/exec/#vaccel.ops.exec.ExecMixin.exec_with_resource(symbol)","title":"<code>symbol</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/exec/#vaccel.ops.exec.ExecMixin.exec_with_resource(arg_read)","title":"<code>arg_read</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/exec/#vaccel.ops.exec.ExecMixin.exec_with_resource(arg_write)","title":"<code>arg_write</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/","title":"fpga","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/#vaccel.ops.fpga","title":"fpga","text":"<p>FPGA operations.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/#vaccel.ops.fpga.FpgaMixin","title":"FpgaMixin","text":"<p>Mixin providing the FPGA operations for a <code>Session</code>.</p> <p>This mixin is intended to be used in combination with <code>BaseSession</code> and should not be instantiated on its own.</p> Intended usage <p>class Session(BaseSession, FPGAMixin):     ...</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/#vaccel.ops.fpga.FpgaMixin.fpga_arraycopy","title":"fpga_arraycopy","text":"<pre><code>fpga_arraycopy(a: list[int]) -&gt; list[int]\n</code></pre> <p>Performs the matrix copying operation.</p> <p>Wraps the <code>vaccel_fpga_arraycopy()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The matrix A to be copied.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>A copy of the matrix A.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/fpga.py</code> <pre><code>def fpga_arraycopy(self, a: list[int]) -&gt; list[int]:\n    \"\"\"Performs the matrix copying operation.\n\n    Wraps the `vaccel_fpga_arraycopy()` C operation.\n\n    Args:\n        a: The matrix A to be copied.\n\n    Returns:\n        A copy of the matrix A.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_out_a = CList([0] * len(a))\n\n    ret = lib.vaccel_fpga_arraycopy(\n        self._c_ptr_or_raise, c_a._c_ptr, c_out_a._c_ptr, len(c_a)\n    )\n    if ret != 0:\n        raise FFIError(ret, \"FPGA array copy failed\")\n\n    return [int(item) for item in c_out_a.value]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/#vaccel.ops.fpga.FpgaMixin.fpga_arraycopy(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/#vaccel.ops.fpga.FpgaMixin.fpga_mmult","title":"fpga_mmult","text":"<pre><code>fpga_mmult(a: list[float], b: list[float]) -&gt; list[float]\n</code></pre> <p>Performs the matrix multiplication operation.</p> <p>Wraps the <code>vaccel_fpga_mmult()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[float]</code> <p>A matrix A.</p> required <code>list[float]</code> <p>A matrix B.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The multiplication result of matrices A and B.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/fpga.py</code> <pre><code>def fpga_mmult(self, a: list[float], b: list[float]) -&gt; list[float]:\n    \"\"\"Performs the matrix multiplication operation.\n\n    Wraps the `vaccel_fpga_mmult()` C operation.\n\n    Args:\n        a: A matrix A.\n        b: A matrix B.\n\n    Returns:\n        The multiplication result of matrices A and B.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_b = CList(b)\n    c_c = CList([float(0)] * len(a))\n\n    ret = lib.vaccel_fpga_mmult(\n        self._c_ptr_or_raise, c_a._c_ptr, c_b._c_ptr, c_c._c_ptr, len(c_a)\n    )\n    if ret != 0:\n        raise FFIError(ret, \"FPGA matrix multiplication failed\")\n\n    return [float(item) for item in c_c.value]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/#vaccel.ops.fpga.FpgaMixin.fpga_mmult(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/#vaccel.ops.fpga.FpgaMixin.fpga_mmult(b)","title":"<code>b</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/#vaccel.ops.fpga.FpgaMixin.fpga_parallel","title":"fpga_parallel","text":"<pre><code>fpga_parallel(a: list[float], b: list[float]) -&gt; (list[float], list[float])\n</code></pre> <p>Performs the parallel matrix addition and multiplication operation.</p> <p>Wraps the <code>vaccel_fpga_parallel()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[float]</code> <p>A matrix A.</p> required <code>list[float]</code> <p>A matrix B.</p> required <p>Returns:</p> Type Description <code>(list[float], list[float])</code> <p>A tuple containing: - The result of the addition of matrices A and B. - The result of the multiplication of matrices A and B.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/fpga.py</code> <pre><code>def fpga_parallel(\n    self, a: list[float], b: list[float]\n) -&gt; (list[float], list[float]):\n    \"\"\"Performs the parallel matrix addition and multiplication operation.\n\n    Wraps the `vaccel_fpga_parallel()` C operation.\n\n    Args:\n        a: A matrix A.\n        b: A matrix B.\n\n    Returns:\n        A tuple containing:\n            - The result of the addition of matrices A and B.\n            - The result of the multiplication of matrices A and B.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_b = CList(b)\n    c_add_output = CList([float(0)] * len(a))\n    c_mult_output = CList([float(0)] * len(a))\n\n    ret = lib.vaccel_fpga_parallel(\n        self._c_ptr_or_raise,\n        c_a._c_ptr,\n        c_b._c_ptr,\n        c_add_output._c_ptr,\n        c_mult_output._c_ptr,\n        len(c_a),\n    )\n    if ret != 0:\n        raise FFIError(\n            ret, \"FPGA parallel matrix addition and multiplication failed\"\n        )\n\n    return (\n        [float(item) for item in c_add_output.value],\n        [float(item) for item in c_mult_output.value],\n    )\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/#vaccel.ops.fpga.FpgaMixin.fpga_parallel(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/#vaccel.ops.fpga.FpgaMixin.fpga_parallel(b)","title":"<code>b</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/#vaccel.ops.fpga.FpgaMixin.fpga_vadd","title":"fpga_vadd","text":"<pre><code>fpga_vadd(a: list[float], b: list[float]) -&gt; list[float]\n</code></pre> <p>Performs the matrix addition operation.</p> <p>Wraps the <code>vaccel_fpga_vadd()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[float]</code> <p>A matrix A.</p> required <code>list[float]</code> <p>A matrix B.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The addition result of matrices A and B.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/fpga.py</code> <pre><code>def fpga_vadd(self, a: list[float], b: list[float]) -&gt; list[float]:\n    \"\"\"Performs the matrix addition operation.\n\n    Wraps the `vaccel_fpga_vadd()` C operation.\n\n    Args:\n        a: A matrix A.\n        b: A matrix B.\n\n    Returns:\n        The addition result of matrices A and B.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_b = CList(b)\n    c_c = CList([float(0)] * len(a))\n\n    ret = lib.vaccel_fpga_vadd(\n        self._c_ptr_or_raise,\n        c_a._c_ptr,\n        c_b._c_ptr,\n        c_c._c_ptr,\n        len(c_a),\n        len(c_b),\n    )\n    if ret != 0:\n        raise FFIError(ret, \"FPGA vector addition failed\")\n\n    return [float(item) for item in c_c.value]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/#vaccel.ops.fpga.FpgaMixin.fpga_vadd(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/fpga/#vaccel.ops.fpga.FpgaMixin.fpga_vadd(b)","title":"<code>b</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/genop/","title":"genop","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/genop/#vaccel.ops.genop","title":"genop","text":"<p>Generic operation.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/genop/#vaccel.ops.genop.GenopMixin","title":"GenopMixin","text":"<p>Mixin providing the Generic operation for a <code>Session</code>.</p> <p>This mixin is intended to be used in combination with <code>BaseSession</code> and should not be instantiated on its own.</p> Intended usage <p>class Session(BaseSession, GenopMixin):     ...</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/genop/#vaccel.ops.genop.GenopMixin.genop","title":"genop","text":"<pre><code>genop(arg_read: list[Arg], arg_write: list[Arg]) -&gt; None\n</code></pre> <p>Performs the Generic operation.</p> <p>Wraps the <code>vaccel_genop()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[Arg]</code> <p>The input arguments of the operation.</p> required <code>list[Arg]</code> <p>The output arguments of the operation. Modified in place.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/genop.py</code> <pre><code>def genop(self, arg_read: list[Arg], arg_write: list[Arg]) -&gt; None:\n    \"\"\"Performs the Generic operation.\n\n    Wraps the `vaccel_genop()` C operation.\n\n    Args:\n        arg_read: The input arguments of the operation.\n        arg_write: The output arguments of the operation. Modified in place.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_args_read = CList(arg_read)\n    c_args_write = CList(arg_write)\n\n    ret = lib.vaccel_genop(\n        self._c_ptr_or_raise,\n        c_args_read._c_ptr,\n        len(c_args_read),\n        c_args_write._c_ptr,\n        len(c_args_write),\n    )\n    if ret:\n        raise FFIError(ret, \"Generic operation failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/genop/#vaccel.ops.genop.GenopMixin.genop(arg_read)","title":"<code>arg_read</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/genop/#vaccel.ops.genop.GenopMixin.genop(arg_write)","title":"<code>arg_write</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/image/","title":"image","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/image/#vaccel.ops.image","title":"image","text":"<p>Image-related operations.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/image/#vaccel.ops.image.ImageMixin","title":"ImageMixin","text":"<p>Mixin providing image operations for a <code>Session</code>.</p> <p>This mixin is intended to be used in combination with <code>BaseSession</code> and should not be instantiated on its own.</p> Intended usage <p>class Session(BaseSession, ImageMixin):     ...</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/image/#vaccel.ops.image.ImageMixin.classify","title":"classify","text":"<pre><code>classify(image: bytes) -&gt; (str, str)\n</code></pre> <p>Performs the image classification operation.</p> <p>Wraps the <code>vaccel_image_classification()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>(str, str)</code> <p>A tuple containing: - The classification tag. - The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def classify(self, image: bytes) -&gt; (str, str):\n    \"\"\"Performs the image classification operation.\n\n    Wraps the `vaccel_image_classification()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        A tuple containing:\n            - The classification tag.\n            - The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_text = CBytes(bytearray(self._out_len))\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_classification(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_text._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_text),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image classification failed\")\n\n    return out_text.to_str(), out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/image/#vaccel.ops.image.ImageMixin.classify(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/image/#vaccel.ops.image.ImageMixin.depth","title":"depth","text":"<pre><code>depth(image: bytes) -&gt; str\n</code></pre> <p>Performs the image depth estimation operation.</p> <p>Wraps the <code>vaccel_image_depth()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def depth(self, image: bytes) -&gt; str:\n    \"\"\"Performs the image depth estimation operation.\n\n    Wraps the `vaccel_image_depth()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_depth(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image depth estimation failed\")\n\n    return out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/image/#vaccel.ops.image.ImageMixin.depth(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/image/#vaccel.ops.image.ImageMixin.detect","title":"detect","text":"<pre><code>detect(image: bytes) -&gt; str\n</code></pre> <p>Performs the image detection operation.</p> <p>Wraps the <code>vaccel_image_detection()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def detect(self, image: bytes) -&gt; str:\n    \"\"\"Performs the image detection operation.\n\n    Wraps the `vaccel_image_detection()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_detection(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image detection failed\")\n\n    return out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/image/#vaccel.ops.image.ImageMixin.detect(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/image/#vaccel.ops.image.ImageMixin.pose","title":"pose","text":"<pre><code>pose(image: bytes) -&gt; str\n</code></pre> <p>Performs the image pose estimation operation.</p> <p>Wraps the <code>vaccel_image_pose()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def pose(self, image: bytes) -&gt; str:\n    \"\"\"Performs the image pose estimation operation.\n\n    Wraps the `vaccel_image_pose()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_pose(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image pose estimation failed\")\n\n    return out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/image/#vaccel.ops.image.ImageMixin.pose(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/image/#vaccel.ops.image.ImageMixin.segment","title":"segment","text":"<pre><code>segment(image: bytes) -&gt; str\n</code></pre> <p>Performs the image segmentation operations.</p> <p>Wraps the <code>vaccel_image_segmentation()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def segment(self, image: bytes) -&gt; str:\n    \"\"\"Performs the image segmentation operations.\n\n    Wraps the `vaccel_image_segmentation()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_segmentation(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image segmentation failed\")\n\n    return out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/image/#vaccel.ops.image.ImageMixin.segment(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/minmax/","title":"minmax","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/minmax/#vaccel.ops.minmax","title":"minmax","text":"<p>Minmax operation.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/minmax/#vaccel.ops.minmax.MinmaxMixin","title":"MinmaxMixin","text":"<p>Mixin providing the Minmax operation for a <code>Session</code>.</p> <p>This mixin is intended to be used in combination with <code>BaseSession</code> and should not be instantiated on its own.</p> Intended usage <p>class Session(BaseSession, MinmaxMixin):     ...</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/minmax/#vaccel.ops.minmax.MinmaxMixin.minmax","title":"minmax","text":"<pre><code>minmax(\n    indata: bytes, ndata: int, low_threshold: int, high_threshold: int\n) -&gt; (bytes, float, float)\n</code></pre> <p>Performs the minmax operation.</p> <p>Wraps the <code>vaccel_minmax()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The input data as a <code>bytes</code> object.</p> required <code>int</code> <p>The number of data to be read provided data object.</p> required <code>int</code> <p>The threshold for the min value.</p> required <code>int</code> <p>The threshold for the max value.</p> required <p>Returns:</p> Type Description <code>(bytes, float, float)</code> <p>A tuple containing: - The resulting output data. - The detected min value of the data. - The detected max value of the data.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/minmax.py</code> <pre><code>def minmax(\n    self, indata: bytes, ndata: int, low_threshold: int, high_threshold: int\n) -&gt; (bytes, float, float):\n    \"\"\"Performs the minmax operation.\n\n    Wraps the `vaccel_minmax()` C operation.\n\n    Args:\n        indata: The input data as a `bytes` object.\n        ndata: The number of data to be read provided data object.\n        low_threshold: The threshold for the min value.\n        high_threshold: The threshold for the max value.\n\n    Returns:\n        A tuple containing:\n            - The resulting output data.\n            - The detected min value of the data.\n            - The detected max value of the data.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_indata = CBytes(indata)\n    c_outdata = CBytes(bytearray(ndata * ffi.sizeof(\"double\")))\n    c_min = CFloat(float(0), \"double\")\n    c_max = CFloat(float(0), \"double\")\n\n    ret = lib.vaccel_minmax(\n        self._c_ptr_or_raise,\n        c_indata._as_c_array(\"double\"),\n        ndata,\n        low_threshold,\n        high_threshold,\n        c_outdata._as_c_array(\"double\"),\n        c_min._c_ptr,\n        c_max._c_ptr,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Minmax operation failed\")\n\n    return (c_outdata.value, c_min.value, c_max.value)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/minmax/#vaccel.ops.minmax.MinmaxMixin.minmax(indata)","title":"<code>indata</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/minmax/#vaccel.ops.minmax.MinmaxMixin.minmax(ndata)","title":"<code>ndata</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/minmax/#vaccel.ops.minmax.MinmaxMixin.minmax(low_threshold)","title":"<code>low_threshold</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/minmax/#vaccel.ops.minmax.MinmaxMixin.minmax(high_threshold)","title":"<code>high_threshold</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/noop/","title":"noop","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/noop/#vaccel.ops.noop","title":"noop","text":"<p>Debug operation.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/noop/#vaccel.ops.noop.NoopMixin","title":"NoopMixin","text":"<p>Mixin providing the NoOp operation for a <code>Session</code>.</p> <p>This mixin is intended to be used in combination with <code>BaseSession</code> and should not be instantiated on its own.</p> Intended usage <p>class Session(BaseSession, NoopMixin):     ...</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/noop/#vaccel.ops.noop.NoopMixin.noop","title":"noop","text":"<pre><code>noop() -&gt; None\n</code></pre> <p>Performs the NoOp operation.</p> <p>Wraps the <code>vaccel_noop()</code> C operation.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/noop.py</code> <pre><code>def noop(self) -&gt; None:\n    \"\"\"Performs the NoOp operation.\n\n    Wraps the `vaccel_noop()` C operation.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_noop(self._c_ptr_or_raise)\n    if ret != 0:\n        raise FFIError(ret, \"NoOp operation failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/","title":"tf","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf","title":"tf","text":"<p>Tensorflow operations and objects.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Buffer","title":"Buffer","text":"<pre><code>Buffer(data: bytes | bytearray)\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_tf_buffer</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_tf_buffer</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>bytes | bytearray</code> <p>The buffer data to be passed to the C struct.</p> required Source code in <code>                vaccel/ops/tf/buffer.py</code> <pre><code>def __init__(self, data: bytes | bytearray):\n    \"\"\"Initializes a new `Buffer` object.\n\n    Args:\n        data: The buffer data to be passed to the C struct.\n    \"\"\"\n    self._data = data\n    self._c_data = None\n    self._c_obj_ptr = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Buffer(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Buffer.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Buffer.data","title":"data  <code>property</code>","text":"<pre><code>data: bytes\n</code></pre> <p>The buffer data.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The data of the buffer.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Buffer.size","title":"size  <code>property</code>","text":"<pre><code>size: int\n</code></pre> <p>The buffer size.</p> <p>Returns:</p> Type Description <code>int</code> <p>The size of the buffer.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Buffer.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_tf_buffer`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Node","title":"Node","text":"<pre><code>Node(name: str, id_: int)\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_tf_node</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_tf_node</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name to be passed to the C struct.</p> required <code>int</code> <p>The ID to be passed to the C struct.</p> required Source code in <code>                vaccel/ops/tf/node.py</code> <pre><code>def __init__(self, name: str, id_: int):\n    \"\"\"Initializes a new `Node` object.\n\n    Args:\n        name: The name to be passed to the C struct.\n        id_: The ID to be passed to the C struct.\n    \"\"\"\n    self._name = name\n    self._id = id_\n    self._c_obj_ptr = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Node(name)","title":"<code>name</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Node(id_)","title":"<code>id_</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Node.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Node.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre> <p>The node identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>The node's ID.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Node.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The node name.</p> <p>Returns:</p> Type Description <code>str</code> <p>The node's name.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Node.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_tf_node`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Status","title":"Status","text":"<pre><code>Status(error_code: int = 0, message: str = '')\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_tf_status</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_tf_status</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The error code to be passed to the C struct. Defaults to 0.</p> <code>0</code> <code>str</code> <p>The message to be passed to the C struct. Defaults to \"\".</p> <code>''</code> Source code in <code>                vaccel/ops/tf/status.py</code> <pre><code>def __init__(self, error_code: int = 0, message: str = \"\"):\n    \"\"\"Initializes a new `Status` object.\n\n    Args:\n        error_code: The error code to be passed to the C struct. Defaults\n            to 0.\n        message: The message to be passed to the C struct. Defaults to \"\".\n    \"\"\"\n    self._error_code = error_code\n    self._message = message\n    self._c_obj_ptr = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Status(error_code)","title":"<code>error_code</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Status(message)","title":"<code>message</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Status.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Status.code","title":"code  <code>property</code>","text":"<pre><code>code: int\n</code></pre> <p>The status error code.</p> <p>Returns:</p> Type Description <code>int</code> <p>The code of the status.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Status.message","title":"message  <code>property</code>","text":"<pre><code>message: str\n</code></pre> <p>The status message.</p> <p>Returns:</p> Type Description <code>str</code> <p>The message of the status.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Status.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_tf_status`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.TFMixin","title":"TFMixin","text":"<p>Mixin providing Tensorflow operations for a <code>Session</code>.</p> <p>This mixin is intended to be used in combination with <code>BaseSession</code> and should not be instantiated on its own.</p> Intended usage <p>class Session(BaseSession, TensorflowMixin):     ...</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.TFMixin.tf_model_load","title":"tf_model_load","text":"<pre><code>tf_model_load(resource: Resource) -&gt; Status\n</code></pre> <p>Performs the Tensorflow model load operation.</p> <p>Wraps the <code>vaccel_tf_model_load()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to load.</p> required <p>Returns:</p> Type Description <code>Status</code> <p>The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/mixin.py</code> <pre><code>def tf_model_load(self, resource: Resource) -&gt; Status:\n    \"\"\"Performs the Tensorflow model load operation.\n\n    Wraps the `vaccel_tf_model_load()` C operation.\n\n    Args:\n        resource: A resource with the model to load.\n\n    Returns:\n        The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    status = Status()\n    ret = lib.vaccel_tf_model_load(\n        self._c_ptr_or_raise, resource._c_ptr, status._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow model load failed\")\n    return status\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.TFMixin.tf_model_load(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.TFMixin.tf_model_run","title":"tf_model_run","text":"<pre><code>tf_model_run(\n    resource: Resource,\n    in_nodes: list[Node],\n    in_tensors: list[Tensor],\n    out_nodes: list[Node],\n    run_options: Buffer | None = None,\n) -&gt; (list[Tensor], Status)\n</code></pre> <p>Performs the Tensorflow model run operation.</p> <p>Wraps the <code>vaccel_tf_model_run()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to run.</p> required <code>list[Node]</code> <p>The input nodes for the inference.</p> required <code>list[Tensor]</code> <p>The input tensors for the inference.</p> required <code>list[Node]</code> <p>The output nodes for the inference.</p> required <code>Buffer | None</code> <p>The inference options.</p> <code>None</code> <p>Returns:</p> Type Description <code>(list[Tensor], Status)</code> <p>A tuple containing: - The output tensors - The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/mixin.py</code> <pre><code>def tf_model_run(\n    self,\n    resource: Resource,\n    in_nodes: list[Node],\n    in_tensors: list[Tensor],\n    out_nodes: list[Node],\n    run_options: Buffer | None = None,\n) -&gt; (list[Tensor], Status):\n    \"\"\"Performs the Tensorflow model run operation.\n\n    Wraps the `vaccel_tf_model_run()` C operation.\n\n    Args:\n        resource: A resource with the model to run.\n        in_nodes: The input nodes for the inference.\n        in_tensors: The input tensors for the inference.\n        out_nodes: The output nodes for the inference.\n        run_options: The inference options.\n\n    Returns:\n        A tuple containing:\n            - The output tensors\n            - The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    run_options_ptr = (\n        ffi.NULL if run_options is None else run_options._c_ptr\n    )\n    c_in_nodes = CList(in_nodes)\n    c_in_tensors = CList.from_ptrs(in_tensors)\n    c_out_nodes = CList(out_nodes)\n    c_out_tensors = CList.from_ptrs([Tensor.empty()] * len(c_out_nodes))\n    status = Status()\n\n    ret = lib.vaccel_tf_model_run(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        run_options_ptr,\n        c_in_nodes._c_ptr,\n        c_in_tensors._c_ptr,\n        len(c_in_nodes),\n        c_out_nodes._c_ptr,\n        c_out_tensors._c_ptr,\n        len(c_out_nodes),\n        status._c_ptr,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow model run failed\")\n\n    out_tensors = [Tensor.from_c_obj(t) for t in c_out_tensors.value]\n    return (out_tensors, status)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.TFMixin.tf_model_run(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.TFMixin.tf_model_run(in_nodes)","title":"<code>in_nodes</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.TFMixin.tf_model_run(in_tensors)","title":"<code>in_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.TFMixin.tf_model_run(out_nodes)","title":"<code>out_nodes</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.TFMixin.tf_model_run(run_options)","title":"<code>run_options</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.TFMixin.tf_model_unload","title":"tf_model_unload","text":"<pre><code>tf_model_unload(resource: Resource) -&gt; Status\n</code></pre> <p>Performs the Tensorflow model unload operation.</p> <p>Wraps the <code>vaccel_tf_model_unload()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to unload.</p> required <p>Returns:</p> Type Description <code>Status</code> <p>The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/mixin.py</code> <pre><code>def tf_model_unload(self, resource: Resource) -&gt; Status:\n    \"\"\"Performs the Tensorflow model unload operation.\n\n    Wraps the `vaccel_tf_model_unload()` C operation.\n\n    Args:\n        resource: A resource with the model to unload.\n\n    Returns:\n        The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    status = Status()\n    ret = lib.vaccel_tf_model_unload(\n        self._c_ptr_or_raise, resource._c_ptr, status._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow model unload failed\")\n    return status\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.TFMixin.tf_model_unload(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor","title":"Tensor","text":"<pre><code>Tensor(dims: list[int], data_type: TensorType, data: list[Any])\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_tf_tensor</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_tf_tensor</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The dims to be passed to the C struct.</p> required <code>TensorType</code> <p>The data_type to be passed to the C struct.</p> required <code>list[Any]</code> <p>The data to be passed to the C struct.</p> required Source code in <code>                vaccel/ops/tf/tensor.py</code> <pre><code>def __init__(self, dims: list[int], data_type: TensorType, data: list[Any]):\n    \"\"\"Initializes a new `Tensor` object.\n\n    Args:\n        dims: The dims to be passed to the C struct.\n        data_type: The data_type to be passed to the C struct.\n        data: The data to be passed to the C struct.\n    \"\"\"\n    self._dims = dims\n    self._data = data\n    self._data_type = data_type\n    self._c_data = None\n    self._c_obj_ptr = ffi.NULL\n    self._c_obj_data = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor(dims)","title":"<code>dims</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor(data_type)","title":"<code>data_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.data","title":"data  <code>property</code>","text":"<pre><code>data: list\n</code></pre> <p>The tensor data.</p> <p>Returns:</p> Type Description <code>list</code> <p>The data of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.data_type","title":"data_type  <code>property</code>","text":"<pre><code>data_type: TensorType\n</code></pre> <p>The tensor data type.</p> <p>Returns:</p> Type Description <code>TensorType</code> <p>The data type of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: list[int]\n</code></pre> <p>The tensor dims.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The dims of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: list[int]\n</code></pre> <p>The tensor shape.</p> <p>Alias of <code>Tensor.dims</code>.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The shape of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_tf_tensor`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.as_bytelike","title":"as_bytelike","text":"<pre><code>as_bytelike() -&gt; bytes | bytearray | memoryview\n</code></pre> <p>Returns the tensor data buffer as a byte-like object.</p> <p>Returns:</p> Type Description <code>bytes | bytearray | memoryview</code> <p>The data of the tensor as a byte-like object.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>def as_bytelike(self) -&gt; bytes | bytearray | memoryview:\n    \"\"\"Returns the tensor data buffer as a byte-like object.\n\n    Returns:\n        The data of the tensor as a byte-like object.\n    \"\"\"\n    if self._c_data is not None:\n        if isinstance(self._c_data, CBytes):\n            return self._c_data.value\n        return self._c_data.as_memoryview()\n    return CBytes.from_c_obj(\n        self._c_ptr_or_raise.data, self._c_ptr_or_raise.size\n    ).value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.as_memoryview","title":"as_memoryview","text":"<pre><code>as_memoryview() -&gt; memoryview\n</code></pre> <p>Returns the tensor data buffer as memoryview.</p> <p>Returns:</p> Type Description <code>memoryview</code> <p>The data of the tensor as memoryview.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>def as_memoryview(self) -&gt; memoryview:\n    \"\"\"Returns the tensor data buffer as memoryview.\n\n    Returns:\n        The data of the tensor as memoryview.\n    \"\"\"\n    data = self.as_bytelike()\n    return data if isinstance(data, memoryview) else memoryview(data)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.as_numpy","title":"as_numpy","text":"<pre><code>as_numpy() -&gt; ndarray\n</code></pre> <p>Returns the tensor data buffer as a NumPy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The data of the tensor as a NumPy array.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>def as_numpy(self) -&gt; \"np.ndarray\":\n    \"\"\"Returns the tensor data buffer as a NumPy array.\n\n    Returns:\n        The data of the tensor as a NumPy array.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    if isinstance(self._c_data, CNumpyArray):\n        return self._c_data.value\n\n    dtype = TensorTypeMapper.type_to_numpy(self.data_type)\n    return CNumpyArray.from_c_obj(\n        self._c_ptr_or_raise.data,\n        self._c_ptr_or_raise.size,\n        self.shape,\n        dtype,\n    ).value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.empty","title":"empty  <code>classmethod</code>","text":"<pre><code>empty() -&gt; Tensor\n</code></pre> <p>Initializes a new empty <code>Tensor</code> object.</p> <p>The object has a NULL pointer in place of the C struct.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>@classmethod\ndef empty(cls) -&gt; \"Tensor\":\n    \"\"\"Initializes a new empty `Tensor` object.\n\n    The object has a NULL pointer in place of the C struct.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    inst = cls.__new__(cls)\n    inst._dims = None\n    inst._data = None\n    inst._data_type = None\n    inst._c_data = None\n    inst._c_obj_ptr = ffi.new(\"struct vaccel_tf_tensor **\")\n    inst._c_obj = inst._c_obj_ptr[0]\n    inst._c_obj_ptr[0] = ffi.NULL\n    inst._c_size = ffi.sizeof(\"struct vaccel_tf_tensor *\")\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.from_buffer","title":"from_buffer  <code>classmethod</code>","text":"<pre><code>from_buffer(\n    dims: list[int], data_type: TensorType, data: bytes | bytearray | memoryview\n) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from byte-like data.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The dims to be passed to the C struct.</p> required <code>TensorType</code> <p>The data_type to be passed to the C struct.</p> required <code>bytes | bytearray | memoryview</code> <p>The data to be passed to the C struct.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>@classmethod\ndef from_buffer(\n    cls,\n    dims: list[int],\n    data_type: TensorType,\n    data: bytes | bytearray | memoryview,\n) -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from byte-like data.\n\n    Args:\n        dims: The dims to be passed to the C struct.\n        data_type: The data_type to be passed to the C struct.\n        data: The data to be passed to the C struct.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    inst = cls.__new__(cls)\n    inst._dims = dims\n    inst._data = data\n    inst._data_type = data_type\n    inst._c_data = CBytes(inst._data)\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.from_buffer(dims)","title":"<code>dims</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.from_buffer(data_type)","title":"<code>data_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.from_buffer(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.from_c_obj","title":"from_c_obj  <code>classmethod</code>","text":"<pre><code>from_c_obj(c_obj: CData) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from an existing C struct.</p> <p>Parameters:</p> Name Type Description Default <code>CData</code> <p>A pointer to a <code>struct vaccel_tf_tensor</code> C object.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>@classmethod\ndef from_c_obj(cls, c_obj: ffi.CData) -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from an existing C struct.\n\n    Args:\n        c_obj: A pointer to a `struct vaccel_tf_tensor` C object.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    type_str = ffi.getctype(ffi.typeof(c_obj))\n    if type_str != \"struct vaccel_tf_tensor *\":\n        msg = f\"Expected 'struct vaccel_tf_tensor *', got '{type_str}'\"\n        raise TypeError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = None\n    inst._data = None\n    inst._data_type = None\n    inst._c_data = None\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = ffi.NULL\n    inst._c_obj = c_obj\n    inst._c_size = ffi.sizeof(inst._c_obj)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.from_c_obj(c_obj)","title":"<code>c_obj</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.from_numpy","title":"from_numpy  <code>classmethod</code>","text":"<pre><code>from_numpy(data: ndarray) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>The NumPy array containing the tensor data.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If NumPy is not installed.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>@classmethod\ndef from_numpy(cls, data: \"np.ndarray\") -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from a NumPy array.\n\n    Args:\n        data: The NumPy array containing the tensor data.\n\n    Returns:\n        A new `Tensor` object\n\n    Raises:\n        NotImplementedError: If NumPy is not installed.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = list(data.shape)\n    inst._data = data\n    inst._data_type = TensorTypeMapper.type_from_numpy(inst._data.dtype)\n    inst._c_data = CNumpyArray(inst._data)\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.from_numpy(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/#vaccel.ops.tf.Tensor.to_bytes","title":"to_bytes","text":"<pre><code>to_bytes() -&gt; bytes\n</code></pre> <p>Returns the tensor data buffer as bytes.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The data of the tensor as bytes.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>def to_bytes(self) -&gt; bytes:\n    \"\"\"Returns the tensor data buffer as bytes.\n\n    Returns:\n        The data of the tensor as bytes.\n    \"\"\"\n    data = self.as_bytelike()\n    return data if isinstance(data, bytes) else bytes(data)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/buffer/","title":"buffer","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/buffer/#vaccel.ops.tf.buffer","title":"buffer","text":"<p>Interface to the <code>struct vaccel_tf_buffer</code> C object.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/buffer/#vaccel.ops.tf.buffer.Buffer","title":"Buffer","text":"<pre><code>Buffer(data: bytes | bytearray)\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_tf_buffer</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_tf_buffer</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>bytes | bytearray</code> <p>The buffer data to be passed to the C struct.</p> required Source code in <code>                vaccel/ops/tf/buffer.py</code> <pre><code>def __init__(self, data: bytes | bytearray):\n    \"\"\"Initializes a new `Buffer` object.\n\n    Args:\n        data: The buffer data to be passed to the C struct.\n    \"\"\"\n    self._data = data\n    self._c_data = None\n    self._c_obj_ptr = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/buffer/#vaccel.ops.tf.buffer.Buffer(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/buffer/#vaccel.ops.tf.buffer.Buffer.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/buffer/#vaccel.ops.tf.buffer.Buffer.data","title":"data  <code>property</code>","text":"<pre><code>data: bytes\n</code></pre> <p>The buffer data.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The data of the buffer.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/buffer/#vaccel.ops.tf.buffer.Buffer.size","title":"size  <code>property</code>","text":"<pre><code>size: int\n</code></pre> <p>The buffer size.</p> <p>Returns:</p> Type Description <code>int</code> <p>The size of the buffer.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/buffer/#vaccel.ops.tf.buffer.Buffer.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_tf_buffer`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/","title":"lite","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite","title":"lite","text":"<p>Tensorflow Lite operations and objects.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.TFLiteMixin","title":"TFLiteMixin","text":"<p>Mixin providing Tensorflow Lite operations for a <code>Session</code>.</p> <p>This mixin is intended to be used in combination with <code>BaseSession</code> and should not be instantiated on its own.</p> Intended usage <p>class Session(BaseSession, TensorflowLiteMixin):     ...</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.TFLiteMixin.tflite_model_load","title":"tflite_model_load","text":"<pre><code>tflite_model_load(resource: Resource) -&gt; None\n</code></pre> <p>Performs the Tensorflow Lite model load operation.</p> <p>Wraps the <code>vaccel_tflite_model_load()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to load.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/lite/mixin.py</code> <pre><code>def tflite_model_load(self, resource: Resource) -&gt; None:\n    \"\"\"Performs the Tensorflow Lite model load operation.\n\n    Wraps the `vaccel_tflite_model_load()` C operation.\n\n    Args:\n        resource: A resource with the model to load.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_tflite_model_load(\n        self._c_ptr_or_raise, resource._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow Lite model load failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.TFLiteMixin.tflite_model_load(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.TFLiteMixin.tflite_model_run","title":"tflite_model_run","text":"<pre><code>tflite_model_run(\n    resource: Resource, in_tensors: list[Tensor], nr_out_tensors: int = 1\n) -&gt; (list[Tensor], int)\n</code></pre> <p>Performs the Tensorflow Lite model run operation.</p> <p>Wraps the <code>vaccel_tflite_model_run()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to run.</p> required <code>list[Tensor]</code> <p>The input tensors for the inference.</p> required <code>int</code> <p>The number of output tensors. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>(list[Tensor], int)</code> <p>A tuple containing: - The output tensors - The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/lite/mixin.py</code> <pre><code>def tflite_model_run(\n    self,\n    resource: Resource,\n    in_tensors: list[Tensor],\n    nr_out_tensors: int = 1,\n) -&gt; (list[Tensor], int):\n    \"\"\"Performs the Tensorflow Lite model run operation.\n\n    Wraps the `vaccel_tflite_model_run()` C operation.\n\n    Args:\n        resource: A resource with the model to run.\n        in_tensors: The input tensors for the inference.\n        nr_out_tensors: The number of output tensors. Defaults to 1.\n\n    Returns:\n        A tuple containing:\n            - The output tensors\n            - The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_in_tensors = CList.from_ptrs(in_tensors)\n    c_out_tensors = CList.from_ptrs([Tensor.empty()] * nr_out_tensors)\n    status = CInt(0, \"uint8_t\")\n\n    ret = lib.vaccel_tflite_model_run(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        c_in_tensors._c_ptr,\n        len(c_in_tensors),\n        c_out_tensors._c_ptr,\n        len(c_out_tensors),\n        status._c_ptr,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow Lite model run failed\")\n\n    out_tensors = [Tensor.from_c_obj(t) for t in c_out_tensors.value]\n    return (out_tensors, status.value)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.TFLiteMixin.tflite_model_run(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.TFLiteMixin.tflite_model_run(in_tensors)","title":"<code>in_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.TFLiteMixin.tflite_model_run(nr_out_tensors)","title":"<code>nr_out_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.TFLiteMixin.tflite_model_unload","title":"tflite_model_unload","text":"<pre><code>tflite_model_unload(resource: Resource) -&gt; None\n</code></pre> <p>Performs the Tensorflow Lite model unload operation.</p> <p>Wraps the <code>vaccel_tflite_model_unload()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to unload.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/lite/mixin.py</code> <pre><code>def tflite_model_unload(self, resource: Resource) -&gt; None:\n    \"\"\"Performs the Tensorflow Lite model unload operation.\n\n    Wraps the `vaccel_tflite_model_unload()` C operation.\n\n    Args:\n        resource: A resource with the model to unload.\n\n    Returns:\n        The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_tflite_model_unload(\n        self._c_ptr_or_raise, resource._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow Lite model unload failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.TFLiteMixin.tflite_model_unload(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor","title":"Tensor","text":"<pre><code>Tensor(dims: list[int], data_type: TensorType, data: list[Any])\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_tflite_tensor</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_tflite_tensor</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The dims to be passed to the C struct.</p> required <code>TensorType</code> <p>The data_type to be passed to the C struct.</p> required <code>list[Any]</code> <p>The data to be passed to the C struct.</p> required Source code in <code>                vaccel/ops/tf/lite/tensor.py</code> <pre><code>def __init__(self, dims: list[int], data_type: TensorType, data: list[Any]):\n    \"\"\"Initializes a new `Tensor` object.\n\n    Args:\n        dims: The dims to be passed to the C struct.\n        data_type: The data_type to be passed to the C struct.\n        data: The data to be passed to the C struct.\n    \"\"\"\n    self._dims = dims\n    self._data = data\n    self._data_type = data_type\n    self._c_data = None\n    self._c_obj_ptr = ffi.NULL\n    self._c_obj_data = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor(dims)","title":"<code>dims</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor(data_type)","title":"<code>data_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.data","title":"data  <code>property</code>","text":"<pre><code>data: list\n</code></pre> <p>The tensor data.</p> <p>Returns:</p> Type Description <code>list</code> <p>The data of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.data_type","title":"data_type  <code>property</code>","text":"<pre><code>data_type: TensorType\n</code></pre> <p>The tensor data type.</p> <p>Returns:</p> Type Description <code>TensorType</code> <p>The data type of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: list[int]\n</code></pre> <p>The tensor dims.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The dims of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: list[int]\n</code></pre> <p>The tensor shape.</p> <p>Alias of <code>Tensor.dims</code>.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The shape of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_tflite_tensor`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.as_bytelike","title":"as_bytelike","text":"<pre><code>as_bytelike() -&gt; bytes | bytearray | memoryview\n</code></pre> <p>Returns the tensor data buffer as a byte-like object.</p> <p>Returns:</p> Type Description <code>bytes | bytearray | memoryview</code> <p>The data of the tensor as a byte-like object.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>def as_bytelike(self) -&gt; bytes | bytearray | memoryview:\n    \"\"\"Returns the tensor data buffer as a byte-like object.\n\n    Returns:\n        The data of the tensor as a byte-like object.\n    \"\"\"\n    if self._c_data is not None:\n        if isinstance(self._c_data, CBytes):\n            return self._c_data.value\n        return self._c_data.as_memoryview()\n    return CBytes.from_c_obj(\n        self._c_ptr_or_raise.data, self._c_ptr_or_raise.size\n    ).value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.as_memoryview","title":"as_memoryview","text":"<pre><code>as_memoryview() -&gt; memoryview\n</code></pre> <p>Returns the tensor data buffer as memoryview.</p> <p>Returns:</p> Type Description <code>memoryview</code> <p>The data of the tensor as memoryview.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>def as_memoryview(self) -&gt; memoryview:\n    \"\"\"Returns the tensor data buffer as memoryview.\n\n    Returns:\n        The data of the tensor as memoryview.\n    \"\"\"\n    data = self.as_bytelike()\n    return data if isinstance(data, memoryview) else memoryview(data)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.as_numpy","title":"as_numpy","text":"<pre><code>as_numpy() -&gt; ndarray\n</code></pre> <p>Returns the tensor data buffer as a NumPy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The data of the tensor as a NumPy array.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>def as_numpy(self) -&gt; \"np.ndarray\":\n    \"\"\"Returns the tensor data buffer as a NumPy array.\n\n    Returns:\n        The data of the tensor as a NumPy array.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    if isinstance(self._c_data, CNumpyArray):\n        return self._c_data.value\n\n    dtype = TensorTypeMapper.type_to_numpy(self.data_type)\n    return CNumpyArray.from_c_obj(\n        self._c_ptr_or_raise.data,\n        self._c_ptr_or_raise.size,\n        self.shape,\n        dtype,\n    ).value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.empty","title":"empty  <code>classmethod</code>","text":"<pre><code>empty() -&gt; Tensor\n</code></pre> <p>Initializes a new empty <code>Tensor</code> object.</p> <p>The object has a NULL pointer in place of the C struct.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>@classmethod\ndef empty(cls) -&gt; \"Tensor\":\n    \"\"\"Initializes a new empty `Tensor` object.\n\n    The object has a NULL pointer in place of the C struct.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    inst = cls.__new__(cls)\n    inst._dims = None\n    inst._data = None\n    inst._data_type = None\n    inst._c_data = None\n    inst._c_obj_ptr = ffi.new(\"struct vaccel_tflite_tensor **\")\n    inst._c_obj = inst._c_obj_ptr[0]\n    inst._c_obj_ptr[0] = ffi.NULL\n    inst._c_size = ffi.sizeof(\"struct vaccel_tflite_tensor *\")\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.from_buffer","title":"from_buffer  <code>classmethod</code>","text":"<pre><code>from_buffer(\n    dims: list[int], data_type: TensorType, data: bytes | bytearray | memoryview\n) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from byte-like data.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The dims to be passed to the C struct.</p> required <code>TensorType</code> <p>The data_type to be passed to the C struct.</p> required <code>bytes | bytearray | memoryview</code> <p>The data to be passed to the C struct.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>@classmethod\ndef from_buffer(\n    cls,\n    dims: list[int],\n    data_type: TensorType,\n    data: bytes | bytearray | memoryview,\n) -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from byte-like data.\n\n    Args:\n        dims: The dims to be passed to the C struct.\n        data_type: The data_type to be passed to the C struct.\n        data: The data to be passed to the C struct.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    inst = cls.__new__(cls)\n    inst._dims = dims\n    inst._data = data\n    inst._data_type = data_type\n    inst._c_data = CBytes(inst._data)\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.from_buffer(dims)","title":"<code>dims</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.from_buffer(data_type)","title":"<code>data_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.from_buffer(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.from_c_obj","title":"from_c_obj  <code>classmethod</code>","text":"<pre><code>from_c_obj(c_obj: CData) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from an existing C struct.</p> <p>Parameters:</p> Name Type Description Default <code>CData</code> <p>A pointer to a <code>struct vaccel_tflite_tensor</code> C object.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>@classmethod\ndef from_c_obj(cls, c_obj: ffi.CData) -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from an existing C struct.\n\n    Args:\n        c_obj: A pointer to a `struct vaccel_tflite_tensor` C object.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    type_str = ffi.getctype(ffi.typeof(c_obj))\n    if type_str != \"struct vaccel_tflite_tensor *\":\n        msg = f\"Expected 'struct vaccel_tflite_tensor *', got '{type_str}'\"\n        raise TypeError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = None\n    inst._data = None\n    inst._data_type = None\n    inst._c_data = None\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = ffi.NULL\n    inst._c_obj = c_obj\n    inst._c_size = ffi.sizeof(inst._c_obj)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.from_c_obj(c_obj)","title":"<code>c_obj</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.from_numpy","title":"from_numpy  <code>classmethod</code>","text":"<pre><code>from_numpy(data: ndarray) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>The NumPy array containing the tensor data.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If NumPy is not installed.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>@classmethod\ndef from_numpy(cls, data: \"np.ndarray\") -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from a NumPy array.\n\n    Args:\n        data: The NumPy array containing the tensor data.\n\n    Returns:\n        A new `Tensor` object\n\n    Raises:\n        NotImplementedError: If NumPy is not installed.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = list(data.shape)\n    inst._data = data\n    inst._data_type = TensorTypeMapper.type_from_numpy(inst._data.dtype)\n    inst._c_data = CNumpyArray(inst._data)\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.from_numpy(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/#vaccel.ops.tf.lite.Tensor.to_bytes","title":"to_bytes","text":"<pre><code>to_bytes() -&gt; bytes\n</code></pre> <p>Returns the tensor data buffer as bytes.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The data of the tensor as bytes.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>def to_bytes(self) -&gt; bytes:\n    \"\"\"Returns the tensor data buffer as bytes.\n\n    Returns:\n        The data of the tensor as bytes.\n    \"\"\"\n    data = self.as_bytelike()\n    return data if isinstance(data, bytes) else bytes(data)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/mixin/","title":"mixin","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/mixin/#vaccel.ops.tf.lite.mixin","title":"mixin","text":"<p>Tensorflow Lite operations.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/mixin/#vaccel.ops.tf.lite.mixin.TFLiteMixin","title":"TFLiteMixin","text":"<p>Mixin providing Tensorflow Lite operations for a <code>Session</code>.</p> <p>This mixin is intended to be used in combination with <code>BaseSession</code> and should not be instantiated on its own.</p> Intended usage <p>class Session(BaseSession, TensorflowLiteMixin):     ...</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/mixin/#vaccel.ops.tf.lite.mixin.TFLiteMixin.tflite_model_load","title":"tflite_model_load","text":"<pre><code>tflite_model_load(resource: Resource) -&gt; None\n</code></pre> <p>Performs the Tensorflow Lite model load operation.</p> <p>Wraps the <code>vaccel_tflite_model_load()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to load.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/lite/mixin.py</code> <pre><code>def tflite_model_load(self, resource: Resource) -&gt; None:\n    \"\"\"Performs the Tensorflow Lite model load operation.\n\n    Wraps the `vaccel_tflite_model_load()` C operation.\n\n    Args:\n        resource: A resource with the model to load.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_tflite_model_load(\n        self._c_ptr_or_raise, resource._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow Lite model load failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/mixin/#vaccel.ops.tf.lite.mixin.TFLiteMixin.tflite_model_load(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/mixin/#vaccel.ops.tf.lite.mixin.TFLiteMixin.tflite_model_run","title":"tflite_model_run","text":"<pre><code>tflite_model_run(\n    resource: Resource, in_tensors: list[Tensor], nr_out_tensors: int = 1\n) -&gt; (list[Tensor], int)\n</code></pre> <p>Performs the Tensorflow Lite model run operation.</p> <p>Wraps the <code>vaccel_tflite_model_run()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to run.</p> required <code>list[Tensor]</code> <p>The input tensors for the inference.</p> required <code>int</code> <p>The number of output tensors. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>(list[Tensor], int)</code> <p>A tuple containing: - The output tensors - The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/lite/mixin.py</code> <pre><code>def tflite_model_run(\n    self,\n    resource: Resource,\n    in_tensors: list[Tensor],\n    nr_out_tensors: int = 1,\n) -&gt; (list[Tensor], int):\n    \"\"\"Performs the Tensorflow Lite model run operation.\n\n    Wraps the `vaccel_tflite_model_run()` C operation.\n\n    Args:\n        resource: A resource with the model to run.\n        in_tensors: The input tensors for the inference.\n        nr_out_tensors: The number of output tensors. Defaults to 1.\n\n    Returns:\n        A tuple containing:\n            - The output tensors\n            - The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_in_tensors = CList.from_ptrs(in_tensors)\n    c_out_tensors = CList.from_ptrs([Tensor.empty()] * nr_out_tensors)\n    status = CInt(0, \"uint8_t\")\n\n    ret = lib.vaccel_tflite_model_run(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        c_in_tensors._c_ptr,\n        len(c_in_tensors),\n        c_out_tensors._c_ptr,\n        len(c_out_tensors),\n        status._c_ptr,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow Lite model run failed\")\n\n    out_tensors = [Tensor.from_c_obj(t) for t in c_out_tensors.value]\n    return (out_tensors, status.value)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/mixin/#vaccel.ops.tf.lite.mixin.TFLiteMixin.tflite_model_run(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/mixin/#vaccel.ops.tf.lite.mixin.TFLiteMixin.tflite_model_run(in_tensors)","title":"<code>in_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/mixin/#vaccel.ops.tf.lite.mixin.TFLiteMixin.tflite_model_run(nr_out_tensors)","title":"<code>nr_out_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/mixin/#vaccel.ops.tf.lite.mixin.TFLiteMixin.tflite_model_unload","title":"tflite_model_unload","text":"<pre><code>tflite_model_unload(resource: Resource) -&gt; None\n</code></pre> <p>Performs the Tensorflow Lite model unload operation.</p> <p>Wraps the <code>vaccel_tflite_model_unload()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to unload.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/lite/mixin.py</code> <pre><code>def tflite_model_unload(self, resource: Resource) -&gt; None:\n    \"\"\"Performs the Tensorflow Lite model unload operation.\n\n    Wraps the `vaccel_tflite_model_unload()` C operation.\n\n    Args:\n        resource: A resource with the model to unload.\n\n    Returns:\n        The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_tflite_model_unload(\n        self._c_ptr_or_raise, resource._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow Lite model unload failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/mixin/#vaccel.ops.tf.lite.mixin.TFLiteMixin.tflite_model_unload(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/","title":"tensor","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor","title":"tensor","text":"<p>Interface to the <code>struct vaccel_tflite_tensor</code> C object.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor","title":"Tensor","text":"<pre><code>Tensor(dims: list[int], data_type: TensorType, data: list[Any])\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_tflite_tensor</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_tflite_tensor</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The dims to be passed to the C struct.</p> required <code>TensorType</code> <p>The data_type to be passed to the C struct.</p> required <code>list[Any]</code> <p>The data to be passed to the C struct.</p> required Source code in <code>                vaccel/ops/tf/lite/tensor.py</code> <pre><code>def __init__(self, dims: list[int], data_type: TensorType, data: list[Any]):\n    \"\"\"Initializes a new `Tensor` object.\n\n    Args:\n        dims: The dims to be passed to the C struct.\n        data_type: The data_type to be passed to the C struct.\n        data: The data to be passed to the C struct.\n    \"\"\"\n    self._dims = dims\n    self._data = data\n    self._data_type = data_type\n    self._c_data = None\n    self._c_obj_ptr = ffi.NULL\n    self._c_obj_data = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor(dims)","title":"<code>dims</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor(data_type)","title":"<code>data_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.data","title":"data  <code>property</code>","text":"<pre><code>data: list\n</code></pre> <p>The tensor data.</p> <p>Returns:</p> Type Description <code>list</code> <p>The data of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.data_type","title":"data_type  <code>property</code>","text":"<pre><code>data_type: TensorType\n</code></pre> <p>The tensor data type.</p> <p>Returns:</p> Type Description <code>TensorType</code> <p>The data type of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: list[int]\n</code></pre> <p>The tensor dims.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The dims of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: list[int]\n</code></pre> <p>The tensor shape.</p> <p>Alias of <code>Tensor.dims</code>.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The shape of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_tflite_tensor`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.as_bytelike","title":"as_bytelike","text":"<pre><code>as_bytelike() -&gt; bytes | bytearray | memoryview\n</code></pre> <p>Returns the tensor data buffer as a byte-like object.</p> <p>Returns:</p> Type Description <code>bytes | bytearray | memoryview</code> <p>The data of the tensor as a byte-like object.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>def as_bytelike(self) -&gt; bytes | bytearray | memoryview:\n    \"\"\"Returns the tensor data buffer as a byte-like object.\n\n    Returns:\n        The data of the tensor as a byte-like object.\n    \"\"\"\n    if self._c_data is not None:\n        if isinstance(self._c_data, CBytes):\n            return self._c_data.value\n        return self._c_data.as_memoryview()\n    return CBytes.from_c_obj(\n        self._c_ptr_or_raise.data, self._c_ptr_or_raise.size\n    ).value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.as_memoryview","title":"as_memoryview","text":"<pre><code>as_memoryview() -&gt; memoryview\n</code></pre> <p>Returns the tensor data buffer as memoryview.</p> <p>Returns:</p> Type Description <code>memoryview</code> <p>The data of the tensor as memoryview.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>def as_memoryview(self) -&gt; memoryview:\n    \"\"\"Returns the tensor data buffer as memoryview.\n\n    Returns:\n        The data of the tensor as memoryview.\n    \"\"\"\n    data = self.as_bytelike()\n    return data if isinstance(data, memoryview) else memoryview(data)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.as_numpy","title":"as_numpy","text":"<pre><code>as_numpy() -&gt; ndarray\n</code></pre> <p>Returns the tensor data buffer as a NumPy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The data of the tensor as a NumPy array.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>def as_numpy(self) -&gt; \"np.ndarray\":\n    \"\"\"Returns the tensor data buffer as a NumPy array.\n\n    Returns:\n        The data of the tensor as a NumPy array.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    if isinstance(self._c_data, CNumpyArray):\n        return self._c_data.value\n\n    dtype = TensorTypeMapper.type_to_numpy(self.data_type)\n    return CNumpyArray.from_c_obj(\n        self._c_ptr_or_raise.data,\n        self._c_ptr_or_raise.size,\n        self.shape,\n        dtype,\n    ).value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.empty","title":"empty  <code>classmethod</code>","text":"<pre><code>empty() -&gt; Tensor\n</code></pre> <p>Initializes a new empty <code>Tensor</code> object.</p> <p>The object has a NULL pointer in place of the C struct.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>@classmethod\ndef empty(cls) -&gt; \"Tensor\":\n    \"\"\"Initializes a new empty `Tensor` object.\n\n    The object has a NULL pointer in place of the C struct.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    inst = cls.__new__(cls)\n    inst._dims = None\n    inst._data = None\n    inst._data_type = None\n    inst._c_data = None\n    inst._c_obj_ptr = ffi.new(\"struct vaccel_tflite_tensor **\")\n    inst._c_obj = inst._c_obj_ptr[0]\n    inst._c_obj_ptr[0] = ffi.NULL\n    inst._c_size = ffi.sizeof(\"struct vaccel_tflite_tensor *\")\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.from_buffer","title":"from_buffer  <code>classmethod</code>","text":"<pre><code>from_buffer(\n    dims: list[int], data_type: TensorType, data: bytes | bytearray | memoryview\n) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from byte-like data.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The dims to be passed to the C struct.</p> required <code>TensorType</code> <p>The data_type to be passed to the C struct.</p> required <code>bytes | bytearray | memoryview</code> <p>The data to be passed to the C struct.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>@classmethod\ndef from_buffer(\n    cls,\n    dims: list[int],\n    data_type: TensorType,\n    data: bytes | bytearray | memoryview,\n) -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from byte-like data.\n\n    Args:\n        dims: The dims to be passed to the C struct.\n        data_type: The data_type to be passed to the C struct.\n        data: The data to be passed to the C struct.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    inst = cls.__new__(cls)\n    inst._dims = dims\n    inst._data = data\n    inst._data_type = data_type\n    inst._c_data = CBytes(inst._data)\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.from_buffer(dims)","title":"<code>dims</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.from_buffer(data_type)","title":"<code>data_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.from_buffer(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.from_c_obj","title":"from_c_obj  <code>classmethod</code>","text":"<pre><code>from_c_obj(c_obj: CData) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from an existing C struct.</p> <p>Parameters:</p> Name Type Description Default <code>CData</code> <p>A pointer to a <code>struct vaccel_tflite_tensor</code> C object.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>@classmethod\ndef from_c_obj(cls, c_obj: ffi.CData) -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from an existing C struct.\n\n    Args:\n        c_obj: A pointer to a `struct vaccel_tflite_tensor` C object.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    type_str = ffi.getctype(ffi.typeof(c_obj))\n    if type_str != \"struct vaccel_tflite_tensor *\":\n        msg = f\"Expected 'struct vaccel_tflite_tensor *', got '{type_str}'\"\n        raise TypeError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = None\n    inst._data = None\n    inst._data_type = None\n    inst._c_data = None\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = ffi.NULL\n    inst._c_obj = c_obj\n    inst._c_size = ffi.sizeof(inst._c_obj)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.from_c_obj(c_obj)","title":"<code>c_obj</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.from_numpy","title":"from_numpy  <code>classmethod</code>","text":"<pre><code>from_numpy(data: ndarray) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>The NumPy array containing the tensor data.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If NumPy is not installed.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>@classmethod\ndef from_numpy(cls, data: \"np.ndarray\") -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from a NumPy array.\n\n    Args:\n        data: The NumPy array containing the tensor data.\n\n    Returns:\n        A new `Tensor` object\n\n    Raises:\n        NotImplementedError: If NumPy is not installed.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = list(data.shape)\n    inst._data = data\n    inst._data_type = TensorTypeMapper.type_from_numpy(inst._data.dtype)\n    inst._c_data = CNumpyArray(inst._data)\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.from_numpy(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.Tensor.to_bytes","title":"to_bytes","text":"<pre><code>to_bytes() -&gt; bytes\n</code></pre> <p>Returns the tensor data buffer as bytes.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The data of the tensor as bytes.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>def to_bytes(self) -&gt; bytes:\n    \"\"\"Returns the tensor data buffer as bytes.\n\n    Returns:\n        The data of the tensor as bytes.\n    \"\"\"\n    data = self.as_bytelike()\n    return data if isinstance(data, bytes) else bytes(data)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.TensorTypeMapper","title":"TensorTypeMapper","text":"<p>Utility for mapping between <code>TensorType</code> and other common types.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.TensorTypeMapper.type_from_numpy","title":"type_from_numpy  <code>classmethod</code>","text":"<pre><code>type_from_numpy(dtype: dtype) -&gt; TensorType\n</code></pre> <p>Converts a NumPy <code>dtype</code> to <code>TensorType</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <p>A NumPy <code>dtype</code> object or something convertible to <code>np.dtype</code>.</p> required <p>Returns:</p> Type Description <code>TensorType</code> <p>A corresponding tensor type value.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If NumPy is not installed.</p> <code>ValueError</code> <p>If the <code>dtype</code> value is not supported.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>@classmethod\ndef type_from_numpy(cls, dtype: \"np.dtype\") -&gt; TensorType:\n    \"\"\"Converts a NumPy `dtype` to `TensorType`.\n\n    Args:\n        dtype: A NumPy `dtype` object or something convertible to\n            `np.dtype`.\n\n    Returns:\n        A corresponding tensor type value.\n\n    Raises:\n        NotImplementedError: If NumPy is not installed.\n        ValueError: If the `dtype` value is not supported.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    dtype = np.dtype(dtype)\n    if dtype not in cls._NUMPY_TO_TENSOR_TYPE:\n        supported = \", \".join(str(d) for d in cls._NUMPY_TO_TENSOR_TYPE)\n        msg = f\"Unsupported NumPy dtype: {dtype}. Supported: {supported}\"\n        raise ValueError(msg)\n\n    return cls._NUMPY_TO_TENSOR_TYPE[dtype]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.TensorTypeMapper.type_from_numpy(dtype)","title":"<code>dtype</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.TensorTypeMapper.type_to_c_size","title":"type_to_c_size  <code>classmethod</code>","text":"<pre><code>type_to_c_size(tensor_type: TensorType) -&gt; int\n</code></pre> <p>Converts a <code>TensorType</code> to a C type size (in bytes).</p> <p>Parameters:</p> Name Type Description Default <code>TensorType</code> <p>The tensor type value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>A corresponding C type size in bytes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>tensor_type</code> value is not supported.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>@classmethod\ndef type_to_c_size(cls, tensor_type: TensorType) -&gt; int:\n    \"\"\"Converts a `TensorType` to a C type size (in bytes).\n\n    Args:\n        tensor_type: The tensor type value.\n\n    Returns:\n        A corresponding C type size in bytes.\n\n    Raises:\n        ValueError: If the `tensor_type` value is not supported.\n    \"\"\"\n    if tensor_type not in cls._TENSOR_TYPE_TO_C:\n        supported = \", \".join(str(d) for d in cls._TENSOR_TYPE_TO_C)\n        msg = (\n            f\"Unsupported TensorType: {tensor_type}. Supported: {supported}\"\n        )\n        raise ValueError(msg)\n    return cls._TENSOR_TYPE_TO_C[tensor_type][1]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.TensorTypeMapper.type_to_c_size(tensor_type)","title":"<code>tensor_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.TensorTypeMapper.type_to_c_type","title":"type_to_c_type  <code>classmethod</code>","text":"<pre><code>type_to_c_type(tensor_type: TensorType) -&gt; str\n</code></pre> <p>Converts a <code>TensorType</code> to a C type string.</p> <p>Parameters:</p> Name Type Description Default <code>TensorType</code> <p>The tensor type value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A corresponding C type as a string (e.g., \"float\", \"int64_t\").</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>tensor_type</code> value is not supported.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>@classmethod\ndef type_to_c_type(cls, tensor_type: TensorType) -&gt; str:\n    \"\"\"Converts a `TensorType` to a C type string.\n\n    Args:\n        tensor_type: The tensor type value.\n\n    Returns:\n        A corresponding C type as a string (e.g., \"float\", \"int64_t\").\n\n    Raises:\n        ValueError: If the `tensor_type` value is not supported.\n    \"\"\"\n    if tensor_type not in cls._TENSOR_TYPE_TO_C:\n        supported = \", \".join(str(d) for d in cls._TENSOR_TYPE_TO_C)\n        msg = (\n            f\"Unsupported TensorType: {tensor_type}. Supported: {supported}\"\n        )\n        raise ValueError(msg)\n    return cls._TENSOR_TYPE_TO_C[tensor_type][0]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.TensorTypeMapper.type_to_c_type(tensor_type)","title":"<code>tensor_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.TensorTypeMapper.type_to_numpy","title":"type_to_numpy  <code>classmethod</code>","text":"<pre><code>type_to_numpy(ttype: TensorType) -&gt; dtype\n</code></pre> <p>Converts a <code>TensorType</code> to a NumPy <code>dtype</code>.</p> <p>Parameters:</p> Name Type Description Default <code>TensorType</code> <p>A <code>TensorType</code> enum value.</p> required <p>Returns:</p> Type Description <code>dtype</code> <p>A corresponding NumPy <code>dtype</code> object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If NumPy is not installed.</p> <code>ValueError</code> <p>If the <code>TensorType</code> value is not supported.</p> Source code in <code>          vaccel/ops/tf/lite/tensor.py</code> <pre><code>@classmethod\ndef type_to_numpy(cls, ttype: TensorType) -&gt; \"np.dtype\":\n    \"\"\"Converts a `TensorType` to a NumPy `dtype`.\n\n    Args:\n        ttype: A `TensorType` enum value.\n\n    Returns:\n        A corresponding NumPy `dtype` object.\n\n    Raises:\n        NotImplementedError: If NumPy is not installed.\n        ValueError: If the `TensorType` value is not supported.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    if ttype not in cls._TENSOR_TYPE_TO_NUMPY:\n        supported = \", \".join(str(t) for t in cls._TENSOR_TYPE_TO_NUMPY)\n        msg = f\"Unsupported TensorType: {ttype}. Supported: {supported}\"\n        raise ValueError(msg)\n\n    return cls._TENSOR_TYPE_TO_NUMPY[ttype]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/lite/tensor/#vaccel.ops.tf.lite.tensor.TensorTypeMapper.type_to_numpy(ttype)","title":"<code>ttype</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/mixin/","title":"mixin","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/mixin/#vaccel.ops.tf.mixin","title":"mixin","text":"<p>Tensorflow operations.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/mixin/#vaccel.ops.tf.mixin.TFMixin","title":"TFMixin","text":"<p>Mixin providing Tensorflow operations for a <code>Session</code>.</p> <p>This mixin is intended to be used in combination with <code>BaseSession</code> and should not be instantiated on its own.</p> Intended usage <p>class Session(BaseSession, TensorflowMixin):     ...</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/mixin/#vaccel.ops.tf.mixin.TFMixin.tf_model_load","title":"tf_model_load","text":"<pre><code>tf_model_load(resource: Resource) -&gt; Status\n</code></pre> <p>Performs the Tensorflow model load operation.</p> <p>Wraps the <code>vaccel_tf_model_load()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to load.</p> required <p>Returns:</p> Type Description <code>Status</code> <p>The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/mixin.py</code> <pre><code>def tf_model_load(self, resource: Resource) -&gt; Status:\n    \"\"\"Performs the Tensorflow model load operation.\n\n    Wraps the `vaccel_tf_model_load()` C operation.\n\n    Args:\n        resource: A resource with the model to load.\n\n    Returns:\n        The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    status = Status()\n    ret = lib.vaccel_tf_model_load(\n        self._c_ptr_or_raise, resource._c_ptr, status._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow model load failed\")\n    return status\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/mixin/#vaccel.ops.tf.mixin.TFMixin.tf_model_load(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/mixin/#vaccel.ops.tf.mixin.TFMixin.tf_model_run","title":"tf_model_run","text":"<pre><code>tf_model_run(\n    resource: Resource,\n    in_nodes: list[Node],\n    in_tensors: list[Tensor],\n    out_nodes: list[Node],\n    run_options: Buffer | None = None,\n) -&gt; (list[Tensor], Status)\n</code></pre> <p>Performs the Tensorflow model run operation.</p> <p>Wraps the <code>vaccel_tf_model_run()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to run.</p> required <code>list[Node]</code> <p>The input nodes for the inference.</p> required <code>list[Tensor]</code> <p>The input tensors for the inference.</p> required <code>list[Node]</code> <p>The output nodes for the inference.</p> required <code>Buffer | None</code> <p>The inference options.</p> <code>None</code> <p>Returns:</p> Type Description <code>(list[Tensor], Status)</code> <p>A tuple containing: - The output tensors - The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/mixin.py</code> <pre><code>def tf_model_run(\n    self,\n    resource: Resource,\n    in_nodes: list[Node],\n    in_tensors: list[Tensor],\n    out_nodes: list[Node],\n    run_options: Buffer | None = None,\n) -&gt; (list[Tensor], Status):\n    \"\"\"Performs the Tensorflow model run operation.\n\n    Wraps the `vaccel_tf_model_run()` C operation.\n\n    Args:\n        resource: A resource with the model to run.\n        in_nodes: The input nodes for the inference.\n        in_tensors: The input tensors for the inference.\n        out_nodes: The output nodes for the inference.\n        run_options: The inference options.\n\n    Returns:\n        A tuple containing:\n            - The output tensors\n            - The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    run_options_ptr = (\n        ffi.NULL if run_options is None else run_options._c_ptr\n    )\n    c_in_nodes = CList(in_nodes)\n    c_in_tensors = CList.from_ptrs(in_tensors)\n    c_out_nodes = CList(out_nodes)\n    c_out_tensors = CList.from_ptrs([Tensor.empty()] * len(c_out_nodes))\n    status = Status()\n\n    ret = lib.vaccel_tf_model_run(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        run_options_ptr,\n        c_in_nodes._c_ptr,\n        c_in_tensors._c_ptr,\n        len(c_in_nodes),\n        c_out_nodes._c_ptr,\n        c_out_tensors._c_ptr,\n        len(c_out_nodes),\n        status._c_ptr,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow model run failed\")\n\n    out_tensors = [Tensor.from_c_obj(t) for t in c_out_tensors.value]\n    return (out_tensors, status)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/mixin/#vaccel.ops.tf.mixin.TFMixin.tf_model_run(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/mixin/#vaccel.ops.tf.mixin.TFMixin.tf_model_run(in_nodes)","title":"<code>in_nodes</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/mixin/#vaccel.ops.tf.mixin.TFMixin.tf_model_run(in_tensors)","title":"<code>in_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/mixin/#vaccel.ops.tf.mixin.TFMixin.tf_model_run(out_nodes)","title":"<code>out_nodes</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/mixin/#vaccel.ops.tf.mixin.TFMixin.tf_model_run(run_options)","title":"<code>run_options</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/mixin/#vaccel.ops.tf.mixin.TFMixin.tf_model_unload","title":"tf_model_unload","text":"<pre><code>tf_model_unload(resource: Resource) -&gt; Status\n</code></pre> <p>Performs the Tensorflow model unload operation.</p> <p>Wraps the <code>vaccel_tf_model_unload()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to unload.</p> required <p>Returns:</p> Type Description <code>Status</code> <p>The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/mixin.py</code> <pre><code>def tf_model_unload(self, resource: Resource) -&gt; Status:\n    \"\"\"Performs the Tensorflow model unload operation.\n\n    Wraps the `vaccel_tf_model_unload()` C operation.\n\n    Args:\n        resource: A resource with the model to unload.\n\n    Returns:\n        The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    status = Status()\n    ret = lib.vaccel_tf_model_unload(\n        self._c_ptr_or_raise, resource._c_ptr, status._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow model unload failed\")\n    return status\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/mixin/#vaccel.ops.tf.mixin.TFMixin.tf_model_unload(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/node/","title":"node","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/node/#vaccel.ops.tf.node","title":"node","text":"<p>Interface to the <code>struct vaccel_tf_node</code> C object.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/node/#vaccel.ops.tf.node.Node","title":"Node","text":"<pre><code>Node(name: str, id_: int)\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_tf_node</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_tf_node</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name to be passed to the C struct.</p> required <code>int</code> <p>The ID to be passed to the C struct.</p> required Source code in <code>                vaccel/ops/tf/node.py</code> <pre><code>def __init__(self, name: str, id_: int):\n    \"\"\"Initializes a new `Node` object.\n\n    Args:\n        name: The name to be passed to the C struct.\n        id_: The ID to be passed to the C struct.\n    \"\"\"\n    self._name = name\n    self._id = id_\n    self._c_obj_ptr = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/node/#vaccel.ops.tf.node.Node(name)","title":"<code>name</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/node/#vaccel.ops.tf.node.Node(id_)","title":"<code>id_</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/node/#vaccel.ops.tf.node.Node.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/node/#vaccel.ops.tf.node.Node.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre> <p>The node identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>The node's ID.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/node/#vaccel.ops.tf.node.Node.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The node name.</p> <p>Returns:</p> Type Description <code>str</code> <p>The node's name.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/node/#vaccel.ops.tf.node.Node.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_tf_node`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/status/","title":"status","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/status/#vaccel.ops.tf.status","title":"status","text":"<p>Interface to the <code>struct vaccel_tf_status</code> C object.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/status/#vaccel.ops.tf.status.Status","title":"Status","text":"<pre><code>Status(error_code: int = 0, message: str = '')\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_tf_status</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_tf_status</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The error code to be passed to the C struct. Defaults to 0.</p> <code>0</code> <code>str</code> <p>The message to be passed to the C struct. Defaults to \"\".</p> <code>''</code> Source code in <code>                vaccel/ops/tf/status.py</code> <pre><code>def __init__(self, error_code: int = 0, message: str = \"\"):\n    \"\"\"Initializes a new `Status` object.\n\n    Args:\n        error_code: The error code to be passed to the C struct. Defaults\n            to 0.\n        message: The message to be passed to the C struct. Defaults to \"\".\n    \"\"\"\n    self._error_code = error_code\n    self._message = message\n    self._c_obj_ptr = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/status/#vaccel.ops.tf.status.Status(error_code)","title":"<code>error_code</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/status/#vaccel.ops.tf.status.Status(message)","title":"<code>message</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/status/#vaccel.ops.tf.status.Status.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/status/#vaccel.ops.tf.status.Status.code","title":"code  <code>property</code>","text":"<pre><code>code: int\n</code></pre> <p>The status error code.</p> <p>Returns:</p> Type Description <code>int</code> <p>The code of the status.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/status/#vaccel.ops.tf.status.Status.message","title":"message  <code>property</code>","text":"<pre><code>message: str\n</code></pre> <p>The status message.</p> <p>Returns:</p> Type Description <code>str</code> <p>The message of the status.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/status/#vaccel.ops.tf.status.Status.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_tf_status`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/","title":"tensor","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor","title":"tensor","text":"<p>Interface to the <code>struct vaccel_tf_tensor</code> C object.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor","title":"Tensor","text":"<pre><code>Tensor(dims: list[int], data_type: TensorType, data: list[Any])\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_tf_tensor</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_tf_tensor</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The dims to be passed to the C struct.</p> required <code>TensorType</code> <p>The data_type to be passed to the C struct.</p> required <code>list[Any]</code> <p>The data to be passed to the C struct.</p> required Source code in <code>                vaccel/ops/tf/tensor.py</code> <pre><code>def __init__(self, dims: list[int], data_type: TensorType, data: list[Any]):\n    \"\"\"Initializes a new `Tensor` object.\n\n    Args:\n        dims: The dims to be passed to the C struct.\n        data_type: The data_type to be passed to the C struct.\n        data: The data to be passed to the C struct.\n    \"\"\"\n    self._dims = dims\n    self._data = data\n    self._data_type = data_type\n    self._c_data = None\n    self._c_obj_ptr = ffi.NULL\n    self._c_obj_data = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor(dims)","title":"<code>dims</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor(data_type)","title":"<code>data_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.data","title":"data  <code>property</code>","text":"<pre><code>data: list\n</code></pre> <p>The tensor data.</p> <p>Returns:</p> Type Description <code>list</code> <p>The data of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.data_type","title":"data_type  <code>property</code>","text":"<pre><code>data_type: TensorType\n</code></pre> <p>The tensor data type.</p> <p>Returns:</p> Type Description <code>TensorType</code> <p>The data type of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: list[int]\n</code></pre> <p>The tensor dims.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The dims of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: list[int]\n</code></pre> <p>The tensor shape.</p> <p>Alias of <code>Tensor.dims</code>.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The shape of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_tf_tensor`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.as_bytelike","title":"as_bytelike","text":"<pre><code>as_bytelike() -&gt; bytes | bytearray | memoryview\n</code></pre> <p>Returns the tensor data buffer as a byte-like object.</p> <p>Returns:</p> Type Description <code>bytes | bytearray | memoryview</code> <p>The data of the tensor as a byte-like object.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>def as_bytelike(self) -&gt; bytes | bytearray | memoryview:\n    \"\"\"Returns the tensor data buffer as a byte-like object.\n\n    Returns:\n        The data of the tensor as a byte-like object.\n    \"\"\"\n    if self._c_data is not None:\n        if isinstance(self._c_data, CBytes):\n            return self._c_data.value\n        return self._c_data.as_memoryview()\n    return CBytes.from_c_obj(\n        self._c_ptr_or_raise.data, self._c_ptr_or_raise.size\n    ).value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.as_memoryview","title":"as_memoryview","text":"<pre><code>as_memoryview() -&gt; memoryview\n</code></pre> <p>Returns the tensor data buffer as memoryview.</p> <p>Returns:</p> Type Description <code>memoryview</code> <p>The data of the tensor as memoryview.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>def as_memoryview(self) -&gt; memoryview:\n    \"\"\"Returns the tensor data buffer as memoryview.\n\n    Returns:\n        The data of the tensor as memoryview.\n    \"\"\"\n    data = self.as_bytelike()\n    return data if isinstance(data, memoryview) else memoryview(data)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.as_numpy","title":"as_numpy","text":"<pre><code>as_numpy() -&gt; ndarray\n</code></pre> <p>Returns the tensor data buffer as a NumPy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The data of the tensor as a NumPy array.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>def as_numpy(self) -&gt; \"np.ndarray\":\n    \"\"\"Returns the tensor data buffer as a NumPy array.\n\n    Returns:\n        The data of the tensor as a NumPy array.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    if isinstance(self._c_data, CNumpyArray):\n        return self._c_data.value\n\n    dtype = TensorTypeMapper.type_to_numpy(self.data_type)\n    return CNumpyArray.from_c_obj(\n        self._c_ptr_or_raise.data,\n        self._c_ptr_or_raise.size,\n        self.shape,\n        dtype,\n    ).value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.empty","title":"empty  <code>classmethod</code>","text":"<pre><code>empty() -&gt; Tensor\n</code></pre> <p>Initializes a new empty <code>Tensor</code> object.</p> <p>The object has a NULL pointer in place of the C struct.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>@classmethod\ndef empty(cls) -&gt; \"Tensor\":\n    \"\"\"Initializes a new empty `Tensor` object.\n\n    The object has a NULL pointer in place of the C struct.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    inst = cls.__new__(cls)\n    inst._dims = None\n    inst._data = None\n    inst._data_type = None\n    inst._c_data = None\n    inst._c_obj_ptr = ffi.new(\"struct vaccel_tf_tensor **\")\n    inst._c_obj = inst._c_obj_ptr[0]\n    inst._c_obj_ptr[0] = ffi.NULL\n    inst._c_size = ffi.sizeof(\"struct vaccel_tf_tensor *\")\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.from_buffer","title":"from_buffer  <code>classmethod</code>","text":"<pre><code>from_buffer(\n    dims: list[int], data_type: TensorType, data: bytes | bytearray | memoryview\n) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from byte-like data.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The dims to be passed to the C struct.</p> required <code>TensorType</code> <p>The data_type to be passed to the C struct.</p> required <code>bytes | bytearray | memoryview</code> <p>The data to be passed to the C struct.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>@classmethod\ndef from_buffer(\n    cls,\n    dims: list[int],\n    data_type: TensorType,\n    data: bytes | bytearray | memoryview,\n) -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from byte-like data.\n\n    Args:\n        dims: The dims to be passed to the C struct.\n        data_type: The data_type to be passed to the C struct.\n        data: The data to be passed to the C struct.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    inst = cls.__new__(cls)\n    inst._dims = dims\n    inst._data = data\n    inst._data_type = data_type\n    inst._c_data = CBytes(inst._data)\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.from_buffer(dims)","title":"<code>dims</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.from_buffer(data_type)","title":"<code>data_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.from_buffer(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.from_c_obj","title":"from_c_obj  <code>classmethod</code>","text":"<pre><code>from_c_obj(c_obj: CData) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from an existing C struct.</p> <p>Parameters:</p> Name Type Description Default <code>CData</code> <p>A pointer to a <code>struct vaccel_tf_tensor</code> C object.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>@classmethod\ndef from_c_obj(cls, c_obj: ffi.CData) -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from an existing C struct.\n\n    Args:\n        c_obj: A pointer to a `struct vaccel_tf_tensor` C object.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    type_str = ffi.getctype(ffi.typeof(c_obj))\n    if type_str != \"struct vaccel_tf_tensor *\":\n        msg = f\"Expected 'struct vaccel_tf_tensor *', got '{type_str}'\"\n        raise TypeError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = None\n    inst._data = None\n    inst._data_type = None\n    inst._c_data = None\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = ffi.NULL\n    inst._c_obj = c_obj\n    inst._c_size = ffi.sizeof(inst._c_obj)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.from_c_obj(c_obj)","title":"<code>c_obj</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.from_numpy","title":"from_numpy  <code>classmethod</code>","text":"<pre><code>from_numpy(data: ndarray) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>The NumPy array containing the tensor data.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If NumPy is not installed.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>@classmethod\ndef from_numpy(cls, data: \"np.ndarray\") -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from a NumPy array.\n\n    Args:\n        data: The NumPy array containing the tensor data.\n\n    Returns:\n        A new `Tensor` object\n\n    Raises:\n        NotImplementedError: If NumPy is not installed.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = list(data.shape)\n    inst._data = data\n    inst._data_type = TensorTypeMapper.type_from_numpy(inst._data.dtype)\n    inst._c_data = CNumpyArray(inst._data)\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.from_numpy(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.Tensor.to_bytes","title":"to_bytes","text":"<pre><code>to_bytes() -&gt; bytes\n</code></pre> <p>Returns the tensor data buffer as bytes.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The data of the tensor as bytes.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>def to_bytes(self) -&gt; bytes:\n    \"\"\"Returns the tensor data buffer as bytes.\n\n    Returns:\n        The data of the tensor as bytes.\n    \"\"\"\n    data = self.as_bytelike()\n    return data if isinstance(data, bytes) else bytes(data)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.TensorTypeMapper","title":"TensorTypeMapper","text":"<p>Utility for mapping between <code>TensorType</code> and other common types.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.TensorTypeMapper.type_from_numpy","title":"type_from_numpy  <code>classmethod</code>","text":"<pre><code>type_from_numpy(dtype: dtype) -&gt; TensorType\n</code></pre> <p>Converts a NumPy <code>dtype</code> to <code>TensorType</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <p>A NumPy <code>dtype</code> object or something convertible to <code>np.dtype</code>.</p> required <p>Returns:</p> Type Description <code>TensorType</code> <p>A corresponding tensor type value.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If NumPy is not installed.</p> <code>ValueError</code> <p>If the <code>dtype</code> value is not supported.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>@classmethod\ndef type_from_numpy(cls, dtype: \"np.dtype\") -&gt; TensorType:\n    \"\"\"Converts a NumPy `dtype` to `TensorType`.\n\n    Args:\n        dtype: A NumPy `dtype` object or something convertible to\n            `np.dtype`.\n\n    Returns:\n        A corresponding tensor type value.\n\n    Raises:\n        NotImplementedError: If NumPy is not installed.\n        ValueError: If the `dtype` value is not supported.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    dtype = np.dtype(dtype)\n    if dtype not in cls._NUMPY_TO_TENSOR_TYPE:\n        supported = \", \".join(str(d) for d in cls._NUMPY_TO_TENSOR_TYPE)\n        msg = f\"Unsupported NumPy dtype: {dtype}. Supported: {supported}\"\n        raise ValueError(msg)\n\n    return cls._NUMPY_TO_TENSOR_TYPE[dtype]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.TensorTypeMapper.type_from_numpy(dtype)","title":"<code>dtype</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.TensorTypeMapper.type_to_c_size","title":"type_to_c_size  <code>classmethod</code>","text":"<pre><code>type_to_c_size(tensor_type: TensorType) -&gt; int\n</code></pre> <p>Converts a <code>TensorType</code> to a C type size (in bytes).</p> <p>Parameters:</p> Name Type Description Default <code>TensorType</code> <p>The tensor type value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>A corresponding C type size in bytes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>tensor_type</code> value is not supported.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>@classmethod\ndef type_to_c_size(cls, tensor_type: TensorType) -&gt; int:\n    \"\"\"Converts a `TensorType` to a C type size (in bytes).\n\n    Args:\n        tensor_type: The tensor type value.\n\n    Returns:\n        A corresponding C type size in bytes.\n\n    Raises:\n        ValueError: If the `tensor_type` value is not supported.\n    \"\"\"\n    if tensor_type not in cls._TENSOR_TYPE_TO_C:\n        supported = \", \".join(str(d) for d in cls._TENSOR_TYPE_TO_C)\n        msg = (\n            f\"Unsupported TensorType: {tensor_type}. Supported: {supported}\"\n        )\n        raise ValueError(msg)\n    return cls._TENSOR_TYPE_TO_C[tensor_type][1]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.TensorTypeMapper.type_to_c_size(tensor_type)","title":"<code>tensor_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.TensorTypeMapper.type_to_c_type","title":"type_to_c_type  <code>classmethod</code>","text":"<pre><code>type_to_c_type(tensor_type: TensorType) -&gt; str\n</code></pre> <p>Converts a <code>TensorType</code> to a C type string.</p> <p>Parameters:</p> Name Type Description Default <code>TensorType</code> <p>The tensor type value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A corresponding C type as a string (e.g., \"float\", \"int64_t\").</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>tensor_type</code> value is not supported.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>@classmethod\ndef type_to_c_type(cls, tensor_type: TensorType) -&gt; str:\n    \"\"\"Converts a `TensorType` to a C type string.\n\n    Args:\n        tensor_type: The tensor type value.\n\n    Returns:\n        A corresponding C type as a string (e.g., \"float\", \"int64_t\").\n\n    Raises:\n        ValueError: If the `tensor_type` value is not supported.\n    \"\"\"\n    if tensor_type not in cls._TENSOR_TYPE_TO_C:\n        supported = \", \".join(str(d) for d in cls._TENSOR_TYPE_TO_C)\n        msg = (\n            f\"Unsupported TensorType: {tensor_type}. Supported: {supported}\"\n        )\n        raise ValueError(msg)\n    return cls._TENSOR_TYPE_TO_C[tensor_type][0]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.TensorTypeMapper.type_to_c_type(tensor_type)","title":"<code>tensor_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.TensorTypeMapper.type_to_numpy","title":"type_to_numpy  <code>classmethod</code>","text":"<pre><code>type_to_numpy(ttype: TensorType) -&gt; dtype\n</code></pre> <p>Converts a <code>TensorType</code> to a NumPy <code>dtype</code>.</p> <p>Parameters:</p> Name Type Description Default <code>TensorType</code> <p>A <code>TensorType</code> enum value.</p> required <p>Returns:</p> Type Description <code>dtype</code> <p>A corresponding NumPy <code>dtype</code> object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If NumPy is not installed.</p> <code>ValueError</code> <p>If the <code>TensorType</code> value is not supported.</p> Source code in <code>          vaccel/ops/tf/tensor.py</code> <pre><code>@classmethod\ndef type_to_numpy(cls, ttype: TensorType) -&gt; \"np.dtype\":\n    \"\"\"Converts a `TensorType` to a NumPy `dtype`.\n\n    Args:\n        ttype: A `TensorType` enum value.\n\n    Returns:\n        A corresponding NumPy `dtype` object.\n\n    Raises:\n        NotImplementedError: If NumPy is not installed.\n        ValueError: If the `TensorType` value is not supported.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    if ttype not in cls._TENSOR_TYPE_TO_NUMPY:\n        supported = \", \".join(str(t) for t in cls._TENSOR_TYPE_TO_NUMPY)\n        msg = f\"Unsupported TensorType: {ttype}. Supported: {supported}\"\n        raise ValueError(msg)\n\n    return cls._TENSOR_TYPE_TO_NUMPY[ttype]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/tf/tensor/#vaccel.ops.tf.tensor.TensorTypeMapper.type_to_numpy(ttype)","title":"<code>ttype</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/","title":"torch","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch","title":"torch","text":"<p>Torch operations and objects.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Buffer","title":"Buffer","text":"<pre><code>Buffer(data: bytes | bytearray)\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_torch_buffer</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_torch_buffer</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>bytes | bytearray</code> <p>The buffer data to be passed to the C struct.</p> required Source code in <code>                vaccel/ops/torch/buffer.py</code> <pre><code>def __init__(self, data: bytes | bytearray):\n    \"\"\"Initializes a new `Buffer` object.\n\n    Args:\n        data: The buffer data to be passed to the C struct.\n    \"\"\"\n    self._data = data\n    self._c_data = None\n    self._c_obj_ptr = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Buffer(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Buffer.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Buffer.data","title":"data  <code>property</code>","text":"<pre><code>data: bytes\n</code></pre> <p>The buffer data.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The data of the buffer.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Buffer.size","title":"size  <code>property</code>","text":"<pre><code>size: int\n</code></pre> <p>The buffer size.</p> <p>Returns:</p> Type Description <code>int</code> <p>The size of the buffer.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Buffer.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_torch_buffer`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor","title":"Tensor","text":"<pre><code>Tensor(dims: list[int], data_type: TensorType, data: list[Any])\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_torch_tensor</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_torch_tensor</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The dims to be passed to the C struct.</p> required <code>TensorType</code> <p>The data_type to be passed to the C struct.</p> required <code>list[Any]</code> <p>The data to be passed to the C struct.</p> required Source code in <code>                vaccel/ops/torch/tensor.py</code> <pre><code>def __init__(self, dims: list[int], data_type: TensorType, data: list[Any]):\n    \"\"\"Initializes a new `Tensor` object.\n\n    Args:\n        dims: The dims to be passed to the C struct.\n        data_type: The data_type to be passed to the C struct.\n        data: The data to be passed to the C struct.\n    \"\"\"\n    self._dims = dims\n    self._data = data\n    self._data_type = data_type\n    self._c_data = None\n    self._c_obj_ptr = ffi.NULL\n    self._c_obj_data = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor(dims)","title":"<code>dims</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor(data_type)","title":"<code>data_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.data","title":"data  <code>property</code>","text":"<pre><code>data: list\n</code></pre> <p>The tensor data.</p> <p>Returns:</p> Type Description <code>list</code> <p>The data of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.data_type","title":"data_type  <code>property</code>","text":"<pre><code>data_type: TensorType\n</code></pre> <p>The tensor data type.</p> <p>Returns:</p> Type Description <code>TensorType</code> <p>The data type of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: list[int]\n</code></pre> <p>The tensor dims.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The dims of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: list[int]\n</code></pre> <p>The tensor shape.</p> <p>Alias of <code>Tensor.dims</code>.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The shape of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_torch_tensor`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.as_bytelike","title":"as_bytelike","text":"<pre><code>as_bytelike() -&gt; bytes | bytearray | memoryview\n</code></pre> <p>Returns the tensor data buffer as a byte-like object.</p> <p>Returns:</p> Type Description <code>bytes | bytearray | memoryview</code> <p>The data of the tensor as a byte-like object.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>def as_bytelike(self) -&gt; bytes | bytearray | memoryview:\n    \"\"\"Returns the tensor data buffer as a byte-like object.\n\n    Returns:\n        The data of the tensor as a byte-like object.\n    \"\"\"\n    if self._c_data is not None:\n        if isinstance(self._c_data, CBytes):\n            return self._c_data.value\n        return self._c_data.as_memoryview()\n    return CBytes.from_c_obj(\n        self._c_ptr_or_raise.data, self._c_ptr_or_raise.size\n    ).value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.as_memoryview","title":"as_memoryview","text":"<pre><code>as_memoryview() -&gt; memoryview\n</code></pre> <p>Returns the tensor data buffer as memoryview.</p> <p>Returns:</p> Type Description <code>memoryview</code> <p>The data of the tensor as memoryview.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>def as_memoryview(self) -&gt; memoryview:\n    \"\"\"Returns the tensor data buffer as memoryview.\n\n    Returns:\n        The data of the tensor as memoryview.\n    \"\"\"\n    data = self.as_bytelike()\n    return data if isinstance(data, memoryview) else memoryview(data)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.as_numpy","title":"as_numpy","text":"<pre><code>as_numpy() -&gt; ndarray\n</code></pre> <p>Returns the tensor data buffer as a NumPy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The data of the tensor as a NumPy array.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>def as_numpy(self) -&gt; \"np.ndarray\":\n    \"\"\"Returns the tensor data buffer as a NumPy array.\n\n    Returns:\n        The data of the tensor as a NumPy array.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    if isinstance(self._c_data, CNumpyArray):\n        return self._c_data.value\n\n    dtype = TensorTypeMapper.type_to_numpy(self.data_type)\n    return CNumpyArray.from_c_obj(\n        self._c_ptr_or_raise.data,\n        self._c_ptr_or_raise.size,\n        self.shape,\n        dtype,\n    ).value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.as_torch","title":"as_torch","text":"<pre><code>as_torch() -&gt; Tensor\n</code></pre> <p>Returns the tensor as a PyTorch tensor.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>The tensor as a PyTorch tensor.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If PyTorch is not installed.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>def as_torch(self) -&gt; \"torch.Tensor\":\n    \"\"\"Returns the tensor as a PyTorch tensor.\n\n    Returns:\n        The tensor as a PyTorch tensor.\n\n    Raises:\n        NotImplementedError: If PyTorch is not installed.\n    \"\"\"\n    if not HAS_TORCH:\n        msg = \"PyTorch is not available\"\n        raise NotImplementedError(msg)\n\n    if isinstance(self._data, torch.Tensor):\n        return self._data\n\n    dtype = TensorTypeMapper.type_to_torch(self.data_type)\n    buf = ffi.buffer(self._c_ptr_or_raise.data, self._c_ptr_or_raise.size)\n\n    return torch.frombuffer(buf, dtype=dtype).reshape(self.shape)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.empty","title":"empty  <code>classmethod</code>","text":"<pre><code>empty() -&gt; Tensor\n</code></pre> <p>Initializes a new empty <code>Tensor</code> object.</p> <p>The object has a NULL pointer in place of the C struct.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef empty(cls) -&gt; \"Tensor\":\n    \"\"\"Initializes a new empty `Tensor` object.\n\n    The object has a NULL pointer in place of the C struct.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    inst = cls.__new__(cls)\n    inst._dims = None\n    inst._data = None\n    inst._data_type = None\n    inst._c_data = None\n    inst._c_obj_ptr = ffi.new(\"struct vaccel_torch_tensor **\")\n    inst._c_obj = inst._c_obj_ptr[0]\n    inst._c_obj_ptr[0] = ffi.NULL\n    inst._c_size = ffi.sizeof(\"struct vaccel_torch_tensor *\")\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.from_buffer","title":"from_buffer  <code>classmethod</code>","text":"<pre><code>from_buffer(\n    dims: list[int], data_type: TensorType, data: bytes | bytearray | memoryview\n) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from byte-like data.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The dims to be passed to the C struct.</p> required <code>TensorType</code> <p>The data_type to be passed to the C struct.</p> required <code>bytes | bytearray | memoryview</code> <p>The data to be passed to the C struct.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef from_buffer(\n    cls,\n    dims: list[int],\n    data_type: TensorType,\n    data: bytes | bytearray | memoryview,\n) -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from byte-like data.\n\n    Args:\n        dims: The dims to be passed to the C struct.\n        data_type: The data_type to be passed to the C struct.\n        data: The data to be passed to the C struct.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    inst = cls.__new__(cls)\n    inst._dims = dims\n    inst._data = data\n    inst._data_type = data_type\n    inst._c_data = CBytes(inst._data)\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.from_buffer(dims)","title":"<code>dims</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.from_buffer(data_type)","title":"<code>data_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.from_buffer(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.from_c_obj","title":"from_c_obj  <code>classmethod</code>","text":"<pre><code>from_c_obj(c_obj: CData) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from an existing C struct.</p> <p>Parameters:</p> Name Type Description Default <code>CData</code> <p>A pointer to a <code>struct vaccel_torch_tensor</code> C object.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef from_c_obj(cls, c_obj: ffi.CData) -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from an existing C struct.\n\n    Args:\n        c_obj: A pointer to a `struct vaccel_torch_tensor` C object.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    type_str = ffi.getctype(ffi.typeof(c_obj))\n    if type_str != \"struct vaccel_torch_tensor *\":\n        msg = f\"Expected 'struct vaccel_torch_tensor *', got '{type_str}'\"\n        raise TypeError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = None\n    inst._data = None\n    inst._data_type = None\n    inst._c_data = None\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = ffi.NULL\n    inst._c_obj = c_obj\n    inst._c_size = ffi.sizeof(inst._c_obj)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.from_c_obj(c_obj)","title":"<code>c_obj</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.from_numpy","title":"from_numpy  <code>classmethod</code>","text":"<pre><code>from_numpy(data: ndarray) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>The NumPy array containing the tensor data.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If NumPy is not installed.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef from_numpy(cls, data: \"np.ndarray\") -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from a NumPy array.\n\n    Args:\n        data: The NumPy array containing the tensor data.\n\n    Returns:\n        A new `Tensor` object\n\n    Raises:\n        NotImplementedError: If NumPy is not installed.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = list(data.shape)\n    inst._data = data\n    inst._data_type = TensorTypeMapper.type_from_numpy(inst._data.dtype)\n    inst._c_data = CNumpyArray(inst._data)\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.from_numpy(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.from_torch","title":"from_torch  <code>classmethod</code>","text":"<pre><code>from_torch(data: Tensor) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from a PyTorch tensor.</p> <p>Parameters:</p> Name Type Description Default <code>Tensor</code> <p>The PyTorch tensor containing the tensor data.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If PyTorch is not installed.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef from_torch(cls, data: \"torch.Tensor\") -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from a PyTorch tensor.\n\n    Args:\n        data: The PyTorch tensor containing the tensor data.\n\n    Returns:\n        A new `Tensor` object\n\n    Raises:\n        NotImplementedError: If PyTorch is not installed.\n    \"\"\"\n    if not HAS_TORCH:\n        msg = \"PyTorch is not available\"\n        raise NotImplementedError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = list(data.shape)\n    inst._data = data.contiguous().cpu()\n    inst._data_type = TensorTypeMapper.type_from_torch(inst._data.dtype)\n    inst._c_obj_ptr = ffi.NULL\n    data_ptr_int = inst._data.untyped_storage().data_ptr()\n    data_ptr = ffi.cast(\"void *\", data_ptr_int)\n    data_size = inst._data.untyped_storage().nbytes()\n    inst._c_data = CBytes.from_c_obj(data_ptr, data_size)\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.from_torch(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.Tensor.to_bytes","title":"to_bytes","text":"<pre><code>to_bytes() -&gt; bytes\n</code></pre> <p>Returns the tensor data buffer as bytes.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The data of the tensor as bytes.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>def to_bytes(self) -&gt; bytes:\n    \"\"\"Returns the tensor data buffer as bytes.\n\n    Returns:\n        The data of the tensor as bytes.\n    \"\"\"\n    data = self.as_bytelike()\n    return data if isinstance(data, bytes) else bytes(data)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.TorchMixin","title":"TorchMixin","text":"<p>Mixin providing Torch operations for a <code>Session</code>.</p> <p>This mixin is intended to be used in combination with <code>BaseSession</code> and should not be instantiated on its own.</p> Intended usage <p>class Session(BaseSession, TorchMixin):     ...</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.TorchMixin.torch_model_load","title":"torch_model_load","text":"<pre><code>torch_model_load(resource: Resource) -&gt; None\n</code></pre> <p>Performs the Torch model load operation.</p> <p>Wraps the <code>vaccel_torch_model_load()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to load.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/torch/mixin.py</code> <pre><code>def torch_model_load(self, resource: Resource) -&gt; None:\n    \"\"\"Performs the Torch model load operation.\n\n    Wraps the `vaccel_torch_model_load()` C operation.\n\n    Args:\n        resource: A resource with the model to load.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_torch_model_load(self._c_ptr_or_raise, resource._c_ptr)\n    if ret != 0:\n        raise FFIError(ret, \"Torch model load failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.TorchMixin.torch_model_load(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.TorchMixin.torch_model_run","title":"torch_model_run","text":"<pre><code>torch_model_run(\n    resource: Resource,\n    in_tensors: list[Tensor],\n    nr_out_tensors: int = 1,\n    run_options: Buffer | None = None,\n) -&gt; list[Tensor]\n</code></pre> <p>Performs the Torch model run operation.</p> <p>Wraps the <code>vaccel_torch_model_run()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to run.</p> required <code>list[Tensor]</code> <p>The input tensors for the inference.</p> required <code>int</code> <p>The number of output tensors. Defaults to 1.</p> <code>1</code> <code>Buffer | None</code> <p>The inference options.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Tensor]</code> <p>The output tensors</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/torch/mixin.py</code> <pre><code>def torch_model_run(\n    self,\n    resource: Resource,\n    in_tensors: list[Tensor],\n    nr_out_tensors: int = 1,\n    run_options: Buffer | None = None,\n) -&gt; list[Tensor]:\n    \"\"\"Performs the Torch model run operation.\n\n    Wraps the `vaccel_torch_model_run()` C operation.\n\n    Args:\n        resource: A resource with the model to run.\n        in_tensors: The input tensors for the inference.\n        nr_out_tensors: The number of output tensors. Defaults to 1.\n        run_options: The inference options.\n\n    Returns:\n        The output tensors\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    run_options_ptr = (\n        ffi.NULL if run_options is None else run_options._c_ptr\n    )\n    c_in_tensors = CList.from_ptrs(in_tensors)\n    c_out_tensors = CList.from_ptrs([Tensor.empty()] * nr_out_tensors)\n\n    ret = lib.vaccel_torch_model_run(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        run_options_ptr,\n        c_in_tensors._c_ptr,\n        len(c_in_tensors),\n        c_out_tensors._c_ptr,\n        len(c_out_tensors),\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Torch jitload forward operation failed\")\n\n    return [Tensor.from_c_obj(t) for t in c_out_tensors.value]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.TorchMixin.torch_model_run(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.TorchMixin.torch_model_run(in_tensors)","title":"<code>in_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.TorchMixin.torch_model_run(nr_out_tensors)","title":"<code>nr_out_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/#vaccel.ops.torch.TorchMixin.torch_model_run(run_options)","title":"<code>run_options</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/buffer/","title":"buffer","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/buffer/#vaccel.ops.torch.buffer","title":"buffer","text":"<p>Interface to the <code>struct vaccel_torch_buffer</code> C object.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/buffer/#vaccel.ops.torch.buffer.Buffer","title":"Buffer","text":"<pre><code>Buffer(data: bytes | bytearray)\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_torch_buffer</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_torch_buffer</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>bytes | bytearray</code> <p>The buffer data to be passed to the C struct.</p> required Source code in <code>                vaccel/ops/torch/buffer.py</code> <pre><code>def __init__(self, data: bytes | bytearray):\n    \"\"\"Initializes a new `Buffer` object.\n\n    Args:\n        data: The buffer data to be passed to the C struct.\n    \"\"\"\n    self._data = data\n    self._c_data = None\n    self._c_obj_ptr = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/buffer/#vaccel.ops.torch.buffer.Buffer(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/buffer/#vaccel.ops.torch.buffer.Buffer.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/buffer/#vaccel.ops.torch.buffer.Buffer.data","title":"data  <code>property</code>","text":"<pre><code>data: bytes\n</code></pre> <p>The buffer data.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The data of the buffer.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/buffer/#vaccel.ops.torch.buffer.Buffer.size","title":"size  <code>property</code>","text":"<pre><code>size: int\n</code></pre> <p>The buffer size.</p> <p>Returns:</p> Type Description <code>int</code> <p>The size of the buffer.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/buffer/#vaccel.ops.torch.buffer.Buffer.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_torch_buffer`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/mixin/","title":"mixin","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/mixin/#vaccel.ops.torch.mixin","title":"mixin","text":"<p>Torch operations.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/mixin/#vaccel.ops.torch.mixin.TorchMixin","title":"TorchMixin","text":"<p>Mixin providing Torch operations for a <code>Session</code>.</p> <p>This mixin is intended to be used in combination with <code>BaseSession</code> and should not be instantiated on its own.</p> Intended usage <p>class Session(BaseSession, TorchMixin):     ...</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/mixin/#vaccel.ops.torch.mixin.TorchMixin.torch_model_load","title":"torch_model_load","text":"<pre><code>torch_model_load(resource: Resource) -&gt; None\n</code></pre> <p>Performs the Torch model load operation.</p> <p>Wraps the <code>vaccel_torch_model_load()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to load.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/torch/mixin.py</code> <pre><code>def torch_model_load(self, resource: Resource) -&gt; None:\n    \"\"\"Performs the Torch model load operation.\n\n    Wraps the `vaccel_torch_model_load()` C operation.\n\n    Args:\n        resource: A resource with the model to load.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_torch_model_load(self._c_ptr_or_raise, resource._c_ptr)\n    if ret != 0:\n        raise FFIError(ret, \"Torch model load failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/mixin/#vaccel.ops.torch.mixin.TorchMixin.torch_model_load(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/mixin/#vaccel.ops.torch.mixin.TorchMixin.torch_model_run","title":"torch_model_run","text":"<pre><code>torch_model_run(\n    resource: Resource,\n    in_tensors: list[Tensor],\n    nr_out_tensors: int = 1,\n    run_options: Buffer | None = None,\n) -&gt; list[Tensor]\n</code></pre> <p>Performs the Torch model run operation.</p> <p>Wraps the <code>vaccel_torch_model_run()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to run.</p> required <code>list[Tensor]</code> <p>The input tensors for the inference.</p> required <code>int</code> <p>The number of output tensors. Defaults to 1.</p> <code>1</code> <code>Buffer | None</code> <p>The inference options.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Tensor]</code> <p>The output tensors</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/torch/mixin.py</code> <pre><code>def torch_model_run(\n    self,\n    resource: Resource,\n    in_tensors: list[Tensor],\n    nr_out_tensors: int = 1,\n    run_options: Buffer | None = None,\n) -&gt; list[Tensor]:\n    \"\"\"Performs the Torch model run operation.\n\n    Wraps the `vaccel_torch_model_run()` C operation.\n\n    Args:\n        resource: A resource with the model to run.\n        in_tensors: The input tensors for the inference.\n        nr_out_tensors: The number of output tensors. Defaults to 1.\n        run_options: The inference options.\n\n    Returns:\n        The output tensors\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    run_options_ptr = (\n        ffi.NULL if run_options is None else run_options._c_ptr\n    )\n    c_in_tensors = CList.from_ptrs(in_tensors)\n    c_out_tensors = CList.from_ptrs([Tensor.empty()] * nr_out_tensors)\n\n    ret = lib.vaccel_torch_model_run(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        run_options_ptr,\n        c_in_tensors._c_ptr,\n        len(c_in_tensors),\n        c_out_tensors._c_ptr,\n        len(c_out_tensors),\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Torch jitload forward operation failed\")\n\n    return [Tensor.from_c_obj(t) for t in c_out_tensors.value]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/mixin/#vaccel.ops.torch.mixin.TorchMixin.torch_model_run(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/mixin/#vaccel.ops.torch.mixin.TorchMixin.torch_model_run(in_tensors)","title":"<code>in_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/mixin/#vaccel.ops.torch.mixin.TorchMixin.torch_model_run(nr_out_tensors)","title":"<code>nr_out_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/mixin/#vaccel.ops.torch.mixin.TorchMixin.torch_model_run(run_options)","title":"<code>run_options</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/","title":"tensor","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor","title":"tensor","text":"<p>Interface to the <code>struct vaccel_torch_tensor</code> C object.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor","title":"Tensor","text":"<pre><code>Tensor(dims: list[int], data_type: TensorType, data: list[Any])\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_torch_tensor</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_torch_tensor</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The dims to be passed to the C struct.</p> required <code>TensorType</code> <p>The data_type to be passed to the C struct.</p> required <code>list[Any]</code> <p>The data to be passed to the C struct.</p> required Source code in <code>                vaccel/ops/torch/tensor.py</code> <pre><code>def __init__(self, dims: list[int], data_type: TensorType, data: list[Any]):\n    \"\"\"Initializes a new `Tensor` object.\n\n    Args:\n        dims: The dims to be passed to the C struct.\n        data_type: The data_type to be passed to the C struct.\n        data: The data to be passed to the C struct.\n    \"\"\"\n    self._dims = dims\n    self._data = data\n    self._data_type = data_type\n    self._c_data = None\n    self._c_obj_ptr = ffi.NULL\n    self._c_obj_data = ffi.NULL\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor(dims)","title":"<code>dims</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor(data_type)","title":"<code>data_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.data","title":"data  <code>property</code>","text":"<pre><code>data: list\n</code></pre> <p>The tensor data.</p> <p>Returns:</p> Type Description <code>list</code> <p>The data of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.data_type","title":"data_type  <code>property</code>","text":"<pre><code>data_type: TensorType\n</code></pre> <p>The tensor data type.</p> <p>Returns:</p> Type Description <code>TensorType</code> <p>The data type of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: list[int]\n</code></pre> <p>The tensor dims.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The dims of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: list[int]\n</code></pre> <p>The tensor shape.</p> <p>Alias of <code>Tensor.dims</code>.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The shape of the tensor.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_torch_tensor`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.as_bytelike","title":"as_bytelike","text":"<pre><code>as_bytelike() -&gt; bytes | bytearray | memoryview\n</code></pre> <p>Returns the tensor data buffer as a byte-like object.</p> <p>Returns:</p> Type Description <code>bytes | bytearray | memoryview</code> <p>The data of the tensor as a byte-like object.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>def as_bytelike(self) -&gt; bytes | bytearray | memoryview:\n    \"\"\"Returns the tensor data buffer as a byte-like object.\n\n    Returns:\n        The data of the tensor as a byte-like object.\n    \"\"\"\n    if self._c_data is not None:\n        if isinstance(self._c_data, CBytes):\n            return self._c_data.value\n        return self._c_data.as_memoryview()\n    return CBytes.from_c_obj(\n        self._c_ptr_or_raise.data, self._c_ptr_or_raise.size\n    ).value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.as_memoryview","title":"as_memoryview","text":"<pre><code>as_memoryview() -&gt; memoryview\n</code></pre> <p>Returns the tensor data buffer as memoryview.</p> <p>Returns:</p> Type Description <code>memoryview</code> <p>The data of the tensor as memoryview.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>def as_memoryview(self) -&gt; memoryview:\n    \"\"\"Returns the tensor data buffer as memoryview.\n\n    Returns:\n        The data of the tensor as memoryview.\n    \"\"\"\n    data = self.as_bytelike()\n    return data if isinstance(data, memoryview) else memoryview(data)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.as_numpy","title":"as_numpy","text":"<pre><code>as_numpy() -&gt; ndarray\n</code></pre> <p>Returns the tensor data buffer as a NumPy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The data of the tensor as a NumPy array.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>def as_numpy(self) -&gt; \"np.ndarray\":\n    \"\"\"Returns the tensor data buffer as a NumPy array.\n\n    Returns:\n        The data of the tensor as a NumPy array.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    if isinstance(self._c_data, CNumpyArray):\n        return self._c_data.value\n\n    dtype = TensorTypeMapper.type_to_numpy(self.data_type)\n    return CNumpyArray.from_c_obj(\n        self._c_ptr_or_raise.data,\n        self._c_ptr_or_raise.size,\n        self.shape,\n        dtype,\n    ).value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.as_torch","title":"as_torch","text":"<pre><code>as_torch() -&gt; Tensor\n</code></pre> <p>Returns the tensor as a PyTorch tensor.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>The tensor as a PyTorch tensor.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If PyTorch is not installed.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>def as_torch(self) -&gt; \"torch.Tensor\":\n    \"\"\"Returns the tensor as a PyTorch tensor.\n\n    Returns:\n        The tensor as a PyTorch tensor.\n\n    Raises:\n        NotImplementedError: If PyTorch is not installed.\n    \"\"\"\n    if not HAS_TORCH:\n        msg = \"PyTorch is not available\"\n        raise NotImplementedError(msg)\n\n    if isinstance(self._data, torch.Tensor):\n        return self._data\n\n    dtype = TensorTypeMapper.type_to_torch(self.data_type)\n    buf = ffi.buffer(self._c_ptr_or_raise.data, self._c_ptr_or_raise.size)\n\n    return torch.frombuffer(buf, dtype=dtype).reshape(self.shape)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.empty","title":"empty  <code>classmethod</code>","text":"<pre><code>empty() -&gt; Tensor\n</code></pre> <p>Initializes a new empty <code>Tensor</code> object.</p> <p>The object has a NULL pointer in place of the C struct.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef empty(cls) -&gt; \"Tensor\":\n    \"\"\"Initializes a new empty `Tensor` object.\n\n    The object has a NULL pointer in place of the C struct.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    inst = cls.__new__(cls)\n    inst._dims = None\n    inst._data = None\n    inst._data_type = None\n    inst._c_data = None\n    inst._c_obj_ptr = ffi.new(\"struct vaccel_torch_tensor **\")\n    inst._c_obj = inst._c_obj_ptr[0]\n    inst._c_obj_ptr[0] = ffi.NULL\n    inst._c_size = ffi.sizeof(\"struct vaccel_torch_tensor *\")\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.from_buffer","title":"from_buffer  <code>classmethod</code>","text":"<pre><code>from_buffer(\n    dims: list[int], data_type: TensorType, data: bytes | bytearray | memoryview\n) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from byte-like data.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The dims to be passed to the C struct.</p> required <code>TensorType</code> <p>The data_type to be passed to the C struct.</p> required <code>bytes | bytearray | memoryview</code> <p>The data to be passed to the C struct.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef from_buffer(\n    cls,\n    dims: list[int],\n    data_type: TensorType,\n    data: bytes | bytearray | memoryview,\n) -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from byte-like data.\n\n    Args:\n        dims: The dims to be passed to the C struct.\n        data_type: The data_type to be passed to the C struct.\n        data: The data to be passed to the C struct.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    inst = cls.__new__(cls)\n    inst._dims = dims\n    inst._data = data\n    inst._data_type = data_type\n    inst._c_data = CBytes(inst._data)\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.from_buffer(dims)","title":"<code>dims</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.from_buffer(data_type)","title":"<code>data_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.from_buffer(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.from_c_obj","title":"from_c_obj  <code>classmethod</code>","text":"<pre><code>from_c_obj(c_obj: CData) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from an existing C struct.</p> <p>Parameters:</p> Name Type Description Default <code>CData</code> <p>A pointer to a <code>struct vaccel_torch_tensor</code> C object.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef from_c_obj(cls, c_obj: ffi.CData) -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from an existing C struct.\n\n    Args:\n        c_obj: A pointer to a `struct vaccel_torch_tensor` C object.\n\n    Returns:\n        A new `Tensor` object\n    \"\"\"\n    type_str = ffi.getctype(ffi.typeof(c_obj))\n    if type_str != \"struct vaccel_torch_tensor *\":\n        msg = f\"Expected 'struct vaccel_torch_tensor *', got '{type_str}'\"\n        raise TypeError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = None\n    inst._data = None\n    inst._data_type = None\n    inst._c_data = None\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = ffi.NULL\n    inst._c_obj = c_obj\n    inst._c_size = ffi.sizeof(inst._c_obj)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.from_c_obj(c_obj)","title":"<code>c_obj</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.from_numpy","title":"from_numpy  <code>classmethod</code>","text":"<pre><code>from_numpy(data: ndarray) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>The NumPy array containing the tensor data.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If NumPy is not installed.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef from_numpy(cls, data: \"np.ndarray\") -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from a NumPy array.\n\n    Args:\n        data: The NumPy array containing the tensor data.\n\n    Returns:\n        A new `Tensor` object\n\n    Raises:\n        NotImplementedError: If NumPy is not installed.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = list(data.shape)\n    inst._data = data\n    inst._data_type = TensorTypeMapper.type_from_numpy(inst._data.dtype)\n    inst._c_data = CNumpyArray(inst._data)\n    inst._c_obj_ptr = ffi.NULL\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.from_numpy(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.from_torch","title":"from_torch  <code>classmethod</code>","text":"<pre><code>from_torch(data: Tensor) -&gt; Tensor\n</code></pre> <p>Initializes a new <code>Tensor</code> object from a PyTorch tensor.</p> <p>Parameters:</p> Name Type Description Default <code>Tensor</code> <p>The PyTorch tensor containing the tensor data.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A new <code>Tensor</code> object</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If PyTorch is not installed.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef from_torch(cls, data: \"torch.Tensor\") -&gt; \"Tensor\":\n    \"\"\"Initializes a new `Tensor` object from a PyTorch tensor.\n\n    Args:\n        data: The PyTorch tensor containing the tensor data.\n\n    Returns:\n        A new `Tensor` object\n\n    Raises:\n        NotImplementedError: If PyTorch is not installed.\n    \"\"\"\n    if not HAS_TORCH:\n        msg = \"PyTorch is not available\"\n        raise NotImplementedError(msg)\n\n    inst = cls.__new__(cls)\n    inst._dims = list(data.shape)\n    inst._data = data.contiguous().cpu()\n    inst._data_type = TensorTypeMapper.type_from_torch(inst._data.dtype)\n    inst._c_obj_ptr = ffi.NULL\n    data_ptr_int = inst._data.untyped_storage().data_ptr()\n    data_ptr = ffi.cast(\"void *\", data_ptr_int)\n    data_size = inst._data.untyped_storage().nbytes()\n    inst._c_data = CBytes.from_c_obj(data_ptr, data_size)\n    inst._c_obj_data = inst._c_data._c_ptr\n    super().__init__(inst)\n    return inst\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.from_torch(data)","title":"<code>data</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.Tensor.to_bytes","title":"to_bytes","text":"<pre><code>to_bytes() -&gt; bytes\n</code></pre> <p>Returns the tensor data buffer as bytes.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The data of the tensor as bytes.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>def to_bytes(self) -&gt; bytes:\n    \"\"\"Returns the tensor data buffer as bytes.\n\n    Returns:\n        The data of the tensor as bytes.\n    \"\"\"\n    data = self.as_bytelike()\n    return data if isinstance(data, bytes) else bytes(data)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.TensorTypeMapper","title":"TensorTypeMapper","text":"<p>Utility for mapping between <code>TensorType</code> and other common types.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.TensorTypeMapper.type_from_numpy","title":"type_from_numpy  <code>classmethod</code>","text":"<pre><code>type_from_numpy(dtype: dtype) -&gt; TensorType\n</code></pre> <p>Converts a NumPy <code>dtype</code> to <code>TensorType</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <p>A NumPy <code>dtype</code> object or something convertible to <code>np.dtype</code>.</p> required <p>Returns:</p> Type Description <code>TensorType</code> <p>A corresponding tensor type value.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If NumPy is not installed.</p> <code>ValueError</code> <p>If the <code>dtype</code> value is not supported.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef type_from_numpy(cls, dtype: \"np.dtype\") -&gt; TensorType:\n    \"\"\"Converts a NumPy `dtype` to `TensorType`.\n\n    Args:\n        dtype: A NumPy `dtype` object or something convertible to\n            `np.dtype`.\n\n    Returns:\n        A corresponding tensor type value.\n\n    Raises:\n        NotImplementedError: If NumPy is not installed.\n        ValueError: If the `dtype` value is not supported.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    dtype = np.dtype(dtype)\n    if dtype not in cls._NUMPY_TO_TENSOR_TYPE:\n        supported = \", \".join(str(d) for d in cls._NUMPY_TO_TENSOR_TYPE)\n        msg = f\"Unsupported NumPy dtype: {dtype}. Supported: {supported}\"\n        raise ValueError(msg)\n\n    return cls._NUMPY_TO_TENSOR_TYPE[dtype]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.TensorTypeMapper.type_from_numpy(dtype)","title":"<code>dtype</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.TensorTypeMapper.type_from_torch","title":"type_from_torch  <code>classmethod</code>","text":"<pre><code>type_from_torch(dtype: dtype) -&gt; TensorType\n</code></pre> <p>Converts a PyTorch <code>dtype</code> to <code>TensorType</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <p>A PyTorch <code>dtype</code> object.</p> required <p>Returns:</p> Type Description <code>TensorType</code> <p>A corresponding tensor type value.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If PyTorch is not installed.</p> <code>ValueError</code> <p>If the <code>dtype</code> value is not supported.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef type_from_torch(cls, dtype: \"torch.dtype\") -&gt; TensorType:\n    \"\"\"Converts a PyTorch `dtype` to `TensorType`.\n\n    Args:\n        dtype: A PyTorch `dtype` object.\n\n    Returns:\n        A corresponding tensor type value.\n\n    Raises:\n        NotImplementedError: If PyTorch is not installed.\n        ValueError: If the `dtype` value is not supported.\n    \"\"\"\n    if not HAS_TORCH:\n        msg = \"PyTorch is not available\"\n        raise NotImplementedError(msg)\n\n    if dtype not in cls._TORCH_TO_TENSOR_TYPE:\n        supported = \", \".join(str(d) for d in cls._TORCH_TO_TENSOR_TYPE)\n        msg = f\"Unsupported PyTorch dtype: {dtype}. Supported: {supported}\"\n        raise ValueError(msg)\n\n    return cls._TORCH_TO_TENSOR_TYPE[dtype]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.TensorTypeMapper.type_from_torch(dtype)","title":"<code>dtype</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.TensorTypeMapper.type_to_c_size","title":"type_to_c_size  <code>classmethod</code>","text":"<pre><code>type_to_c_size(tensor_type: TensorType) -&gt; int\n</code></pre> <p>Converts a <code>TensorType</code> to a C type size (in bytes).</p> <p>Parameters:</p> Name Type Description Default <code>TensorType</code> <p>The tensor type value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>A corresponding C type size in bytes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>tensor_type</code> value is not supported.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef type_to_c_size(cls, tensor_type: TensorType) -&gt; int:\n    \"\"\"Converts a `TensorType` to a C type size (in bytes).\n\n    Args:\n        tensor_type: The tensor type value.\n\n    Returns:\n        A corresponding C type size in bytes.\n\n    Raises:\n        ValueError: If the `tensor_type` value is not supported.\n    \"\"\"\n    if tensor_type not in cls._TENSOR_TYPE_TO_C:\n        supported = \", \".join(str(d) for d in cls._TENSOR_TYPE_TO_C)\n        msg = (\n            f\"Unsupported TensorType: {tensor_type}. Supported: {supported}\"\n        )\n        raise ValueError(msg)\n    return cls._TENSOR_TYPE_TO_C[tensor_type][1]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.TensorTypeMapper.type_to_c_size(tensor_type)","title":"<code>tensor_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.TensorTypeMapper.type_to_c_type","title":"type_to_c_type  <code>classmethod</code>","text":"<pre><code>type_to_c_type(tensor_type: TensorType) -&gt; str\n</code></pre> <p>Converts a <code>TensorType</code> to a C type string.</p> <p>Parameters:</p> Name Type Description Default <code>TensorType</code> <p>The tensor type value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A corresponding C type as a string (e.g., \"float\", \"int64_t\").</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>tensor_type</code> value is not supported.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef type_to_c_type(cls, tensor_type: TensorType) -&gt; str:\n    \"\"\"Converts a `TensorType` to a C type string.\n\n    Args:\n        tensor_type: The tensor type value.\n\n    Returns:\n        A corresponding C type as a string (e.g., \"float\", \"int64_t\").\n\n    Raises:\n        ValueError: If the `tensor_type` value is not supported.\n    \"\"\"\n    if tensor_type not in cls._TENSOR_TYPE_TO_C:\n        supported = \", \".join(str(d) for d in cls._TENSOR_TYPE_TO_C)\n        msg = (\n            f\"Unsupported TensorType: {tensor_type}. Supported: {supported}\"\n        )\n        raise ValueError(msg)\n    return cls._TENSOR_TYPE_TO_C[tensor_type][0]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.TensorTypeMapper.type_to_c_type(tensor_type)","title":"<code>tensor_type</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.TensorTypeMapper.type_to_numpy","title":"type_to_numpy  <code>classmethod</code>","text":"<pre><code>type_to_numpy(ttype: TensorType) -&gt; dtype\n</code></pre> <p>Converts a <code>TensorType</code> to a NumPy <code>dtype</code>.</p> <p>Parameters:</p> Name Type Description Default <code>TensorType</code> <p>A <code>TensorType</code> enum value.</p> required <p>Returns:</p> Type Description <code>dtype</code> <p>A corresponding NumPy <code>dtype</code> object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If NumPy is not installed.</p> <code>ValueError</code> <p>If the <code>TensorType</code> value is not supported.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef type_to_numpy(cls, ttype: TensorType) -&gt; \"np.dtype\":\n    \"\"\"Converts a `TensorType` to a NumPy `dtype`.\n\n    Args:\n        ttype: A `TensorType` enum value.\n\n    Returns:\n        A corresponding NumPy `dtype` object.\n\n    Raises:\n        NotImplementedError: If NumPy is not installed.\n        ValueError: If the `TensorType` value is not supported.\n    \"\"\"\n    if not HAS_NUMPY:\n        msg = \"NumPy is not available\"\n        raise NotImplementedError(msg)\n\n    if ttype not in cls._TENSOR_TYPE_TO_NUMPY:\n        supported = \", \".join(str(t) for t in cls._TENSOR_TYPE_TO_NUMPY)\n        msg = f\"Unsupported TensorType: {ttype}. Supported: {supported}\"\n        raise ValueError(msg)\n\n    return cls._TENSOR_TYPE_TO_NUMPY[ttype]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.TensorTypeMapper.type_to_numpy(ttype)","title":"<code>ttype</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.TensorTypeMapper.type_to_torch","title":"type_to_torch  <code>classmethod</code>","text":"<pre><code>type_to_torch(ttype: TensorType) -&gt; dtype\n</code></pre> <p>Converts a <code>TensorType</code> to a PyTorch <code>dtype</code>.</p> <p>Parameters:</p> Name Type Description Default <code>TensorType</code> <p>A <code>TensorType</code> enum value.</p> required <p>Returns:</p> Type Description <code>dtype</code> <p>A corresponding PyTorch <code>dtype</code> object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If PyTorch is not installed.</p> <code>ValueError</code> <p>If the <code>TensorType</code> value is not supported.</p> Source code in <code>          vaccel/ops/torch/tensor.py</code> <pre><code>@classmethod\ndef type_to_torch(cls, ttype: TensorType) -&gt; \"torch.dtype\":\n    \"\"\"Converts a `TensorType` to a PyTorch `dtype`.\n\n    Args:\n        ttype: A `TensorType` enum value.\n\n    Returns:\n        A corresponding PyTorch `dtype` object.\n\n    Raises:\n        NotImplementedError: If PyTorch is not installed.\n        ValueError: If the `TensorType` value is not supported.\n    \"\"\"\n    if not HAS_TORCH:\n        msg = \"PyTorch is not available\"\n        raise NotImplementedError(msg)\n\n    if ttype not in cls._TENSOR_TYPE_TO_TORCH:\n        supported = \", \".join(str(t) for t in cls._TENSOR_TYPE_TO_TORCH)\n        msg = f\"Unsupported TensorType: {ttype}. Supported: {supported}\"\n        raise ValueError(msg)\n\n    return cls._TENSOR_TYPE_TO_TORCH[ttype]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/ops/torch/tensor/#vaccel.ops.torch.tensor.TensorTypeMapper.type_to_torch(ttype)","title":"<code>ttype</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/","title":"resource","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource","title":"resource","text":"<p>Interface to the <code>struct vaccel_resource</code> C object.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource.Resource","title":"Resource","text":"<pre><code>Resource(paths: list[Path] | list[str] | Path | str, type_: ResourceType)\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_resource</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_resource</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>list[Path] | list[str] | Path | str</code> <p>The path(s) to the file(s) that will be represented by the resource.</p> required <code>ResourceType</code> <p>The type of the resource.</p> required Source code in <code>                vaccel/resource.py</code> <pre><code>def __init__(\n    self, paths: list[Path] | list[str] | Path | str, type_: ResourceType\n):\n    \"\"\"Initializes a new `Resource` object.\n\n    Args:\n        paths: The path(s) to the file(s) that will be represented by the\n            resource.\n        type_: The type of the resource.\n    \"\"\"\n    if isinstance(paths, list):\n        self._paths = [str(path) for path in paths]\n    else:\n        self._paths = [str(paths)]\n    self._c_paths = CList(self._paths)\n    self._type = type_\n    self.__sessions = []\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource.Resource(paths)","title":"<code>paths</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource.Resource(type_)","title":"<code>type_</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource.Resource.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource.Resource.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre> <p>The resource identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>The resource's unique ID.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource.Resource.remote_id","title":"remote_id  <code>property</code>","text":"<pre><code>remote_id: int\n</code></pre> <p>The remote resource identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>The resource's remote ID.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource.Resource.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_resource`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource.Resource.is_registered","title":"is_registered","text":"<pre><code>is_registered(session: BaseSession) -&gt; bool\n</code></pre> <p>Checks if the resource is registered with the session.</p> <p>Parameters:</p> Name Type Description Default <code>BaseSession</code> <p>The session to check for registration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the resource is registered with the session.</p> Source code in <code>          vaccel/resource.py</code> <pre><code>def is_registered(self, session: \"Session\") -&gt; bool:\n    \"\"\"Checks if the resource is registered with the session.\n\n    Args:\n        session: The session to check for registration.\n\n    Returns:\n        True if the resource is registered with the session.\n    \"\"\"\n    return session in self.__sessions\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource.Resource.is_registered(session)","title":"<code>session</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource.Resource.register","title":"register","text":"<pre><code>register(session: BaseSession) -&gt; None\n</code></pre> <p>Register the resource with a session.</p> <p>Parameters:</p> Name Type Description Default <code>BaseSession</code> <p>The session to register the resource with.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If resource registration fails.</p> Source code in <code>          vaccel/resource.py</code> <pre><code>def register(self, session: \"Session\") -&gt; None:\n    \"\"\"Register the resource with a session.\n\n    Args:\n        session: The session to register the resource with.\n\n    Raises:\n        FFIError: If resource registration fails.\n    \"\"\"\n    ret = lib.vaccel_resource_register(\n        self._c_ptr_or_raise,\n        session._c_ptr_or_raise,\n    )\n    if ret != 0:\n        raise FFIError(\n            ret,\n            f\"Could not register resource {self.id} \"\n            f\"with session {session.id}\",\n        )\n    self.__sessions.append(session)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource.Resource.register(session)","title":"<code>session</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource.Resource.unregister","title":"unregister","text":"<pre><code>unregister(session: BaseSession) -&gt; None\n</code></pre> <p>Unregister the resource from a session.</p> <p>Parameters:</p> Name Type Description Default <code>BaseSession</code> <p>The session to unregister the resource from.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If resource unregistration fails.</p> Source code in <code>          vaccel/resource.py</code> <pre><code>def unregister(self, session: \"Session\") -&gt; None:\n    \"\"\"Unregister the resource from a session.\n\n    Args:\n        session: The session to unregister the resource from.\n\n    Raises:\n        FFIError: If resource unregistration fails.\n    \"\"\"\n    ret = lib.vaccel_resource_unregister(\n        self._c_ptr_or_raise,\n        session._c_ptr_or_raise,\n    )\n    if ret != 0:\n        raise FFIError(\n            ret,\n            f\"Could not unregister resource {self.id} \"\n            f\"from session {session.id}\",\n        )\n    self.__sessions.remove(session)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/resource/#vaccel.resource.Resource.unregister(session)","title":"<code>session</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/","title":"session","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session","title":"session","text":"<p>Interface to the <code>struct vaccel_session</code> C object.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.BaseSession","title":"BaseSession","text":"<pre><code>BaseSession(flags: int = 0)\n</code></pre> <p>               Bases: <code>CType</code></p> <p>Wrapper for the <code>struct vaccel_session</code> C object.</p> <p>Manages the creation and initialization of a C <code>struct vaccel_session</code> and provides access to it through Python properties.</p> Inherits <p>CType: Abstract base class for defining C data types.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The flags to configure the session creation. Defaults to 0.</p> <code>0</code> Source code in <code>                vaccel/session.py</code> <pre><code>def __init__(self, flags: int = 0):\n    \"\"\"Initializes a new `BaseSession` object.\n\n    Args:\n        flags: The flags to configure the session creation. Defaults to 0.\n    \"\"\"\n    self._flags = flags\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.BaseSession(flags)","title":"<code>flags</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.BaseSession.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.BaseSession.flags","title":"flags  <code>property</code>","text":"<pre><code>flags: int\n</code></pre> <p>The session flags.</p> <p>Returns:</p> Type Description <code>int</code> <p>The flags set during session creation.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.BaseSession.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre> <p>The session identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>The session's unique ID.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.BaseSession.remote_id","title":"remote_id  <code>property</code>","text":"<pre><code>remote_id: int\n</code></pre> <p>The remote session identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>The session's remote ID.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.BaseSession.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_session`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.BaseSession.has_resource","title":"has_resource","text":"<pre><code>has_resource(resource: Resource) -&gt; bool\n</code></pre> <p>Check if a resource is registered with the session.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>The resource to check for registration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the resource is registered.</p> Source code in <code>          vaccel/session.py</code> <pre><code>def has_resource(self, resource: Resource) -&gt; bool:\n    \"\"\"Check if a resource is registered with the session.\n\n    Args:\n        resource: The resource to check for registration.\n\n    Returns:\n        True if the resource is registered.\n    \"\"\"\n    return (\n        lib.vaccel_session_has_resource(\n            self._c_ptr_or_raise, resource._c_ptr\n        )\n        != 0\n    )\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.BaseSession.has_resource(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session","title":"Session","text":"<pre><code>Session(flags: int = 0)\n</code></pre> <p>               Bases: <code>BaseSession</code>, <code>NoopMixin</code>, <code>GenopMixin</code>, <code>ExecMixin</code>, <code>ImageMixin</code>, <code>BlasMixin</code>, <code>FpgaMixin</code>, <code>MinmaxMixin</code>, <code>TFMixin</code>, <code>TFLiteMixin</code>, <code>TorchMixin</code></p> <p>Extended session with operations' functionalities.</p> <p>Inherits from <code>BaseSession</code> and the operation mixins, adding support for the operation functions.</p> Inherits <p>BaseSession: Core session management. NoopMixin: Debug operation. GenopMixin: Generic operation. ExecMixin: Exec operations. ImageMixin: Image-related operations. BlasMixin: BLAS operations. FpgaMixin: FPGA operations. MinmaxMixin: Minmax operations. TensorflowMixin: TensorFlow operations.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The flags to configure the session creation. Defaults to 0.</p> <code>0</code> Source code in <code>                vaccel/session.py</code> <pre><code>def __init__(self, flags: int = 0):\n    \"\"\"Initializes a new `BaseSession` object.\n\n    Args:\n        flags: The flags to configure the session creation. Defaults to 0.\n    \"\"\"\n    self._flags = flags\n    super().__init__()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session(flags)","title":"<code>flags</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.c_size","title":"c_size  <code>property</code>","text":"<pre><code>c_size: int\n</code></pre> <p>Returns the size of the object in bytes.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.flags","title":"flags  <code>property</code>","text":"<pre><code>flags: int\n</code></pre> <p>The session flags.</p> <p>Returns:</p> Type Description <code>int</code> <p>The flags set during session creation.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre> <p>The session identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>The session's unique ID.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.remote_id","title":"remote_id  <code>property</code>","text":"<pre><code>remote_id: int\n</code></pre> <p>The remote session identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>The session's remote ID.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.value","title":"value  <code>property</code>","text":"<pre><code>value: CData\n</code></pre> <p>Returns the value of the underlying C struct.</p> <p>Returns:</p> Type Description <code>CData</code> <p>The dereferenced 'struct vaccel_session`</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.classify","title":"classify","text":"<pre><code>classify(image: bytes) -&gt; (str, str)\n</code></pre> <p>Performs the image classification operation.</p> <p>Wraps the <code>vaccel_image_classification()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>(str, str)</code> <p>A tuple containing: - The classification tag. - The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def classify(self, image: bytes) -&gt; (str, str):\n    \"\"\"Performs the image classification operation.\n\n    Wraps the `vaccel_image_classification()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        A tuple containing:\n            - The classification tag.\n            - The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_text = CBytes(bytearray(self._out_len))\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_classification(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_text._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_text),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image classification failed\")\n\n    return out_text.to_str(), out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.classify(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.depth","title":"depth","text":"<pre><code>depth(image: bytes) -&gt; str\n</code></pre> <p>Performs the image depth estimation operation.</p> <p>Wraps the <code>vaccel_image_depth()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def depth(self, image: bytes) -&gt; str:\n    \"\"\"Performs the image depth estimation operation.\n\n    Wraps the `vaccel_image_depth()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_depth(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image depth estimation failed\")\n\n    return out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.depth(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.detect","title":"detect","text":"<pre><code>detect(image: bytes) -&gt; str\n</code></pre> <p>Performs the image detection operation.</p> <p>Wraps the <code>vaccel_image_detection()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def detect(self, image: bytes) -&gt; str:\n    \"\"\"Performs the image detection operation.\n\n    Wraps the `vaccel_image_detection()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_detection(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image detection failed\")\n\n    return out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.detect(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.exec","title":"exec","text":"<pre><code>exec(\n    library: str | Path,\n    symbol: str,\n    arg_read: list[Any] | None = None,\n    arg_write: list[Any] | None = None,\n) -&gt; list[Any] | None\n</code></pre> <p>Performs the Exec operation.</p> <p>Wraps the <code>vaccel_exec()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>str | Path</code> <p>The path to the shared object containing the function that will be called.</p> required <code>str</code> <p>The name of the function contained in the above shared object.</p> required <code>list[Any] | None</code> <p>The input arguments that will be passed to the called function.</p> <code>None</code> <code>list[Any] | None</code> <p>The output arguments that will be passed to the called function.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Any] | None</code> <p>The resulting outputs.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/exec.py</code> <pre><code>def exec(\n    self,\n    library: str | Path,\n    symbol: str,\n    arg_read: list[Any] | None = None,\n    arg_write: list[Any] | None = None,\n) -&gt; list[Any] | None:\n    \"\"\"Performs the Exec operation.\n\n    Wraps the `vaccel_exec()` C operation.\n\n    Args:\n        library: The path to the shared object containing the function that\n            will be called.\n        symbol: The name of the function contained in the above shared\n            object.\n        arg_read: The input arguments that will be passed to the\n            called function.\n        arg_write: The output arguments that will be passed to the\n            called function.\n\n    Returns:\n        The resulting outputs.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    if arg_read is not None:\n        c_arg_read = CList([Arg(arg) for arg in arg_read])\n        c_arg_read_ptr = c_arg_read._c_ptr\n        c_arg_read_len = len(c_arg_read)\n    else:\n        c_arg_read = None\n        c_arg_read_ptr = ffi.NULL\n        c_arg_read_len = 0\n\n    if arg_write is not None:\n        c_arg_write = CList([Arg(arg) for arg in arg_write])\n        c_arg_write_ptr = c_arg_write._c_ptr\n        c_arg_write_len = len(c_arg_write)\n    else:\n        c_arg_write = None\n        c_arg_write_ptr = ffi.NULL\n        c_arg_write_len = 0\n\n    ret = lib.vaccel_exec(\n        self._c_ptr_or_raise,\n        str(library).encode(),\n        symbol.encode(),\n        c_arg_read_ptr,\n        c_arg_read_len,\n        c_arg_write_ptr,\n        c_arg_write_len,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Exec operation failed\")\n\n    if c_arg_write is not None:\n        return [c_arg_write[i].buf for i in range(len(c_arg_write))]\n    return None\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.exec(library)","title":"<code>library</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.exec(symbol)","title":"<code>symbol</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.exec(arg_read)","title":"<code>arg_read</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.exec(arg_write)","title":"<code>arg_write</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.exec_with_resource","title":"exec_with_resource","text":"<pre><code>exec_with_resource(\n    resource: Resource,\n    symbol: str,\n    arg_read: list[Any] | None = None,\n    arg_write: list[Any] | None = None,\n) -&gt; list[Any] | None\n</code></pre> <p>Performs the Exec with resource operation.</p> <p>Wraps the <code>vaccel_exec_with_resource()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>The resource of the shared object containing the function that will be called.</p> required <code>str</code> <p>The name of the function contained in the above shared object.</p> required <code>list[Any] | None</code> <p>The input arguments that will be passed to the called function.</p> <code>None</code> <code>list[Any] | None</code> <p>The output arguments that will be passed to the called function.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Any] | None</code> <p>The resulting outputs.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/exec.py</code> <pre><code>def exec_with_resource(\n    self,\n    resource: Resource,\n    symbol: str,\n    arg_read: list[Any] | None = None,\n    arg_write: list[Any] | None = None,\n) -&gt; list[Any] | None:\n    \"\"\"Performs the Exec with resource operation.\n\n    Wraps the `vaccel_exec_with_resource()` C operation.\n\n    Args:\n        resource: The resource of the shared object containing the function\n            that will be called.\n        symbol: The name of the function contained in the above shared\n            object.\n        arg_read: The input arguments that will be passed to the\n            called function.\n        arg_write: The output arguments that will be passed to the\n            called function.\n\n    Returns:\n        The resulting outputs.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    if arg_read is not None:\n        c_arg_read = CList([Arg(arg) for arg in arg_read])\n        c_arg_read_ptr = c_arg_read._c_ptr\n        c_arg_read_len = len(c_arg_read)\n    else:\n        c_arg_read = None\n        c_arg_read_ptr = ffi.NULL\n        c_arg_read_len = 0\n\n    if arg_write is not None:\n        c_arg_write = CList([Arg(arg) for arg in arg_write])\n        c_arg_write_ptr = c_arg_write._c_ptr\n        c_arg_write_len = len(c_arg_write)\n    else:\n        c_arg_write = None\n        c_arg_write_ptr = ffi.NULL\n        c_arg_write_len = 0\n\n    ret = lib.vaccel_exec_with_resource(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        symbol.encode(),\n        c_arg_read_ptr,\n        c_arg_read_len,\n        c_arg_write_ptr,\n        c_arg_write_len,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Exec with resource operation failed\")\n\n    if c_arg_write is not None:\n        return [c_arg_write[i].buf for i in range(len(c_arg_write))]\n    return None\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.exec_with_resource(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.exec_with_resource(symbol)","title":"<code>symbol</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.exec_with_resource(arg_read)","title":"<code>arg_read</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.exec_with_resource(arg_write)","title":"<code>arg_write</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.fpga_arraycopy","title":"fpga_arraycopy","text":"<pre><code>fpga_arraycopy(a: list[int]) -&gt; list[int]\n</code></pre> <p>Performs the matrix copying operation.</p> <p>Wraps the <code>vaccel_fpga_arraycopy()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The matrix A to be copied.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>A copy of the matrix A.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/fpga.py</code> <pre><code>def fpga_arraycopy(self, a: list[int]) -&gt; list[int]:\n    \"\"\"Performs the matrix copying operation.\n\n    Wraps the `vaccel_fpga_arraycopy()` C operation.\n\n    Args:\n        a: The matrix A to be copied.\n\n    Returns:\n        A copy of the matrix A.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_out_a = CList([0] * len(a))\n\n    ret = lib.vaccel_fpga_arraycopy(\n        self._c_ptr_or_raise, c_a._c_ptr, c_out_a._c_ptr, len(c_a)\n    )\n    if ret != 0:\n        raise FFIError(ret, \"FPGA array copy failed\")\n\n    return [int(item) for item in c_out_a.value]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.fpga_arraycopy(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.fpga_mmult","title":"fpga_mmult","text":"<pre><code>fpga_mmult(a: list[float], b: list[float]) -&gt; list[float]\n</code></pre> <p>Performs the matrix multiplication operation.</p> <p>Wraps the <code>vaccel_fpga_mmult()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[float]</code> <p>A matrix A.</p> required <code>list[float]</code> <p>A matrix B.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The multiplication result of matrices A and B.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/fpga.py</code> <pre><code>def fpga_mmult(self, a: list[float], b: list[float]) -&gt; list[float]:\n    \"\"\"Performs the matrix multiplication operation.\n\n    Wraps the `vaccel_fpga_mmult()` C operation.\n\n    Args:\n        a: A matrix A.\n        b: A matrix B.\n\n    Returns:\n        The multiplication result of matrices A and B.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_b = CList(b)\n    c_c = CList([float(0)] * len(a))\n\n    ret = lib.vaccel_fpga_mmult(\n        self._c_ptr_or_raise, c_a._c_ptr, c_b._c_ptr, c_c._c_ptr, len(c_a)\n    )\n    if ret != 0:\n        raise FFIError(ret, \"FPGA matrix multiplication failed\")\n\n    return [float(item) for item in c_c.value]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.fpga_mmult(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.fpga_mmult(b)","title":"<code>b</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.fpga_parallel","title":"fpga_parallel","text":"<pre><code>fpga_parallel(a: list[float], b: list[float]) -&gt; (list[float], list[float])\n</code></pre> <p>Performs the parallel matrix addition and multiplication operation.</p> <p>Wraps the <code>vaccel_fpga_parallel()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[float]</code> <p>A matrix A.</p> required <code>list[float]</code> <p>A matrix B.</p> required <p>Returns:</p> Type Description <code>(list[float], list[float])</code> <p>A tuple containing: - The result of the addition of matrices A and B. - The result of the multiplication of matrices A and B.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/fpga.py</code> <pre><code>def fpga_parallel(\n    self, a: list[float], b: list[float]\n) -&gt; (list[float], list[float]):\n    \"\"\"Performs the parallel matrix addition and multiplication operation.\n\n    Wraps the `vaccel_fpga_parallel()` C operation.\n\n    Args:\n        a: A matrix A.\n        b: A matrix B.\n\n    Returns:\n        A tuple containing:\n            - The result of the addition of matrices A and B.\n            - The result of the multiplication of matrices A and B.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_b = CList(b)\n    c_add_output = CList([float(0)] * len(a))\n    c_mult_output = CList([float(0)] * len(a))\n\n    ret = lib.vaccel_fpga_parallel(\n        self._c_ptr_or_raise,\n        c_a._c_ptr,\n        c_b._c_ptr,\n        c_add_output._c_ptr,\n        c_mult_output._c_ptr,\n        len(c_a),\n    )\n    if ret != 0:\n        raise FFIError(\n            ret, \"FPGA parallel matrix addition and multiplication failed\"\n        )\n\n    return (\n        [float(item) for item in c_add_output.value],\n        [float(item) for item in c_mult_output.value],\n    )\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.fpga_parallel(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.fpga_parallel(b)","title":"<code>b</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.fpga_vadd","title":"fpga_vadd","text":"<pre><code>fpga_vadd(a: list[float], b: list[float]) -&gt; list[float]\n</code></pre> <p>Performs the matrix addition operation.</p> <p>Wraps the <code>vaccel_fpga_vadd()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[float]</code> <p>A matrix A.</p> required <code>list[float]</code> <p>A matrix B.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The addition result of matrices A and B.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/fpga.py</code> <pre><code>def fpga_vadd(self, a: list[float], b: list[float]) -&gt; list[float]:\n    \"\"\"Performs the matrix addition operation.\n\n    Wraps the `vaccel_fpga_vadd()` C operation.\n\n    Args:\n        a: A matrix A.\n        b: A matrix B.\n\n    Returns:\n        The addition result of matrices A and B.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_b = CList(b)\n    c_c = CList([float(0)] * len(a))\n\n    ret = lib.vaccel_fpga_vadd(\n        self._c_ptr_or_raise,\n        c_a._c_ptr,\n        c_b._c_ptr,\n        c_c._c_ptr,\n        len(c_a),\n        len(c_b),\n    )\n    if ret != 0:\n        raise FFIError(ret, \"FPGA vector addition failed\")\n\n    return [float(item) for item in c_c.value]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.fpga_vadd(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.fpga_vadd(b)","title":"<code>b</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.genop","title":"genop","text":"<pre><code>genop(arg_read: list[Arg], arg_write: list[Arg]) -&gt; None\n</code></pre> <p>Performs the Generic operation.</p> <p>Wraps the <code>vaccel_genop()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>list[Arg]</code> <p>The input arguments of the operation.</p> required <code>list[Arg]</code> <p>The output arguments of the operation. Modified in place.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/genop.py</code> <pre><code>def genop(self, arg_read: list[Arg], arg_write: list[Arg]) -&gt; None:\n    \"\"\"Performs the Generic operation.\n\n    Wraps the `vaccel_genop()` C operation.\n\n    Args:\n        arg_read: The input arguments of the operation.\n        arg_write: The output arguments of the operation. Modified in place.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_args_read = CList(arg_read)\n    c_args_write = CList(arg_write)\n\n    ret = lib.vaccel_genop(\n        self._c_ptr_or_raise,\n        c_args_read._c_ptr,\n        len(c_args_read),\n        c_args_write._c_ptr,\n        len(c_args_write),\n    )\n    if ret:\n        raise FFIError(ret, \"Generic operation failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.genop(arg_read)","title":"<code>arg_read</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.genop(arg_write)","title":"<code>arg_write</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.has_resource","title":"has_resource","text":"<pre><code>has_resource(resource: Resource) -&gt; bool\n</code></pre> <p>Check if a resource is registered with the session.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>The resource to check for registration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the resource is registered.</p> Source code in <code>          vaccel/session.py</code> <pre><code>def has_resource(self, resource: Resource) -&gt; bool:\n    \"\"\"Check if a resource is registered with the session.\n\n    Args:\n        resource: The resource to check for registration.\n\n    Returns:\n        True if the resource is registered.\n    \"\"\"\n    return (\n        lib.vaccel_session_has_resource(\n            self._c_ptr_or_raise, resource._c_ptr\n        )\n        != 0\n    )\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.has_resource(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.minmax","title":"minmax","text":"<pre><code>minmax(\n    indata: bytes, ndata: int, low_threshold: int, high_threshold: int\n) -&gt; (bytes, float, float)\n</code></pre> <p>Performs the minmax operation.</p> <p>Wraps the <code>vaccel_minmax()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The input data as a <code>bytes</code> object.</p> required <code>int</code> <p>The number of data to be read provided data object.</p> required <code>int</code> <p>The threshold for the min value.</p> required <code>int</code> <p>The threshold for the max value.</p> required <p>Returns:</p> Type Description <code>(bytes, float, float)</code> <p>A tuple containing: - The resulting output data. - The detected min value of the data. - The detected max value of the data.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/minmax.py</code> <pre><code>def minmax(\n    self, indata: bytes, ndata: int, low_threshold: int, high_threshold: int\n) -&gt; (bytes, float, float):\n    \"\"\"Performs the minmax operation.\n\n    Wraps the `vaccel_minmax()` C operation.\n\n    Args:\n        indata: The input data as a `bytes` object.\n        ndata: The number of data to be read provided data object.\n        low_threshold: The threshold for the min value.\n        high_threshold: The threshold for the max value.\n\n    Returns:\n        A tuple containing:\n            - The resulting output data.\n            - The detected min value of the data.\n            - The detected max value of the data.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_indata = CBytes(indata)\n    c_outdata = CBytes(bytearray(ndata * ffi.sizeof(\"double\")))\n    c_min = CFloat(float(0), \"double\")\n    c_max = CFloat(float(0), \"double\")\n\n    ret = lib.vaccel_minmax(\n        self._c_ptr_or_raise,\n        c_indata._as_c_array(\"double\"),\n        ndata,\n        low_threshold,\n        high_threshold,\n        c_outdata._as_c_array(\"double\"),\n        c_min._c_ptr,\n        c_max._c_ptr,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Minmax operation failed\")\n\n    return (c_outdata.value, c_min.value, c_max.value)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.minmax(indata)","title":"<code>indata</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.minmax(ndata)","title":"<code>ndata</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.minmax(low_threshold)","title":"<code>low_threshold</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.minmax(high_threshold)","title":"<code>high_threshold</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.noop","title":"noop","text":"<pre><code>noop() -&gt; None\n</code></pre> <p>Performs the NoOp operation.</p> <p>Wraps the <code>vaccel_noop()</code> C operation.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/noop.py</code> <pre><code>def noop(self) -&gt; None:\n    \"\"\"Performs the NoOp operation.\n\n    Wraps the `vaccel_noop()` C operation.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_noop(self._c_ptr_or_raise)\n    if ret != 0:\n        raise FFIError(ret, \"NoOp operation failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.pose","title":"pose","text":"<pre><code>pose(image: bytes) -&gt; str\n</code></pre> <p>Performs the image pose estimation operation.</p> <p>Wraps the <code>vaccel_image_pose()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def pose(self, image: bytes) -&gt; str:\n    \"\"\"Performs the image pose estimation operation.\n\n    Wraps the `vaccel_image_pose()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_pose(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image pose estimation failed\")\n\n    return out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.pose(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.segment","title":"segment","text":"<pre><code>segment(image: bytes) -&gt; str\n</code></pre> <p>Performs the image segmentation operations.</p> <p>Wraps the <code>vaccel_image_segmentation()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The image data as a <code>bytes</code> object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resulting image filename.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/image.py</code> <pre><code>def segment(self, image: bytes) -&gt; str:\n    \"\"\"Performs the image segmentation operations.\n\n    Wraps the `vaccel_image_segmentation()` C operation.\n\n    Args:\n        image: The image data as a `bytes` object.\n\n    Returns:\n        The resulting image filename.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    img = CBytes(image)\n    out_imgname = CBytes(bytearray(self._out_len))\n\n    ret = lib.vaccel_image_segmentation(\n        self._c_ptr_or_raise,\n        img._c_ptr,\n        out_imgname._c_ptr,\n        len(img),\n        len(out_imgname),\n    )\n    if ret:\n        raise FFIError(ret, \"Image segmentation failed\")\n\n    return out_imgname.to_str()\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.segment(image)","title":"<code>image</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.sgemm","title":"sgemm","text":"<pre><code>sgemm(\n    m: int,\n    n: int,\n    k: int,\n    alpha: float,\n    a: list[float],\n    lda: int,\n    b: list[float],\n    ldb: int,\n    beta: float,\n    ldc: int,\n) -&gt; list[float]\n</code></pre> <p>Performs the SGEMM operation.</p> <p>Wraps the <code>vaccel_sgemm()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The number of rows in matrix A and matrix C.</p> required <code>int</code> <p>The number of columns in matrix B and matrix C.</p> required <code>int</code> <p>The number of columns in matrix A and rows in matrix B.</p> required <code>float</code> <p>Scalar multiplier for the matrix product A * B.</p> required <code>list[float]</code> <p>The matrix A in row-major order with shape (m, k).</p> required <code>int</code> <p>The leading dimension of matrix A (usually m).</p> required <code>list[float]</code> <p>The matrix B in row-major order with shape (k, n).</p> required <code>int</code> <p>The leading dimension of matrix B (usually k).</p> required <code>float</code> <p>Scalar multiplier for matrix C.</p> required <code>int</code> <p>The leading dimension of matrix C (usually m).</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The resulting matrix C in row-major order with shape (m, n).</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/blas.py</code> <pre><code>def sgemm(\n    self,\n    m: int,\n    n: int,\n    k: int,\n    alpha: float,\n    a: list[float],\n    lda: int,\n    b: list[float],\n    ldb: int,\n    beta: float,\n    ldc: int,\n) -&gt; list[float]:\n    \"\"\"Performs the SGEMM operation.\n\n    Wraps the `vaccel_sgemm()` C operation.\n\n    Args:\n        m: The number of rows in matrix A and matrix C.\n        n: The number of columns in matrix B and matrix C.\n        k: The number of columns in matrix A and rows in matrix B.\n        alpha: Scalar multiplier for the matrix product A * B.\n        a: The matrix A in row-major order with shape (m, k).\n        lda: The leading dimension of matrix A (usually m).\n        b: The matrix B in row-major order with shape (k, n).\n        ldb: The leading dimension of matrix B (usually k).\n        beta: Scalar multiplier for matrix C.\n        ldc: The leading dimension of matrix C (usually m).\n\n    Returns:\n        The resulting matrix C in row-major order with shape (m, n).\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_a = CList(a)\n    c_b = CList(b)\n    c_c = CList([float(0)] * m * n)\n\n    ret = lib.vaccel_sgemm(\n        self._c_ptr_or_raise,\n        m,\n        n,\n        k,\n        alpha,\n        c_a._c_ptr,\n        lda,\n        c_b._c_ptr,\n        ldb,\n        beta,\n        c_c._c_ptr,\n        ldc,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"SGEMM failed\")\n\n    return c_c.value\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.sgemm(m)","title":"<code>m</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.sgemm(n)","title":"<code>n</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.sgemm(k)","title":"<code>k</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.sgemm(alpha)","title":"<code>alpha</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.sgemm(a)","title":"<code>a</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.sgemm(lda)","title":"<code>lda</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.sgemm(b)","title":"<code>b</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.sgemm(ldb)","title":"<code>ldb</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.sgemm(beta)","title":"<code>beta</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.sgemm(ldc)","title":"<code>ldc</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tf_model_load","title":"tf_model_load","text":"<pre><code>tf_model_load(resource: Resource) -&gt; Status\n</code></pre> <p>Performs the Tensorflow model load operation.</p> <p>Wraps the <code>vaccel_tf_model_load()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to load.</p> required <p>Returns:</p> Type Description <code>Status</code> <p>The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/mixin.py</code> <pre><code>def tf_model_load(self, resource: Resource) -&gt; Status:\n    \"\"\"Performs the Tensorflow model load operation.\n\n    Wraps the `vaccel_tf_model_load()` C operation.\n\n    Args:\n        resource: A resource with the model to load.\n\n    Returns:\n        The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    status = Status()\n    ret = lib.vaccel_tf_model_load(\n        self._c_ptr_or_raise, resource._c_ptr, status._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow model load failed\")\n    return status\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tf_model_load(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tf_model_run","title":"tf_model_run","text":"<pre><code>tf_model_run(\n    resource: Resource,\n    in_nodes: list[Node],\n    in_tensors: list[Tensor],\n    out_nodes: list[Node],\n    run_options: Buffer | None = None,\n) -&gt; (list[Tensor], Status)\n</code></pre> <p>Performs the Tensorflow model run operation.</p> <p>Wraps the <code>vaccel_tf_model_run()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to run.</p> required <code>list[Node]</code> <p>The input nodes for the inference.</p> required <code>list[Tensor]</code> <p>The input tensors for the inference.</p> required <code>list[Node]</code> <p>The output nodes for the inference.</p> required <code>Buffer | None</code> <p>The inference options.</p> <code>None</code> <p>Returns:</p> Type Description <code>(list[Tensor], Status)</code> <p>A tuple containing: - The output tensors - The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/mixin.py</code> <pre><code>def tf_model_run(\n    self,\n    resource: Resource,\n    in_nodes: list[Node],\n    in_tensors: list[Tensor],\n    out_nodes: list[Node],\n    run_options: Buffer | None = None,\n) -&gt; (list[Tensor], Status):\n    \"\"\"Performs the Tensorflow model run operation.\n\n    Wraps the `vaccel_tf_model_run()` C operation.\n\n    Args:\n        resource: A resource with the model to run.\n        in_nodes: The input nodes for the inference.\n        in_tensors: The input tensors for the inference.\n        out_nodes: The output nodes for the inference.\n        run_options: The inference options.\n\n    Returns:\n        A tuple containing:\n            - The output tensors\n            - The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    run_options_ptr = (\n        ffi.NULL if run_options is None else run_options._c_ptr\n    )\n    c_in_nodes = CList(in_nodes)\n    c_in_tensors = CList.from_ptrs(in_tensors)\n    c_out_nodes = CList(out_nodes)\n    c_out_tensors = CList.from_ptrs([Tensor.empty()] * len(c_out_nodes))\n    status = Status()\n\n    ret = lib.vaccel_tf_model_run(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        run_options_ptr,\n        c_in_nodes._c_ptr,\n        c_in_tensors._c_ptr,\n        len(c_in_nodes),\n        c_out_nodes._c_ptr,\n        c_out_tensors._c_ptr,\n        len(c_out_nodes),\n        status._c_ptr,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow model run failed\")\n\n    out_tensors = [Tensor.from_c_obj(t) for t in c_out_tensors.value]\n    return (out_tensors, status)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tf_model_run(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tf_model_run(in_nodes)","title":"<code>in_nodes</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tf_model_run(in_tensors)","title":"<code>in_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tf_model_run(out_nodes)","title":"<code>out_nodes</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tf_model_run(run_options)","title":"<code>run_options</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tf_model_unload","title":"tf_model_unload","text":"<pre><code>tf_model_unload(resource: Resource) -&gt; Status\n</code></pre> <p>Performs the Tensorflow model unload operation.</p> <p>Wraps the <code>vaccel_tf_model_unload()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to unload.</p> required <p>Returns:</p> Type Description <code>Status</code> <p>The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/mixin.py</code> <pre><code>def tf_model_unload(self, resource: Resource) -&gt; Status:\n    \"\"\"Performs the Tensorflow model unload operation.\n\n    Wraps the `vaccel_tf_model_unload()` C operation.\n\n    Args:\n        resource: A resource with the model to unload.\n\n    Returns:\n        The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    status = Status()\n    ret = lib.vaccel_tf_model_unload(\n        self._c_ptr_or_raise, resource._c_ptr, status._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow model unload failed\")\n    return status\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tf_model_unload(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tflite_model_load","title":"tflite_model_load","text":"<pre><code>tflite_model_load(resource: Resource) -&gt; None\n</code></pre> <p>Performs the Tensorflow Lite model load operation.</p> <p>Wraps the <code>vaccel_tflite_model_load()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to load.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/lite/mixin.py</code> <pre><code>def tflite_model_load(self, resource: Resource) -&gt; None:\n    \"\"\"Performs the Tensorflow Lite model load operation.\n\n    Wraps the `vaccel_tflite_model_load()` C operation.\n\n    Args:\n        resource: A resource with the model to load.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_tflite_model_load(\n        self._c_ptr_or_raise, resource._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow Lite model load failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tflite_model_load(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tflite_model_run","title":"tflite_model_run","text":"<pre><code>tflite_model_run(\n    resource: Resource, in_tensors: list[Tensor], nr_out_tensors: int = 1\n) -&gt; (list[Tensor], int)\n</code></pre> <p>Performs the Tensorflow Lite model run operation.</p> <p>Wraps the <code>vaccel_tflite_model_run()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to run.</p> required <code>list[Tensor]</code> <p>The input tensors for the inference.</p> required <code>int</code> <p>The number of output tensors. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>(list[Tensor], int)</code> <p>A tuple containing: - The output tensors - The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/lite/mixin.py</code> <pre><code>def tflite_model_run(\n    self,\n    resource: Resource,\n    in_tensors: list[Tensor],\n    nr_out_tensors: int = 1,\n) -&gt; (list[Tensor], int):\n    \"\"\"Performs the Tensorflow Lite model run operation.\n\n    Wraps the `vaccel_tflite_model_run()` C operation.\n\n    Args:\n        resource: A resource with the model to run.\n        in_tensors: The input tensors for the inference.\n        nr_out_tensors: The number of output tensors. Defaults to 1.\n\n    Returns:\n        A tuple containing:\n            - The output tensors\n            - The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    c_in_tensors = CList.from_ptrs(in_tensors)\n    c_out_tensors = CList.from_ptrs([Tensor.empty()] * nr_out_tensors)\n    status = CInt(0, \"uint8_t\")\n\n    ret = lib.vaccel_tflite_model_run(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        c_in_tensors._c_ptr,\n        len(c_in_tensors),\n        c_out_tensors._c_ptr,\n        len(c_out_tensors),\n        status._c_ptr,\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow Lite model run failed\")\n\n    out_tensors = [Tensor.from_c_obj(t) for t in c_out_tensors.value]\n    return (out_tensors, status.value)\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tflite_model_run(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tflite_model_run(in_tensors)","title":"<code>in_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tflite_model_run(nr_out_tensors)","title":"<code>nr_out_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tflite_model_unload","title":"tflite_model_unload","text":"<pre><code>tflite_model_unload(resource: Resource) -&gt; None\n</code></pre> <p>Performs the Tensorflow Lite model unload operation.</p> <p>Wraps the <code>vaccel_tflite_model_unload()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to unload.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The status of the operation execution.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/tf/lite/mixin.py</code> <pre><code>def tflite_model_unload(self, resource: Resource) -&gt; None:\n    \"\"\"Performs the Tensorflow Lite model unload operation.\n\n    Wraps the `vaccel_tflite_model_unload()` C operation.\n\n    Args:\n        resource: A resource with the model to unload.\n\n    Returns:\n        The status of the operation execution.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_tflite_model_unload(\n        self._c_ptr_or_raise, resource._c_ptr\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Tensorflow Lite model unload failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.tflite_model_unload(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.torch_model_load","title":"torch_model_load","text":"<pre><code>torch_model_load(resource: Resource) -&gt; None\n</code></pre> <p>Performs the Torch model load operation.</p> <p>Wraps the <code>vaccel_torch_model_load()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to load.</p> required <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/torch/mixin.py</code> <pre><code>def torch_model_load(self, resource: Resource) -&gt; None:\n    \"\"\"Performs the Torch model load operation.\n\n    Wraps the `vaccel_torch_model_load()` C operation.\n\n    Args:\n        resource: A resource with the model to load.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_torch_model_load(self._c_ptr_or_raise, resource._c_ptr)\n    if ret != 0:\n        raise FFIError(ret, \"Torch model load failed\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.torch_model_load(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.torch_model_run","title":"torch_model_run","text":"<pre><code>torch_model_run(\n    resource: Resource,\n    in_tensors: list[Tensor],\n    nr_out_tensors: int = 1,\n    run_options: Buffer | None = None,\n) -&gt; list[Tensor]\n</code></pre> <p>Performs the Torch model run operation.</p> <p>Wraps the <code>vaccel_torch_model_run()</code> C operation.</p> <p>Parameters:</p> Name Type Description Default <code>Resource</code> <p>A resource with the model to run.</p> required <code>list[Tensor]</code> <p>The input tensors for the inference.</p> required <code>int</code> <p>The number of output tensors. Defaults to 1.</p> <code>1</code> <code>Buffer | None</code> <p>The inference options.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Tensor]</code> <p>The output tensors</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/ops/torch/mixin.py</code> <pre><code>def torch_model_run(\n    self,\n    resource: Resource,\n    in_tensors: list[Tensor],\n    nr_out_tensors: int = 1,\n    run_options: Buffer | None = None,\n) -&gt; list[Tensor]:\n    \"\"\"Performs the Torch model run operation.\n\n    Wraps the `vaccel_torch_model_run()` C operation.\n\n    Args:\n        resource: A resource with the model to run.\n        in_tensors: The input tensors for the inference.\n        nr_out_tensors: The number of output tensors. Defaults to 1.\n        run_options: The inference options.\n\n    Returns:\n        The output tensors\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    run_options_ptr = (\n        ffi.NULL if run_options is None else run_options._c_ptr\n    )\n    c_in_tensors = CList.from_ptrs(in_tensors)\n    c_out_tensors = CList.from_ptrs([Tensor.empty()] * nr_out_tensors)\n\n    ret = lib.vaccel_torch_model_run(\n        self._c_ptr_or_raise,\n        resource._c_ptr,\n        run_options_ptr,\n        c_in_tensors._c_ptr,\n        len(c_in_tensors),\n        c_out_tensors._c_ptr,\n        len(c_out_tensors),\n    )\n    if ret != 0:\n        raise FFIError(ret, \"Torch jitload forward operation failed\")\n\n    return [Tensor.from_c_obj(t) for t in c_out_tensors.value]\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.torch_model_run(resource)","title":"<code>resource</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.torch_model_run(in_tensors)","title":"<code>in_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.torch_model_run(nr_out_tensors)","title":"<code>nr_out_tensors</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/session/#vaccel.session.Session.torch_model_run(run_options)","title":"<code>run_options</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/vaccel/","title":"vaccel","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/vaccel/#vaccel.vaccel","title":"vaccel","text":"<p>Interface to common vaccel C functions.</p>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/vaccel/#vaccel.vaccel.bootstrap","title":"bootstrap","text":"<pre><code>bootstrap(config: Config | None = None) -&gt; None\n</code></pre> <p>Initializes the vAccel library.</p> <p>Parameters:</p> Name Type Description Default <code>Config | None</code> <p>A configuration object for the library. If None, defaults are used.</p> <code>None</code> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/vaccel.py</code> <pre><code>def bootstrap(config: Config | None = None) -&gt; None:\n    \"\"\"Initializes the vAccel library.\n\n    Args:\n        config (Config | None): A configuration object for the library. If None,\n            defaults are used.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    if config is None:\n        ret = lib.vaccel_bootstrap()\n    else:\n        ret = lib.vaccel_bootstrap_with_config(config._c_ptr)\n    if ret != 0:\n        raise FFIError(ret, \"Could not bootstrap vAccel library\")\n</code></pre>"},{"location":"language-bindings/python-bindings/api-reference/vaccel/vaccel/#vaccel.vaccel.bootstrap(config)","title":"<code>config</code>","text":""},{"location":"language-bindings/python-bindings/api-reference/vaccel/vaccel/#vaccel.vaccel.cleanup","title":"cleanup","text":"<pre><code>cleanup() -&gt; None\n</code></pre> <p>Cleans up the vAccel library resources.</p> <p>This function is called automatically at program exit, but can also be invoked explicitly if needed.</p> <p>Raises:</p> Type Description <code>FFIError</code> <p>If the C operation fails.</p> Source code in <code>          vaccel/vaccel.py</code> <pre><code>@atexit.register\ndef cleanup() -&gt; None:\n    \"\"\"Cleans up the vAccel library resources.\n\n    This function is called automatically at program exit, but can also be\n    invoked explicitly if needed.\n\n    Raises:\n        FFIError: If the C operation fails.\n    \"\"\"\n    ret = lib.vaccel_cleanup()\n    if ret != 0:\n        raise FFIError(ret, \"Could not cleanup vAccel library objects\")\n</code></pre>"}]}